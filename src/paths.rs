use crate::util::ThanixClient;
use crate::types::*;
use serde_qs;
use reqwest::Error;

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CircuitsCircuitTerminationsListQuery {
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	/// Circuit
	circuit_id: Option<Vec<i64>>,
	/// Circuit
	circuit_id__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	port_speed: Option<Vec<i64>>,
	port_speed__empty: Option<bool>,
	port_speed__gt: Option<Vec<i64>>,
	port_speed__gte: Option<Vec<i64>>,
	port_speed__lt: Option<Vec<i64>>,
	port_speed__lte: Option<Vec<i64>>,
	port_speed__n: Option<Vec<i64>>,
	/// ProviderNetwork (ID)
	provider_network_id: Option<Vec<i64>>,
	/// ProviderNetwork (ID)
	provider_network_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	term_side: Option<String>,
	term_side__n: Option<String>,
	updated_by_request: Option<String>,
	upstream_speed: Option<Vec<i64>>,
	upstream_speed__empty: Option<bool>,
	upstream_speed__gt: Option<Vec<i64>>,
	upstream_speed__gte: Option<Vec<i64>>,
	upstream_speed__lt: Option<Vec<i64>>,
	upstream_speed__lte: Option<Vec<i64>>,
	upstream_speed__n: Option<Vec<i64>>,
	xconnect_id: Option<Vec<String>>,
	xconnect_id__empty: Option<bool>,
	xconnect_id__ic: Option<Vec<String>>,
	xconnect_id__ie: Option<Vec<String>>,
	xconnect_id__iew: Option<Vec<String>>,
	xconnect_id__isw: Option<Vec<String>>,
	xconnect_id__n: Option<Vec<String>>,
	xconnect_id__nic: Option<Vec<String>>,
	xconnect_id__nie: Option<Vec<String>>,
	xconnect_id__niew: Option<Vec<String>>,
	xconnect_id__nisw: Option<Vec<String>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsListResponse {
	Http200(PaginatedCircuitTerminationList),
	#[default]
	None
}
/// Get a list of circuit termination objects.
pub fn circuits_circuit_terminations_list(state: &ThanixClient, query: CircuitsCircuitTerminationsListQuery) -> Result<CircuitsCircuitTerminationsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuit-terminations/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsListResponse::Http200(r#response.json::<PaginatedCircuitTerminationList>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsBulkUpdateResponse {
	Http200(Vec<CircuitTermination>),
	#[default]
	None
}
/// Put a list of circuit termination objects.
pub fn circuits_circuit_terminations_bulk_update(state: &ThanixClient, body: Vec<CircuitTerminationRequest>) -> Result<CircuitsCircuitTerminationsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/circuit-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsBulkUpdateResponse::Http200(r#response.json::<Vec<CircuitTermination>>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsCreateResponse {
	Http201(CircuitTermination),
	#[default]
	None
}
/// Post a list of circuit termination objects.
pub fn circuits_circuit_terminations_create(state: &ThanixClient, body: WritableCircuitTerminationRequest) -> Result<CircuitsCircuitTerminationsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/circuits/circuit-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CircuitsCircuitTerminationsCreateResponse::Http201(r#response.json::<CircuitTermination>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of circuit termination objects.
pub fn circuits_circuit_terminations_bulk_destroy(state: &ThanixClient, body: Vec<CircuitTerminationRequest>) -> Result<CircuitsCircuitTerminationsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/circuit-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsCircuitTerminationsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsBulkPartialUpdateResponse {
	Http200(Vec<CircuitTermination>),
	#[default]
	None
}
/// Patch a list of circuit termination objects.
pub fn circuits_circuit_terminations_bulk_partial_update(state: &ThanixClient, body: Vec<CircuitTerminationRequest>) -> Result<CircuitsCircuitTerminationsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/circuit-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<CircuitTermination>>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsRetrieveResponse {
	Http200(CircuitTermination),
	#[default]
	None
}
/// Get a circuit termination object.
pub fn circuits_circuit_terminations_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitTerminationsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuit-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsRetrieveResponse::Http200(r#response.json::<CircuitTermination>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsUpdateResponse {
	Http200(CircuitTermination),
	#[default]
	None
}
/// Put a circuit termination object.
pub fn circuits_circuit_terminations_update(state: &ThanixClient, body: WritableCircuitTerminationRequest, id: i64) -> Result<CircuitsCircuitTerminationsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/circuit-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsUpdateResponse::Http200(r#response.json::<CircuitTermination>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a circuit termination object.
pub fn circuits_circuit_terminations_destroy(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitTerminationsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/circuit-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsCircuitTerminationsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsPartialUpdateResponse {
	Http200(CircuitTermination),
	#[default]
	None
}
/// Patch a circuit termination object.
pub fn circuits_circuit_terminations_partial_update(state: &ThanixClient, body: PatchedWritableCircuitTerminationRequest, id: i64) -> Result<CircuitsCircuitTerminationsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/circuit-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsPartialUpdateResponse::Http200(r#response.json::<CircuitTermination>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTerminationsPathsRetrieveResponse {
	Http200(CircuitTermination),
	#[default]
	None
}
/// Return all CablePaths which traverse a given pass-through port.
pub fn circuits_circuit_terminations_paths_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitTerminationsPathsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuit-terminations/{id}/paths/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTerminationsPathsRetrieveResponse::Http200(r#response.json::<CircuitTermination>()?)) },
		_ => { Ok(CircuitsCircuitTerminationsPathsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CircuitsCircuitTypesListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesListResponse {
	Http200(PaginatedCircuitTypeList),
	#[default]
	None
}
/// Get a list of circuit type objects.
pub fn circuits_circuit_types_list(state: &ThanixClient, query: CircuitsCircuitTypesListQuery) -> Result<CircuitsCircuitTypesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuit-types/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTypesListResponse::Http200(r#response.json::<PaginatedCircuitTypeList>()?)) },
		_ => { Ok(CircuitsCircuitTypesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesBulkUpdateResponse {
	Http200(Vec<CircuitType>),
	#[default]
	None
}
/// Put a list of circuit type objects.
pub fn circuits_circuit_types_bulk_update(state: &ThanixClient, body: Vec<CircuitTypeRequest>) -> Result<CircuitsCircuitTypesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/circuit-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTypesBulkUpdateResponse::Http200(r#response.json::<Vec<CircuitType>>()?)) },
		_ => { Ok(CircuitsCircuitTypesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesCreateResponse {
	Http201(CircuitType),
	#[default]
	None
}
/// Post a list of circuit type objects.
pub fn circuits_circuit_types_create(state: &ThanixClient, body: CircuitTypeRequest) -> Result<CircuitsCircuitTypesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/circuits/circuit-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CircuitsCircuitTypesCreateResponse::Http201(r#response.json::<CircuitType>()?)) },
		_ => { Ok(CircuitsCircuitTypesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of circuit type objects.
pub fn circuits_circuit_types_bulk_destroy(state: &ThanixClient, body: Vec<CircuitTypeRequest>) -> Result<CircuitsCircuitTypesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/circuit-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsCircuitTypesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesBulkPartialUpdateResponse {
	Http200(Vec<CircuitType>),
	#[default]
	None
}
/// Patch a list of circuit type objects.
pub fn circuits_circuit_types_bulk_partial_update(state: &ThanixClient, body: Vec<CircuitTypeRequest>) -> Result<CircuitsCircuitTypesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/circuit-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTypesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<CircuitType>>()?)) },
		_ => { Ok(CircuitsCircuitTypesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesRetrieveResponse {
	Http200(CircuitType),
	#[default]
	None
}
/// Get a circuit type object.
pub fn circuits_circuit_types_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitTypesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuit-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTypesRetrieveResponse::Http200(r#response.json::<CircuitType>()?)) },
		_ => { Ok(CircuitsCircuitTypesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesUpdateResponse {
	Http200(CircuitType),
	#[default]
	None
}
/// Put a circuit type object.
pub fn circuits_circuit_types_update(state: &ThanixClient, body: CircuitTypeRequest, id: i64) -> Result<CircuitsCircuitTypesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/circuit-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTypesUpdateResponse::Http200(r#response.json::<CircuitType>()?)) },
		_ => { Ok(CircuitsCircuitTypesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a circuit type object.
pub fn circuits_circuit_types_destroy(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitTypesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/circuit-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsCircuitTypesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitTypesPartialUpdateResponse {
	Http200(CircuitType),
	#[default]
	None
}
/// Patch a circuit type object.
pub fn circuits_circuit_types_partial_update(state: &ThanixClient, body: PatchedCircuitTypeRequest, id: i64) -> Result<CircuitsCircuitTypesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/circuit-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitTypesPartialUpdateResponse::Http200(r#response.json::<CircuitType>()?)) },
		_ => { Ok(CircuitsCircuitTypesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CircuitsCircuitsListQuery {
	cid: Option<Vec<String>>,
	cid__empty: Option<bool>,
	cid__ic: Option<Vec<String>>,
	cid__ie: Option<Vec<String>>,
	cid__iew: Option<Vec<String>>,
	cid__isw: Option<Vec<String>>,
	cid__n: Option<Vec<String>>,
	cid__nic: Option<Vec<String>>,
	cid__nie: Option<Vec<String>>,
	cid__niew: Option<Vec<String>>,
	cid__nisw: Option<Vec<String>>,
	commit_rate: Option<Vec<i64>>,
	commit_rate__empty: Option<bool>,
	commit_rate__gt: Option<Vec<i64>>,
	commit_rate__gte: Option<Vec<i64>>,
	commit_rate__lt: Option<Vec<i64>>,
	commit_rate__lte: Option<Vec<i64>>,
	commit_rate__n: Option<Vec<i64>>,
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	install_date: Option<Vec<String>>,
	install_date__empty: Option<bool>,
	install_date__gt: Option<Vec<String>>,
	install_date__gte: Option<Vec<String>>,
	install_date__lt: Option<Vec<String>>,
	install_date__lte: Option<Vec<String>>,
	install_date__n: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Provider (slug)
	provider: Option<Vec<String>>,
	/// Provider (slug)
	provider__n: Option<Vec<String>>,
	/// Provider account (ID)
	provider_account_id: Option<Vec<i64>>,
	/// Provider account (ID)
	provider_account_id__n: Option<Vec<i64>>,
	/// Provider (ID)
	provider_id: Option<Vec<i64>>,
	/// Provider (ID)
	provider_id__n: Option<Vec<i64>>,
	/// Provider network (ID)
	provider_network_id: Option<Vec<i64>>,
	/// Provider network (ID)
	provider_network_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	termination_date: Option<Vec<String>>,
	termination_date__empty: Option<bool>,
	termination_date__gt: Option<Vec<String>>,
	termination_date__gte: Option<Vec<String>>,
	termination_date__lt: Option<Vec<String>>,
	termination_date__lte: Option<Vec<String>>,
	termination_date__n: Option<Vec<String>>,
	/// Circuit type (slug)
	r#type: Option<Vec<String>>,
	/// Circuit type (slug)
	type__n: Option<Vec<String>>,
	/// Circuit type (ID)
	type_id: Option<Vec<i64>>,
	/// Circuit type (ID)
	type_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsListResponse {
	Http200(PaginatedCircuitList),
	#[default]
	None
}
/// Get a list of circuit objects.
pub fn circuits_circuits_list(state: &ThanixClient, query: CircuitsCircuitsListQuery) -> Result<CircuitsCircuitsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuits/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitsListResponse::Http200(r#response.json::<PaginatedCircuitList>()?)) },
		_ => { Ok(CircuitsCircuitsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsBulkUpdateResponse {
	Http200(Vec<Circuit>),
	#[default]
	None
}
/// Put a list of circuit objects.
pub fn circuits_circuits_bulk_update(state: &ThanixClient, body: Vec<CircuitRequest>) -> Result<CircuitsCircuitsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/circuits/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitsBulkUpdateResponse::Http200(r#response.json::<Vec<Circuit>>()?)) },
		_ => { Ok(CircuitsCircuitsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsCreateResponse {
	Http201(Circuit),
	#[default]
	None
}
/// Post a list of circuit objects.
pub fn circuits_circuits_create(state: &ThanixClient, body: WritableCircuitRequest) -> Result<CircuitsCircuitsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/circuits/circuits/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CircuitsCircuitsCreateResponse::Http201(r#response.json::<Circuit>()?)) },
		_ => { Ok(CircuitsCircuitsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of circuit objects.
pub fn circuits_circuits_bulk_destroy(state: &ThanixClient, body: Vec<CircuitRequest>) -> Result<CircuitsCircuitsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/circuits/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsCircuitsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsBulkPartialUpdateResponse {
	Http200(Vec<Circuit>),
	#[default]
	None
}
/// Patch a list of circuit objects.
pub fn circuits_circuits_bulk_partial_update(state: &ThanixClient, body: Vec<CircuitRequest>) -> Result<CircuitsCircuitsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/circuits/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Circuit>>()?)) },
		_ => { Ok(CircuitsCircuitsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsRetrieveResponse {
	Http200(Circuit),
	#[default]
	None
}
/// Get a circuit object.
pub fn circuits_circuits_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/circuits/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitsRetrieveResponse::Http200(r#response.json::<Circuit>()?)) },
		_ => { Ok(CircuitsCircuitsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsUpdateResponse {
	Http200(Circuit),
	#[default]
	None
}
/// Put a circuit object.
pub fn circuits_circuits_update(state: &ThanixClient, body: WritableCircuitRequest, id: i64) -> Result<CircuitsCircuitsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/circuits/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitsUpdateResponse::Http200(r#response.json::<Circuit>()?)) },
		_ => { Ok(CircuitsCircuitsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a circuit object.
pub fn circuits_circuits_destroy(state: &ThanixClient, id: i64) -> Result<CircuitsCircuitsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/circuits/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsCircuitsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsCircuitsPartialUpdateResponse {
	Http200(Circuit),
	#[default]
	None
}
/// Patch a circuit object.
pub fn circuits_circuits_partial_update(state: &ThanixClient, body: PatchedWritableCircuitRequest, id: i64) -> Result<CircuitsCircuitsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/circuits/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsCircuitsPartialUpdateResponse::Http200(r#response.json::<Circuit>()?)) },
		_ => { Ok(CircuitsCircuitsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CircuitsProviderAccountsListQuery {
	account: Option<Vec<String>>,
	account__empty: Option<bool>,
	account__ic: Option<Vec<String>>,
	account__ie: Option<Vec<String>>,
	account__iew: Option<Vec<String>>,
	account__isw: Option<Vec<String>>,
	account__n: Option<Vec<String>>,
	account__nic: Option<Vec<String>>,
	account__nie: Option<Vec<String>>,
	account__niew: Option<Vec<String>>,
	account__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Provider (slug)
	provider: Option<Vec<String>>,
	/// Provider (slug)
	provider__n: Option<Vec<String>>,
	/// Provider (ID)
	provider_id: Option<Vec<i64>>,
	/// Provider (ID)
	provider_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsListResponse {
	Http200(PaginatedProviderAccountList),
	#[default]
	None
}
/// Get a list of provider account objects.
pub fn circuits_provider_accounts_list(state: &ThanixClient, query: CircuitsProviderAccountsListQuery) -> Result<CircuitsProviderAccountsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/provider-accounts/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderAccountsListResponse::Http200(r#response.json::<PaginatedProviderAccountList>()?)) },
		_ => { Ok(CircuitsProviderAccountsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsBulkUpdateResponse {
	Http200(Vec<ProviderAccount>),
	#[default]
	None
}
/// Put a list of provider account objects.
pub fn circuits_provider_accounts_bulk_update(state: &ThanixClient, body: Vec<ProviderAccountRequest>) -> Result<CircuitsProviderAccountsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/provider-accounts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderAccountsBulkUpdateResponse::Http200(r#response.json::<Vec<ProviderAccount>>()?)) },
		_ => { Ok(CircuitsProviderAccountsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsCreateResponse {
	Http201(ProviderAccount),
	#[default]
	None
}
/// Post a list of provider account objects.
pub fn circuits_provider_accounts_create(state: &ThanixClient, body: WritableProviderAccountRequest) -> Result<CircuitsProviderAccountsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/circuits/provider-accounts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CircuitsProviderAccountsCreateResponse::Http201(r#response.json::<ProviderAccount>()?)) },
		_ => { Ok(CircuitsProviderAccountsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of provider account objects.
pub fn circuits_provider_accounts_bulk_destroy(state: &ThanixClient, body: Vec<ProviderAccountRequest>) -> Result<CircuitsProviderAccountsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/provider-accounts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsProviderAccountsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsBulkPartialUpdateResponse {
	Http200(Vec<ProviderAccount>),
	#[default]
	None
}
/// Patch a list of provider account objects.
pub fn circuits_provider_accounts_bulk_partial_update(state: &ThanixClient, body: Vec<ProviderAccountRequest>) -> Result<CircuitsProviderAccountsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/provider-accounts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderAccountsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ProviderAccount>>()?)) },
		_ => { Ok(CircuitsProviderAccountsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsRetrieveResponse {
	Http200(ProviderAccount),
	#[default]
	None
}
/// Get a provider account object.
pub fn circuits_provider_accounts_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsProviderAccountsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/provider-accounts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderAccountsRetrieveResponse::Http200(r#response.json::<ProviderAccount>()?)) },
		_ => { Ok(CircuitsProviderAccountsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsUpdateResponse {
	Http200(ProviderAccount),
	#[default]
	None
}
/// Put a provider account object.
pub fn circuits_provider_accounts_update(state: &ThanixClient, body: WritableProviderAccountRequest, id: i64) -> Result<CircuitsProviderAccountsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/provider-accounts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderAccountsUpdateResponse::Http200(r#response.json::<ProviderAccount>()?)) },
		_ => { Ok(CircuitsProviderAccountsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a provider account object.
pub fn circuits_provider_accounts_destroy(state: &ThanixClient, id: i64) -> Result<CircuitsProviderAccountsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/provider-accounts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsProviderAccountsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderAccountsPartialUpdateResponse {
	Http200(ProviderAccount),
	#[default]
	None
}
/// Patch a provider account object.
pub fn circuits_provider_accounts_partial_update(state: &ThanixClient, body: PatchedWritableProviderAccountRequest, id: i64) -> Result<CircuitsProviderAccountsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/provider-accounts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderAccountsPartialUpdateResponse::Http200(r#response.json::<ProviderAccount>()?)) },
		_ => { Ok(CircuitsProviderAccountsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CircuitsProviderNetworksListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Provider (slug)
	provider: Option<Vec<String>>,
	/// Provider (slug)
	provider__n: Option<Vec<String>>,
	/// Provider (ID)
	provider_id: Option<Vec<i64>>,
	/// Provider (ID)
	provider_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	service_id: Option<Vec<String>>,
	service_id__empty: Option<bool>,
	service_id__ic: Option<Vec<String>>,
	service_id__ie: Option<Vec<String>>,
	service_id__iew: Option<Vec<String>>,
	service_id__isw: Option<Vec<String>>,
	service_id__n: Option<Vec<String>>,
	service_id__nic: Option<Vec<String>>,
	service_id__nie: Option<Vec<String>>,
	service_id__niew: Option<Vec<String>>,
	service_id__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksListResponse {
	Http200(PaginatedProviderNetworkList),
	#[default]
	None
}
/// Get a list of provider network objects.
pub fn circuits_provider_networks_list(state: &ThanixClient, query: CircuitsProviderNetworksListQuery) -> Result<CircuitsProviderNetworksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/provider-networks/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderNetworksListResponse::Http200(r#response.json::<PaginatedProviderNetworkList>()?)) },
		_ => { Ok(CircuitsProviderNetworksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksBulkUpdateResponse {
	Http200(Vec<ProviderNetwork>),
	#[default]
	None
}
/// Put a list of provider network objects.
pub fn circuits_provider_networks_bulk_update(state: &ThanixClient, body: Vec<ProviderNetworkRequest>) -> Result<CircuitsProviderNetworksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/provider-networks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderNetworksBulkUpdateResponse::Http200(r#response.json::<Vec<ProviderNetwork>>()?)) },
		_ => { Ok(CircuitsProviderNetworksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksCreateResponse {
	Http201(ProviderNetwork),
	#[default]
	None
}
/// Post a list of provider network objects.
pub fn circuits_provider_networks_create(state: &ThanixClient, body: WritableProviderNetworkRequest) -> Result<CircuitsProviderNetworksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/circuits/provider-networks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CircuitsProviderNetworksCreateResponse::Http201(r#response.json::<ProviderNetwork>()?)) },
		_ => { Ok(CircuitsProviderNetworksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of provider network objects.
pub fn circuits_provider_networks_bulk_destroy(state: &ThanixClient, body: Vec<ProviderNetworkRequest>) -> Result<CircuitsProviderNetworksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/provider-networks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsProviderNetworksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksBulkPartialUpdateResponse {
	Http200(Vec<ProviderNetwork>),
	#[default]
	None
}
/// Patch a list of provider network objects.
pub fn circuits_provider_networks_bulk_partial_update(state: &ThanixClient, body: Vec<ProviderNetworkRequest>) -> Result<CircuitsProviderNetworksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/provider-networks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderNetworksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ProviderNetwork>>()?)) },
		_ => { Ok(CircuitsProviderNetworksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksRetrieveResponse {
	Http200(ProviderNetwork),
	#[default]
	None
}
/// Get a provider network object.
pub fn circuits_provider_networks_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsProviderNetworksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/provider-networks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderNetworksRetrieveResponse::Http200(r#response.json::<ProviderNetwork>()?)) },
		_ => { Ok(CircuitsProviderNetworksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksUpdateResponse {
	Http200(ProviderNetwork),
	#[default]
	None
}
/// Put a provider network object.
pub fn circuits_provider_networks_update(state: &ThanixClient, body: WritableProviderNetworkRequest, id: i64) -> Result<CircuitsProviderNetworksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/provider-networks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderNetworksUpdateResponse::Http200(r#response.json::<ProviderNetwork>()?)) },
		_ => { Ok(CircuitsProviderNetworksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a provider network object.
pub fn circuits_provider_networks_destroy(state: &ThanixClient, id: i64) -> Result<CircuitsProviderNetworksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/provider-networks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsProviderNetworksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProviderNetworksPartialUpdateResponse {
	Http200(ProviderNetwork),
	#[default]
	None
}
/// Patch a provider network object.
pub fn circuits_provider_networks_partial_update(state: &ThanixClient, body: PatchedWritableProviderNetworkRequest, id: i64) -> Result<CircuitsProviderNetworksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/provider-networks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProviderNetworksPartialUpdateResponse::Http200(r#response.json::<ProviderNetwork>()?)) },
		_ => { Ok(CircuitsProviderNetworksPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CircuitsProvidersListQuery {
	/// ASN (ID)
	asn_id: Option<Vec<i64>>,
	/// ASN (ID)
	asn_id__n: Option<Vec<i64>>,
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site
	site_id: Option<Vec<i64>>,
	/// Site
	site_id__n: Option<Vec<i64>>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersListResponse {
	Http200(PaginatedProviderList),
	#[default]
	None
}
/// Get a list of provider objects.
pub fn circuits_providers_list(state: &ThanixClient, query: CircuitsProvidersListQuery) -> Result<CircuitsProvidersListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/providers/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProvidersListResponse::Http200(r#response.json::<PaginatedProviderList>()?)) },
		_ => { Ok(CircuitsProvidersListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersBulkUpdateResponse {
	Http200(Vec<Provider>),
	#[default]
	None
}
/// Put a list of provider objects.
pub fn circuits_providers_bulk_update(state: &ThanixClient, body: Vec<ProviderRequest>) -> Result<CircuitsProvidersBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/providers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProvidersBulkUpdateResponse::Http200(r#response.json::<Vec<Provider>>()?)) },
		_ => { Ok(CircuitsProvidersBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersCreateResponse {
	Http201(Provider),
	#[default]
	None
}
/// Post a list of provider objects.
pub fn circuits_providers_create(state: &ThanixClient, body: WritableProviderRequest) -> Result<CircuitsProvidersCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/circuits/providers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CircuitsProvidersCreateResponse::Http201(r#response.json::<Provider>()?)) },
		_ => { Ok(CircuitsProvidersCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of provider objects.
pub fn circuits_providers_bulk_destroy(state: &ThanixClient, body: Vec<ProviderRequest>) -> Result<CircuitsProvidersBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/providers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsProvidersBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersBulkPartialUpdateResponse {
	Http200(Vec<Provider>),
	#[default]
	None
}
/// Patch a list of provider objects.
pub fn circuits_providers_bulk_partial_update(state: &ThanixClient, body: Vec<ProviderRequest>) -> Result<CircuitsProvidersBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/providers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProvidersBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Provider>>()?)) },
		_ => { Ok(CircuitsProvidersBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersRetrieveResponse {
	Http200(Provider),
	#[default]
	None
}
/// Get a provider object.
pub fn circuits_providers_retrieve(state: &ThanixClient, id: i64) -> Result<CircuitsProvidersRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/circuits/providers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProvidersRetrieveResponse::Http200(r#response.json::<Provider>()?)) },
		_ => { Ok(CircuitsProvidersRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersUpdateResponse {
	Http200(Provider),
	#[default]
	None
}
/// Put a provider object.
pub fn circuits_providers_update(state: &ThanixClient, body: WritableProviderRequest, id: i64) -> Result<CircuitsProvidersUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/circuits/providers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProvidersUpdateResponse::Http200(r#response.json::<Provider>()?)) },
		_ => { Ok(CircuitsProvidersUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a provider object.
pub fn circuits_providers_destroy(state: &ThanixClient, id: i64) -> Result<CircuitsProvidersDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/circuits/providers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CircuitsProvidersDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CircuitsProvidersPartialUpdateResponse {
	Http200(Provider),
	#[default]
	None
}
/// Patch a provider object.
pub fn circuits_providers_partial_update(state: &ThanixClient, body: PatchedWritableProviderRequest, id: i64) -> Result<CircuitsProvidersPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/circuits/providers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CircuitsProvidersPartialUpdateResponse::Http200(r#response.json::<Provider>()?)) },
		_ => { Ok(CircuitsProvidersPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CoreDataFilesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	hash: Option<Vec<String>>,
	hash__empty: Option<bool>,
	hash__ic: Option<Vec<String>>,
	hash__ie: Option<Vec<String>>,
	hash__iew: Option<Vec<String>>,
	hash__isw: Option<Vec<String>>,
	hash__n: Option<Vec<String>>,
	hash__nic: Option<Vec<String>>,
	hash__nie: Option<Vec<String>>,
	hash__niew: Option<Vec<String>>,
	hash__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	path: Option<Vec<String>>,
	path__empty: Option<bool>,
	path__ic: Option<Vec<String>>,
	path__ie: Option<Vec<String>>,
	path__iew: Option<Vec<String>>,
	path__isw: Option<Vec<String>>,
	path__n: Option<Vec<String>>,
	path__nic: Option<Vec<String>>,
	path__nie: Option<Vec<String>>,
	path__niew: Option<Vec<String>>,
	path__nisw: Option<Vec<String>>,
	q: Option<String>,
	size: Option<Vec<i64>>,
	size__empty: Option<bool>,
	size__gt: Option<Vec<i64>>,
	size__gte: Option<Vec<i64>>,
	size__lt: Option<Vec<i64>>,
	size__lte: Option<Vec<i64>>,
	size__n: Option<Vec<i64>>,
	/// Data source (name)
	source: Option<Vec<String>>,
	/// Data source (name)
	source__n: Option<Vec<String>>,
	/// Data source (ID)
	source_id: Option<Vec<i64>>,
	/// Data source (ID)
	source_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataFilesListResponse {
	Http200(PaginatedDataFileList),
	#[default]
	None
}
/// Get a list of data file objects.
pub fn core_data_files_list(state: &ThanixClient, query: CoreDataFilesListQuery) -> Result<CoreDataFilesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/core/data-files/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataFilesListResponse::Http200(r#response.json::<PaginatedDataFileList>()?)) },
		_ => { Ok(CoreDataFilesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataFilesRetrieveResponse {
	Http200(DataFile),
	#[default]
	None
}
/// Get a data file object.
pub fn core_data_files_retrieve(state: &ThanixClient, id: i64) -> Result<CoreDataFilesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/core/data-files/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataFilesRetrieveResponse::Http200(r#response.json::<DataFile>()?)) },
		_ => { Ok(CoreDataFilesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CoreDataSourcesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	enabled: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesListResponse {
	Http200(PaginatedDataSourceList),
	#[default]
	None
}
/// Get a list of data source objects.
pub fn core_data_sources_list(state: &ThanixClient, query: CoreDataSourcesListQuery) -> Result<CoreDataSourcesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/core/data-sources/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesListResponse::Http200(r#response.json::<PaginatedDataSourceList>()?)) },
		_ => { Ok(CoreDataSourcesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesBulkUpdateResponse {
	Http200(Vec<DataSource>),
	#[default]
	None
}
/// Put a list of data source objects.
pub fn core_data_sources_bulk_update(state: &ThanixClient, body: Vec<DataSourceRequest>) -> Result<CoreDataSourcesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/core/data-sources/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesBulkUpdateResponse::Http200(r#response.json::<Vec<DataSource>>()?)) },
		_ => { Ok(CoreDataSourcesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesCreateResponse {
	Http201(DataSource),
	#[default]
	None
}
/// Post a list of data source objects.
pub fn core_data_sources_create(state: &ThanixClient, body: WritableDataSourceRequest) -> Result<CoreDataSourcesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/core/data-sources/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(CoreDataSourcesCreateResponse::Http201(r#response.json::<DataSource>()?)) },
		_ => { Ok(CoreDataSourcesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of data source objects.
pub fn core_data_sources_bulk_destroy(state: &ThanixClient, body: Vec<DataSourceRequest>) -> Result<CoreDataSourcesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/core/data-sources/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CoreDataSourcesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesBulkPartialUpdateResponse {
	Http200(Vec<DataSource>),
	#[default]
	None
}
/// Patch a list of data source objects.
pub fn core_data_sources_bulk_partial_update(state: &ThanixClient, body: Vec<DataSourceRequest>) -> Result<CoreDataSourcesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/core/data-sources/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<DataSource>>()?)) },
		_ => { Ok(CoreDataSourcesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesRetrieveResponse {
	Http200(DataSource),
	#[default]
	None
}
/// Get a data source object.
pub fn core_data_sources_retrieve(state: &ThanixClient, id: i64) -> Result<CoreDataSourcesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/core/data-sources/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesRetrieveResponse::Http200(r#response.json::<DataSource>()?)) },
		_ => { Ok(CoreDataSourcesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesUpdateResponse {
	Http200(DataSource),
	#[default]
	None
}
/// Put a data source object.
pub fn core_data_sources_update(state: &ThanixClient, body: WritableDataSourceRequest, id: i64) -> Result<CoreDataSourcesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/core/data-sources/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesUpdateResponse::Http200(r#response.json::<DataSource>()?)) },
		_ => { Ok(CoreDataSourcesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a data source object.
pub fn core_data_sources_destroy(state: &ThanixClient, id: i64) -> Result<CoreDataSourcesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/core/data-sources/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(CoreDataSourcesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesPartialUpdateResponse {
	Http200(DataSource),
	#[default]
	None
}
/// Patch a data source object.
pub fn core_data_sources_partial_update(state: &ThanixClient, body: PatchedWritableDataSourceRequest, id: i64) -> Result<CoreDataSourcesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/core/data-sources/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesPartialUpdateResponse::Http200(r#response.json::<DataSource>()?)) },
		_ => { Ok(CoreDataSourcesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreDataSourcesSyncCreateResponse {
	Http200(DataSource),
	#[default]
	None
}
/// Enqueue a job to synchronize the DataSource.
pub fn core_data_sources_sync_create(state: &ThanixClient, body: WritableDataSourceRequest, id: i64) -> Result<CoreDataSourcesSyncCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/core/data-sources/{id}/sync/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreDataSourcesSyncCreateResponse::Http200(r#response.json::<DataSource>()?)) },
		_ => { Ok(CoreDataSourcesSyncCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct CoreJobsListQuery {
	completed: Option<String>,
	completed__after: Option<String>,
	completed__before: Option<String>,
	created: Option<String>,
	created__after: Option<String>,
	created__before: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	interval: Option<Vec<i64>>,
	interval__empty: Option<bool>,
	interval__gt: Option<Vec<i64>>,
	interval__gte: Option<Vec<i64>>,
	interval__lt: Option<Vec<i64>>,
	interval__lte: Option<Vec<i64>>,
	interval__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	object_id: Option<Vec<i64>>,
	object_id__empty: Option<bool>,
	object_id__gt: Option<Vec<i64>>,
	object_id__gte: Option<Vec<i64>>,
	object_id__lt: Option<Vec<i64>>,
	object_id__lte: Option<Vec<i64>>,
	object_id__n: Option<Vec<i64>>,
	object_type: Option<i64>,
	object_type__n: Option<i64>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	scheduled: Option<String>,
	scheduled__after: Option<String>,
	scheduled__before: Option<String>,
	started: Option<String>,
	started__after: Option<String>,
	started__before: Option<String>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	user: Option<i64>,
	user__n: Option<i64>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreJobsListResponse {
	Http200(PaginatedJobList),
	#[default]
	None
}
/// Retrieve a list of job results
pub fn core_jobs_list(state: &ThanixClient, query: CoreJobsListQuery) -> Result<CoreJobsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/core/jobs/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreJobsListResponse::Http200(r#response.json::<PaginatedJobList>()?)) },
		_ => { Ok(CoreJobsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum CoreJobsRetrieveResponse {
	Http200(Job),
	#[default]
	None
}
/// Retrieve a list of job results
pub fn core_jobs_retrieve(state: &ThanixClient, id: i64) -> Result<CoreJobsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/core/jobs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(CoreJobsRetrieveResponse::Http200(r#response.json::<Job>()?)) },
		_ => { Ok(CoreJobsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimCableTerminationsListQuery {
	cable: Option<i64>,
	cable__n: Option<i64>,
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	termination_id: Option<Vec<i64>>,
	termination_id__empty: Option<bool>,
	termination_id__gt: Option<Vec<i64>>,
	termination_id__gte: Option<Vec<i64>>,
	termination_id__lt: Option<Vec<i64>>,
	termination_id__lte: Option<Vec<i64>>,
	termination_id__n: Option<Vec<i64>>,
	termination_type: Option<String>,
	termination_type__n: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsListResponse {
	Http200(PaginatedCableTerminationList),
	#[default]
	None
}
/// Get a list of cable termination objects.
pub fn dcim_cable_terminations_list(state: &ThanixClient, query: DcimCableTerminationsListQuery) -> Result<DcimCableTerminationsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/cable-terminations/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCableTerminationsListResponse::Http200(r#response.json::<PaginatedCableTerminationList>()?)) },
		_ => { Ok(DcimCableTerminationsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsBulkUpdateResponse {
	Http200(Vec<CableTermination>),
	#[default]
	None
}
/// Put a list of cable termination objects.
pub fn dcim_cable_terminations_bulk_update(state: &ThanixClient, body: Vec<CableTerminationRequest>) -> Result<DcimCableTerminationsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/cable-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCableTerminationsBulkUpdateResponse::Http200(r#response.json::<Vec<CableTermination>>()?)) },
		_ => { Ok(DcimCableTerminationsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsCreateResponse {
	Http201(CableTermination),
	#[default]
	None
}
/// Post a list of cable termination objects.
pub fn dcim_cable_terminations_create(state: &ThanixClient, body: CableTerminationRequest) -> Result<DcimCableTerminationsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/cable-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimCableTerminationsCreateResponse::Http201(r#response.json::<CableTermination>()?)) },
		_ => { Ok(DcimCableTerminationsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of cable termination objects.
pub fn dcim_cable_terminations_bulk_destroy(state: &ThanixClient, body: Vec<CableTerminationRequest>) -> Result<DcimCableTerminationsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/cable-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimCableTerminationsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsBulkPartialUpdateResponse {
	Http200(Vec<CableTermination>),
	#[default]
	None
}
/// Patch a list of cable termination objects.
pub fn dcim_cable_terminations_bulk_partial_update(state: &ThanixClient, body: Vec<CableTerminationRequest>) -> Result<DcimCableTerminationsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/cable-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCableTerminationsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<CableTermination>>()?)) },
		_ => { Ok(DcimCableTerminationsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsRetrieveResponse {
	Http200(CableTermination),
	#[default]
	None
}
/// Get a cable termination object.
pub fn dcim_cable_terminations_retrieve(state: &ThanixClient, id: i64) -> Result<DcimCableTerminationsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/cable-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCableTerminationsRetrieveResponse::Http200(r#response.json::<CableTermination>()?)) },
		_ => { Ok(DcimCableTerminationsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsUpdateResponse {
	Http200(CableTermination),
	#[default]
	None
}
/// Put a cable termination object.
pub fn dcim_cable_terminations_update(state: &ThanixClient, body: CableTerminationRequest, id: i64) -> Result<DcimCableTerminationsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/cable-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCableTerminationsUpdateResponse::Http200(r#response.json::<CableTermination>()?)) },
		_ => { Ok(DcimCableTerminationsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a cable termination object.
pub fn dcim_cable_terminations_destroy(state: &ThanixClient, id: i64) -> Result<DcimCableTerminationsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/cable-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimCableTerminationsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCableTerminationsPartialUpdateResponse {
	Http200(CableTermination),
	#[default]
	None
}
/// Patch a cable termination object.
pub fn dcim_cable_terminations_partial_update(state: &ThanixClient, body: PatchedCableTerminationRequest, id: i64) -> Result<DcimCableTerminationsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/cable-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCableTerminationsPartialUpdateResponse::Http200(r#response.json::<CableTermination>()?)) },
		_ => { Ok(DcimCableTerminationsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimCablesListQuery {
	circuittermination_id: Option<Vec<i64>>,
	color: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	consoleport_id: Option<Vec<i64>>,
	consoleserverport_id: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	device: Option<Vec<String>>,
	device_id: Option<Vec<i64>>,
	frontport_id: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	interface_id: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	length: Option<Vec<f64>>,
	length__empty: Option<bool>,
	length__gt: Option<Vec<f64>>,
	length__gte: Option<Vec<f64>>,
	length__lt: Option<Vec<f64>>,
	length__lte: Option<Vec<f64>>,
	length__n: Option<Vec<f64>>,
	length_unit: Option<String>,
	length_unit__n: Option<String>,
	/// Number of results to return per page.
	limit: Option<i64>,
	location: Option<Vec<String>>,
	location_id: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	powerfeed_id: Option<Vec<i64>>,
	poweroutlet_id: Option<Vec<i64>>,
	powerport_id: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	rack: Option<Vec<String>>,
	rack_id: Option<Vec<i64>>,
	rearport_id: Option<Vec<i64>>,
	site: Option<Vec<String>>,
	site_id: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	termination_a_id: Option<Vec<i64>>,
	termination_a_type: Option<String>,
	termination_a_type__n: Option<String>,
	termination_b_id: Option<Vec<i64>>,
	termination_b_type: Option<String>,
	termination_b_type__n: Option<String>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	/// Unterminated
	unterminated: Option<bool>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesListResponse {
	Http200(PaginatedCableList),
	#[default]
	None
}
/// Get a list of cable objects.
pub fn dcim_cables_list(state: &ThanixClient, query: DcimCablesListQuery) -> Result<DcimCablesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/cables/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCablesListResponse::Http200(r#response.json::<PaginatedCableList>()?)) },
		_ => { Ok(DcimCablesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesBulkUpdateResponse {
	Http200(Vec<Cable>),
	#[default]
	None
}
/// Put a list of cable objects.
pub fn dcim_cables_bulk_update(state: &ThanixClient, body: Vec<CableRequest>) -> Result<DcimCablesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/cables/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCablesBulkUpdateResponse::Http200(r#response.json::<Vec<Cable>>()?)) },
		_ => { Ok(DcimCablesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesCreateResponse {
	Http201(Cable),
	#[default]
	None
}
/// Post a list of cable objects.
pub fn dcim_cables_create(state: &ThanixClient, body: WritableCableRequest) -> Result<DcimCablesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/cables/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimCablesCreateResponse::Http201(r#response.json::<Cable>()?)) },
		_ => { Ok(DcimCablesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of cable objects.
pub fn dcim_cables_bulk_destroy(state: &ThanixClient, body: Vec<CableRequest>) -> Result<DcimCablesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/cables/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimCablesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesBulkPartialUpdateResponse {
	Http200(Vec<Cable>),
	#[default]
	None
}
/// Patch a list of cable objects.
pub fn dcim_cables_bulk_partial_update(state: &ThanixClient, body: Vec<CableRequest>) -> Result<DcimCablesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/cables/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCablesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Cable>>()?)) },
		_ => { Ok(DcimCablesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesRetrieveResponse {
	Http200(Cable),
	#[default]
	None
}
/// Get a cable object.
pub fn dcim_cables_retrieve(state: &ThanixClient, id: i64) -> Result<DcimCablesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/cables/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCablesRetrieveResponse::Http200(r#response.json::<Cable>()?)) },
		_ => { Ok(DcimCablesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesUpdateResponse {
	Http200(Cable),
	#[default]
	None
}
/// Put a cable object.
pub fn dcim_cables_update(state: &ThanixClient, body: WritableCableRequest, id: i64) -> Result<DcimCablesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/cables/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCablesUpdateResponse::Http200(r#response.json::<Cable>()?)) },
		_ => { Ok(DcimCablesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a cable object.
pub fn dcim_cables_destroy(state: &ThanixClient, id: i64) -> Result<DcimCablesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/cables/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimCablesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimCablesPartialUpdateResponse {
	Http200(Cable),
	#[default]
	None
}
/// Patch a cable object.
pub fn dcim_cables_partial_update(state: &ThanixClient, body: PatchedWritableCableRequest, id: i64) -> Result<DcimCablesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/cables/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimCablesPartialUpdateResponse::Http200(r#response.json::<Cable>()?)) },
		_ => { Ok(DcimCablesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimConnectedDeviceListQuery {
	/// The name of the peer device
	peer_device: Option<String>,
	/// The name of the peer interface
	peer_interface: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConnectedDeviceListResponse {
	Http200(Vec<Device>),
	#[default]
	None
}
/// This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer
/// interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors
/// via a protocol such as LLDP. Two query parameters must be included in the request:
/// 
/// * `peer_device`: The name of the peer device
/// * `peer_interface`: The name of the peer interface
pub fn dcim_connected_device_list(state: &ThanixClient, query: DcimConnectedDeviceListQuery) -> Result<DcimConnectedDeviceListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/connected-device/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConnectedDeviceListResponse::Http200(r#response.json::<Vec<Device>>()?)) },
		_ => { Ok(DcimConnectedDeviceListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimConsolePortTemplatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	r#type: Option<String>,
	type__n: Option<String>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesListResponse {
	Http200(PaginatedConsolePortTemplateList),
	#[default]
	None
}
/// Get a list of console port template objects.
pub fn dcim_console_port_templates_list(state: &ThanixClient, query: DcimConsolePortTemplatesListQuery) -> Result<DcimConsolePortTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-port-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortTemplatesListResponse::Http200(r#response.json::<PaginatedConsolePortTemplateList>()?)) },
		_ => { Ok(DcimConsolePortTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesBulkUpdateResponse {
	Http200(Vec<ConsolePortTemplate>),
	#[default]
	None
}
/// Put a list of console port template objects.
pub fn dcim_console_port_templates_bulk_update(state: &ThanixClient, body: Vec<ConsolePortTemplateRequest>) -> Result<DcimConsolePortTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<ConsolePortTemplate>>()?)) },
		_ => { Ok(DcimConsolePortTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesCreateResponse {
	Http201(ConsolePortTemplate),
	#[default]
	None
}
/// Post a list of console port template objects.
pub fn dcim_console_port_templates_create(state: &ThanixClient, body: WritableConsolePortTemplateRequest) -> Result<DcimConsolePortTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/console-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimConsolePortTemplatesCreateResponse::Http201(r#response.json::<ConsolePortTemplate>()?)) },
		_ => { Ok(DcimConsolePortTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of console port template objects.
pub fn dcim_console_port_templates_bulk_destroy(state: &ThanixClient, body: Vec<ConsolePortTemplateRequest>) -> Result<DcimConsolePortTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsolePortTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesBulkPartialUpdateResponse {
	Http200(Vec<ConsolePortTemplate>),
	#[default]
	None
}
/// Patch a list of console port template objects.
pub fn dcim_console_port_templates_bulk_partial_update(state: &ThanixClient, body: Vec<ConsolePortTemplateRequest>) -> Result<DcimConsolePortTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ConsolePortTemplate>>()?)) },
		_ => { Ok(DcimConsolePortTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesRetrieveResponse {
	Http200(ConsolePortTemplate),
	#[default]
	None
}
/// Get a console port template object.
pub fn dcim_console_port_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimConsolePortTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortTemplatesRetrieveResponse::Http200(r#response.json::<ConsolePortTemplate>()?)) },
		_ => { Ok(DcimConsolePortTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesUpdateResponse {
	Http200(ConsolePortTemplate),
	#[default]
	None
}
/// Put a console port template object.
pub fn dcim_console_port_templates_update(state: &ThanixClient, body: WritableConsolePortTemplateRequest, id: i64) -> Result<DcimConsolePortTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortTemplatesUpdateResponse::Http200(r#response.json::<ConsolePortTemplate>()?)) },
		_ => { Ok(DcimConsolePortTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a console port template object.
pub fn dcim_console_port_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimConsolePortTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsolePortTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortTemplatesPartialUpdateResponse {
	Http200(ConsolePortTemplate),
	#[default]
	None
}
/// Patch a console port template object.
pub fn dcim_console_port_templates_partial_update(state: &ThanixClient, body: PatchedWritableConsolePortTemplateRequest, id: i64) -> Result<DcimConsolePortTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortTemplatesPartialUpdateResponse::Http200(r#response.json::<ConsolePortTemplate>()?)) },
		_ => { Ok(DcimConsolePortTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimConsolePortsListQuery {
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	connected: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Physical port type
	r#type: Option<Vec<String>>,
	/// Physical port type
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsListResponse {
	Http200(PaginatedConsolePortList),
	#[default]
	None
}
/// Get a list of console port objects.
pub fn dcim_console_ports_list(state: &ThanixClient, query: DcimConsolePortsListQuery) -> Result<DcimConsolePortsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-ports/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsListResponse::Http200(r#response.json::<PaginatedConsolePortList>()?)) },
		_ => { Ok(DcimConsolePortsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsBulkUpdateResponse {
	Http200(Vec<ConsolePort>),
	#[default]
	None
}
/// Put a list of console port objects.
pub fn dcim_console_ports_bulk_update(state: &ThanixClient, body: Vec<ConsolePortRequest>) -> Result<DcimConsolePortsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsBulkUpdateResponse::Http200(r#response.json::<Vec<ConsolePort>>()?)) },
		_ => { Ok(DcimConsolePortsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsCreateResponse {
	Http201(ConsolePort),
	#[default]
	None
}
/// Post a list of console port objects.
pub fn dcim_console_ports_create(state: &ThanixClient, body: WritableConsolePortRequest) -> Result<DcimConsolePortsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/console-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimConsolePortsCreateResponse::Http201(r#response.json::<ConsolePort>()?)) },
		_ => { Ok(DcimConsolePortsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of console port objects.
pub fn dcim_console_ports_bulk_destroy(state: &ThanixClient, body: Vec<ConsolePortRequest>) -> Result<DcimConsolePortsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsolePortsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsBulkPartialUpdateResponse {
	Http200(Vec<ConsolePort>),
	#[default]
	None
}
/// Patch a list of console port objects.
pub fn dcim_console_ports_bulk_partial_update(state: &ThanixClient, body: Vec<ConsolePortRequest>) -> Result<DcimConsolePortsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ConsolePort>>()?)) },
		_ => { Ok(DcimConsolePortsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsRetrieveResponse {
	Http200(ConsolePort),
	#[default]
	None
}
/// Get a console port object.
pub fn dcim_console_ports_retrieve(state: &ThanixClient, id: i64) -> Result<DcimConsolePortsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsRetrieveResponse::Http200(r#response.json::<ConsolePort>()?)) },
		_ => { Ok(DcimConsolePortsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsUpdateResponse {
	Http200(ConsolePort),
	#[default]
	None
}
/// Put a console port object.
pub fn dcim_console_ports_update(state: &ThanixClient, body: WritableConsolePortRequest, id: i64) -> Result<DcimConsolePortsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsUpdateResponse::Http200(r#response.json::<ConsolePort>()?)) },
		_ => { Ok(DcimConsolePortsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a console port object.
pub fn dcim_console_ports_destroy(state: &ThanixClient, id: i64) -> Result<DcimConsolePortsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsolePortsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsPartialUpdateResponse {
	Http200(ConsolePort),
	#[default]
	None
}
/// Patch a console port object.
pub fn dcim_console_ports_partial_update(state: &ThanixClient, body: PatchedWritableConsolePortRequest, id: i64) -> Result<DcimConsolePortsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsPartialUpdateResponse::Http200(r#response.json::<ConsolePort>()?)) },
		_ => { Ok(DcimConsolePortsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsolePortsTraceRetrieveResponse {
	Http200(ConsolePort),
	#[default]
	None
}
/// Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
pub fn dcim_console_ports_trace_retrieve(state: &ThanixClient, id: i64) -> Result<DcimConsolePortsTraceRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-ports/{id}/trace/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsolePortsTraceRetrieveResponse::Http200(r#response.json::<ConsolePort>()?)) },
		_ => { Ok(DcimConsolePortsTraceRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimConsoleServerPortTemplatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	r#type: Option<String>,
	type__n: Option<String>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesListResponse {
	Http200(PaginatedConsoleServerPortTemplateList),
	#[default]
	None
}
/// Get a list of console server port template objects.
pub fn dcim_console_server_port_templates_list(state: &ThanixClient, query: DcimConsoleServerPortTemplatesListQuery) -> Result<DcimConsoleServerPortTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-server-port-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortTemplatesListResponse::Http200(r#response.json::<PaginatedConsoleServerPortTemplateList>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesBulkUpdateResponse {
	Http200(Vec<ConsoleServerPortTemplate>),
	#[default]
	None
}
/// Put a list of console server port template objects.
pub fn dcim_console_server_port_templates_bulk_update(state: &ThanixClient, body: Vec<ConsoleServerPortTemplateRequest>) -> Result<DcimConsoleServerPortTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-server-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<ConsoleServerPortTemplate>>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesCreateResponse {
	Http201(ConsoleServerPortTemplate),
	#[default]
	None
}
/// Post a list of console server port template objects.
pub fn dcim_console_server_port_templates_create(state: &ThanixClient, body: WritableConsoleServerPortTemplateRequest) -> Result<DcimConsoleServerPortTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/console-server-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimConsoleServerPortTemplatesCreateResponse::Http201(r#response.json::<ConsoleServerPortTemplate>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of console server port template objects.
pub fn dcim_console_server_port_templates_bulk_destroy(state: &ThanixClient, body: Vec<ConsoleServerPortTemplateRequest>) -> Result<DcimConsoleServerPortTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-server-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsoleServerPortTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesBulkPartialUpdateResponse {
	Http200(Vec<ConsoleServerPortTemplate>),
	#[default]
	None
}
/// Patch a list of console server port template objects.
pub fn dcim_console_server_port_templates_bulk_partial_update(state: &ThanixClient, body: Vec<ConsoleServerPortTemplateRequest>) -> Result<DcimConsoleServerPortTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-server-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ConsoleServerPortTemplate>>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesRetrieveResponse {
	Http200(ConsoleServerPortTemplate),
	#[default]
	None
}
/// Get a console server port template object.
pub fn dcim_console_server_port_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimConsoleServerPortTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-server-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortTemplatesRetrieveResponse::Http200(r#response.json::<ConsoleServerPortTemplate>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesUpdateResponse {
	Http200(ConsoleServerPortTemplate),
	#[default]
	None
}
/// Put a console server port template object.
pub fn dcim_console_server_port_templates_update(state: &ThanixClient, body: WritableConsoleServerPortTemplateRequest, id: i64) -> Result<DcimConsoleServerPortTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-server-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortTemplatesUpdateResponse::Http200(r#response.json::<ConsoleServerPortTemplate>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a console server port template object.
pub fn dcim_console_server_port_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimConsoleServerPortTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-server-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsoleServerPortTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortTemplatesPartialUpdateResponse {
	Http200(ConsoleServerPortTemplate),
	#[default]
	None
}
/// Patch a console server port template object.
pub fn dcim_console_server_port_templates_partial_update(state: &ThanixClient, body: PatchedWritableConsoleServerPortTemplateRequest, id: i64) -> Result<DcimConsoleServerPortTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-server-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortTemplatesPartialUpdateResponse::Http200(r#response.json::<ConsoleServerPortTemplate>()?)) },
		_ => { Ok(DcimConsoleServerPortTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimConsoleServerPortsListQuery {
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	connected: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Physical port type
	r#type: Option<Vec<String>>,
	/// Physical port type
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsListResponse {
	Http200(PaginatedConsoleServerPortList),
	#[default]
	None
}
/// Get a list of console server port objects.
pub fn dcim_console_server_ports_list(state: &ThanixClient, query: DcimConsoleServerPortsListQuery) -> Result<DcimConsoleServerPortsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-server-ports/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsListResponse::Http200(r#response.json::<PaginatedConsoleServerPortList>()?)) },
		_ => { Ok(DcimConsoleServerPortsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsBulkUpdateResponse {
	Http200(Vec<ConsoleServerPort>),
	#[default]
	None
}
/// Put a list of console server port objects.
pub fn dcim_console_server_ports_bulk_update(state: &ThanixClient, body: Vec<ConsoleServerPortRequest>) -> Result<DcimConsoleServerPortsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-server-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsBulkUpdateResponse::Http200(r#response.json::<Vec<ConsoleServerPort>>()?)) },
		_ => { Ok(DcimConsoleServerPortsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsCreateResponse {
	Http201(ConsoleServerPort),
	#[default]
	None
}
/// Post a list of console server port objects.
pub fn dcim_console_server_ports_create(state: &ThanixClient, body: WritableConsoleServerPortRequest) -> Result<DcimConsoleServerPortsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/console-server-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimConsoleServerPortsCreateResponse::Http201(r#response.json::<ConsoleServerPort>()?)) },
		_ => { Ok(DcimConsoleServerPortsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of console server port objects.
pub fn dcim_console_server_ports_bulk_destroy(state: &ThanixClient, body: Vec<ConsoleServerPortRequest>) -> Result<DcimConsoleServerPortsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-server-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsoleServerPortsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsBulkPartialUpdateResponse {
	Http200(Vec<ConsoleServerPort>),
	#[default]
	None
}
/// Patch a list of console server port objects.
pub fn dcim_console_server_ports_bulk_partial_update(state: &ThanixClient, body: Vec<ConsoleServerPortRequest>) -> Result<DcimConsoleServerPortsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-server-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ConsoleServerPort>>()?)) },
		_ => { Ok(DcimConsoleServerPortsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsRetrieveResponse {
	Http200(ConsoleServerPort),
	#[default]
	None
}
/// Get a console server port object.
pub fn dcim_console_server_ports_retrieve(state: &ThanixClient, id: i64) -> Result<DcimConsoleServerPortsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-server-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsRetrieveResponse::Http200(r#response.json::<ConsoleServerPort>()?)) },
		_ => { Ok(DcimConsoleServerPortsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsUpdateResponse {
	Http200(ConsoleServerPort),
	#[default]
	None
}
/// Put a console server port object.
pub fn dcim_console_server_ports_update(state: &ThanixClient, body: WritableConsoleServerPortRequest, id: i64) -> Result<DcimConsoleServerPortsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/console-server-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsUpdateResponse::Http200(r#response.json::<ConsoleServerPort>()?)) },
		_ => { Ok(DcimConsoleServerPortsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a console server port object.
pub fn dcim_console_server_ports_destroy(state: &ThanixClient, id: i64) -> Result<DcimConsoleServerPortsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/console-server-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimConsoleServerPortsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsPartialUpdateResponse {
	Http200(ConsoleServerPort),
	#[default]
	None
}
/// Patch a console server port object.
pub fn dcim_console_server_ports_partial_update(state: &ThanixClient, body: PatchedWritableConsoleServerPortRequest, id: i64) -> Result<DcimConsoleServerPortsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/console-server-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsPartialUpdateResponse::Http200(r#response.json::<ConsoleServerPort>()?)) },
		_ => { Ok(DcimConsoleServerPortsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimConsoleServerPortsTraceRetrieveResponse {
	Http200(ConsoleServerPort),
	#[default]
	None
}
/// Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
pub fn dcim_console_server_ports_trace_retrieve(state: &ThanixClient, id: i64) -> Result<DcimConsoleServerPortsTraceRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/console-server-ports/{id}/trace/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimConsoleServerPortsTraceRetrieveResponse::Http200(r#response.json::<ConsoleServerPort>()?)) },
		_ => { Ok(DcimConsoleServerPortsTraceRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimDeviceBayTemplatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesListResponse {
	Http200(PaginatedDeviceBayTemplateList),
	#[default]
	None
}
/// Get a list of device bay template objects.
pub fn dcim_device_bay_templates_list(state: &ThanixClient, query: DcimDeviceBayTemplatesListQuery) -> Result<DcimDeviceBayTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-bay-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBayTemplatesListResponse::Http200(r#response.json::<PaginatedDeviceBayTemplateList>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesBulkUpdateResponse {
	Http200(Vec<DeviceBayTemplate>),
	#[default]
	None
}
/// Put a list of device bay template objects.
pub fn dcim_device_bay_templates_bulk_update(state: &ThanixClient, body: Vec<DeviceBayTemplateRequest>) -> Result<DcimDeviceBayTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBayTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<DeviceBayTemplate>>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesCreateResponse {
	Http201(DeviceBayTemplate),
	#[default]
	None
}
/// Post a list of device bay template objects.
pub fn dcim_device_bay_templates_create(state: &ThanixClient, body: WritableDeviceBayTemplateRequest) -> Result<DcimDeviceBayTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/device-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimDeviceBayTemplatesCreateResponse::Http201(r#response.json::<DeviceBayTemplate>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of device bay template objects.
pub fn dcim_device_bay_templates_bulk_destroy(state: &ThanixClient, body: Vec<DeviceBayTemplateRequest>) -> Result<DcimDeviceBayTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceBayTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesBulkPartialUpdateResponse {
	Http200(Vec<DeviceBayTemplate>),
	#[default]
	None
}
/// Patch a list of device bay template objects.
pub fn dcim_device_bay_templates_bulk_partial_update(state: &ThanixClient, body: Vec<DeviceBayTemplateRequest>) -> Result<DcimDeviceBayTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBayTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<DeviceBayTemplate>>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesRetrieveResponse {
	Http200(DeviceBayTemplate),
	#[default]
	None
}
/// Get a device bay template object.
pub fn dcim_device_bay_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimDeviceBayTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBayTemplatesRetrieveResponse::Http200(r#response.json::<DeviceBayTemplate>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesUpdateResponse {
	Http200(DeviceBayTemplate),
	#[default]
	None
}
/// Put a device bay template object.
pub fn dcim_device_bay_templates_update(state: &ThanixClient, body: WritableDeviceBayTemplateRequest, id: i64) -> Result<DcimDeviceBayTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBayTemplatesUpdateResponse::Http200(r#response.json::<DeviceBayTemplate>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a device bay template object.
pub fn dcim_device_bay_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimDeviceBayTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceBayTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBayTemplatesPartialUpdateResponse {
	Http200(DeviceBayTemplate),
	#[default]
	None
}
/// Patch a device bay template object.
pub fn dcim_device_bay_templates_partial_update(state: &ThanixClient, body: PatchedWritableDeviceBayTemplateRequest, id: i64) -> Result<DcimDeviceBayTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBayTemplatesPartialUpdateResponse::Http200(r#response.json::<DeviceBayTemplate>()?)) },
		_ => { Ok(DcimDeviceBayTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimDeviceBaysListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysListResponse {
	Http200(PaginatedDeviceBayList),
	#[default]
	None
}
/// Get a list of device bay objects.
pub fn dcim_device_bays_list(state: &ThanixClient, query: DcimDeviceBaysListQuery) -> Result<DcimDeviceBaysListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-bays/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBaysListResponse::Http200(r#response.json::<PaginatedDeviceBayList>()?)) },
		_ => { Ok(DcimDeviceBaysListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysBulkUpdateResponse {
	Http200(Vec<DeviceBay>),
	#[default]
	None
}
/// Put a list of device bay objects.
pub fn dcim_device_bays_bulk_update(state: &ThanixClient, body: Vec<DeviceBayRequest>) -> Result<DcimDeviceBaysBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBaysBulkUpdateResponse::Http200(r#response.json::<Vec<DeviceBay>>()?)) },
		_ => { Ok(DcimDeviceBaysBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysCreateResponse {
	Http201(DeviceBay),
	#[default]
	None
}
/// Post a list of device bay objects.
pub fn dcim_device_bays_create(state: &ThanixClient, body: WritableDeviceBayRequest) -> Result<DcimDeviceBaysCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/device-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimDeviceBaysCreateResponse::Http201(r#response.json::<DeviceBay>()?)) },
		_ => { Ok(DcimDeviceBaysCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of device bay objects.
pub fn dcim_device_bays_bulk_destroy(state: &ThanixClient, body: Vec<DeviceBayRequest>) -> Result<DcimDeviceBaysBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceBaysBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysBulkPartialUpdateResponse {
	Http200(Vec<DeviceBay>),
	#[default]
	None
}
/// Patch a list of device bay objects.
pub fn dcim_device_bays_bulk_partial_update(state: &ThanixClient, body: Vec<DeviceBayRequest>) -> Result<DcimDeviceBaysBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBaysBulkPartialUpdateResponse::Http200(r#response.json::<Vec<DeviceBay>>()?)) },
		_ => { Ok(DcimDeviceBaysBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysRetrieveResponse {
	Http200(DeviceBay),
	#[default]
	None
}
/// Get a device bay object.
pub fn dcim_device_bays_retrieve(state: &ThanixClient, id: i64) -> Result<DcimDeviceBaysRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBaysRetrieveResponse::Http200(r#response.json::<DeviceBay>()?)) },
		_ => { Ok(DcimDeviceBaysRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysUpdateResponse {
	Http200(DeviceBay),
	#[default]
	None
}
/// Put a device bay object.
pub fn dcim_device_bays_update(state: &ThanixClient, body: WritableDeviceBayRequest, id: i64) -> Result<DcimDeviceBaysUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBaysUpdateResponse::Http200(r#response.json::<DeviceBay>()?)) },
		_ => { Ok(DcimDeviceBaysUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a device bay object.
pub fn dcim_device_bays_destroy(state: &ThanixClient, id: i64) -> Result<DcimDeviceBaysDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceBaysDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceBaysPartialUpdateResponse {
	Http200(DeviceBay),
	#[default]
	None
}
/// Patch a device bay object.
pub fn dcim_device_bays_partial_update(state: &ThanixClient, body: PatchedWritableDeviceBayRequest, id: i64) -> Result<DcimDeviceBaysPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceBaysPartialUpdateResponse::Http200(r#response.json::<DeviceBay>()?)) },
		_ => { Ok(DcimDeviceBaysPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimDeviceRolesListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	/// Config template (ID)
	config_template_id: Option<Vec<i64>>,
	/// Config template (ID)
	config_template_id__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	vm_role: Option<bool>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesListResponse {
	Http200(PaginatedDeviceRoleList),
	#[default]
	None
}
/// Get a list of device role objects.
pub fn dcim_device_roles_list(state: &ThanixClient, query: DcimDeviceRolesListQuery) -> Result<DcimDeviceRolesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-roles/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceRolesListResponse::Http200(r#response.json::<PaginatedDeviceRoleList>()?)) },
		_ => { Ok(DcimDeviceRolesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesBulkUpdateResponse {
	Http200(Vec<DeviceRole>),
	#[default]
	None
}
/// Put a list of device role objects.
pub fn dcim_device_roles_bulk_update(state: &ThanixClient, body: Vec<DeviceRoleRequest>) -> Result<DcimDeviceRolesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceRolesBulkUpdateResponse::Http200(r#response.json::<Vec<DeviceRole>>()?)) },
		_ => { Ok(DcimDeviceRolesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesCreateResponse {
	Http201(DeviceRole),
	#[default]
	None
}
/// Post a list of device role objects.
pub fn dcim_device_roles_create(state: &ThanixClient, body: WritableDeviceRoleRequest) -> Result<DcimDeviceRolesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/device-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimDeviceRolesCreateResponse::Http201(r#response.json::<DeviceRole>()?)) },
		_ => { Ok(DcimDeviceRolesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of device role objects.
pub fn dcim_device_roles_bulk_destroy(state: &ThanixClient, body: Vec<DeviceRoleRequest>) -> Result<DcimDeviceRolesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceRolesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesBulkPartialUpdateResponse {
	Http200(Vec<DeviceRole>),
	#[default]
	None
}
/// Patch a list of device role objects.
pub fn dcim_device_roles_bulk_partial_update(state: &ThanixClient, body: Vec<DeviceRoleRequest>) -> Result<DcimDeviceRolesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceRolesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<DeviceRole>>()?)) },
		_ => { Ok(DcimDeviceRolesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesRetrieveResponse {
	Http200(DeviceRole),
	#[default]
	None
}
/// Get a device role object.
pub fn dcim_device_roles_retrieve(state: &ThanixClient, id: i64) -> Result<DcimDeviceRolesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceRolesRetrieveResponse::Http200(r#response.json::<DeviceRole>()?)) },
		_ => { Ok(DcimDeviceRolesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesUpdateResponse {
	Http200(DeviceRole),
	#[default]
	None
}
/// Put a device role object.
pub fn dcim_device_roles_update(state: &ThanixClient, body: WritableDeviceRoleRequest, id: i64) -> Result<DcimDeviceRolesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceRolesUpdateResponse::Http200(r#response.json::<DeviceRole>()?)) },
		_ => { Ok(DcimDeviceRolesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a device role object.
pub fn dcim_device_roles_destroy(state: &ThanixClient, id: i64) -> Result<DcimDeviceRolesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceRolesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceRolesPartialUpdateResponse {
	Http200(DeviceRole),
	#[default]
	None
}
/// Patch a device role object.
pub fn dcim_device_roles_partial_update(state: &ThanixClient, body: PatchedWritableDeviceRoleRequest, id: i64) -> Result<DcimDeviceRolesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceRolesPartialUpdateResponse::Http200(r#response.json::<DeviceRole>()?)) },
		_ => { Ok(DcimDeviceRolesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimDeviceTypesListQuery {
	airflow: Option<String>,
	airflow__n: Option<String>,
	/// Has console ports
	console_ports: Option<bool>,
	/// Has console server ports
	console_server_ports: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	/// Default platform (slug)
	default_platform: Option<Vec<String>>,
	/// Default platform (slug)
	default_platform__n: Option<Vec<String>>,
	/// Default platform (ID)
	default_platform_id: Option<Vec<i64>>,
	/// Default platform (ID)
	default_platform_id__n: Option<Vec<i64>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Has device bays
	device_bays: Option<bool>,
	exclude_from_utilization: Option<bool>,
	/// Has a front image
	has_front_image: Option<bool>,
	/// Has a rear image
	has_rear_image: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Has interfaces
	interfaces: Option<bool>,
	/// Has inventory items
	inventory_items: Option<bool>,
	is_full_depth: Option<bool>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	model: Option<Vec<String>>,
	model__empty: Option<bool>,
	model__ic: Option<Vec<String>>,
	model__ie: Option<Vec<String>>,
	model__iew: Option<Vec<String>>,
	model__isw: Option<Vec<String>>,
	model__n: Option<Vec<String>>,
	model__nic: Option<Vec<String>>,
	model__nie: Option<Vec<String>>,
	model__niew: Option<Vec<String>>,
	model__nisw: Option<Vec<String>>,
	modified_by_request: Option<String>,
	/// Has module bays
	module_bays: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	part_number: Option<Vec<String>>,
	part_number__empty: Option<bool>,
	part_number__ic: Option<Vec<String>>,
	part_number__ie: Option<Vec<String>>,
	part_number__iew: Option<Vec<String>>,
	part_number__isw: Option<Vec<String>>,
	part_number__n: Option<Vec<String>>,
	part_number__nic: Option<Vec<String>>,
	part_number__nie: Option<Vec<String>>,
	part_number__niew: Option<Vec<String>>,
	part_number__nisw: Option<Vec<String>>,
	/// Has pass-through ports
	pass_through_ports: Option<bool>,
	/// Has power outlets
	power_outlets: Option<bool>,
	/// Has power ports
	power_ports: Option<bool>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	/// Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
	subdevice_role: Option<String>,
	/// Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
	subdevice_role__n: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	u_height: Option<Vec<f64>>,
	u_height__empty: Option<bool>,
	u_height__gt: Option<Vec<f64>>,
	u_height__gte: Option<Vec<f64>>,
	u_height__lt: Option<Vec<f64>>,
	u_height__lte: Option<Vec<f64>>,
	u_height__n: Option<Vec<f64>>,
	updated_by_request: Option<String>,
	weight: Option<Vec<f64>>,
	weight__empty: Option<bool>,
	weight__gt: Option<Vec<f64>>,
	weight__gte: Option<Vec<f64>>,
	weight__lt: Option<Vec<f64>>,
	weight__lte: Option<Vec<f64>>,
	weight__n: Option<Vec<f64>>,
	weight_unit: Option<String>,
	weight_unit__n: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesListResponse {
	Http200(PaginatedDeviceTypeList),
	#[default]
	None
}
/// Get a list of device type objects.
pub fn dcim_device_types_list(state: &ThanixClient, query: DcimDeviceTypesListQuery) -> Result<DcimDeviceTypesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-types/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceTypesListResponse::Http200(r#response.json::<PaginatedDeviceTypeList>()?)) },
		_ => { Ok(DcimDeviceTypesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesBulkUpdateResponse {
	Http200(Vec<DeviceType>),
	#[default]
	None
}
/// Put a list of device type objects.
pub fn dcim_device_types_bulk_update(state: &ThanixClient, body: Vec<DeviceTypeRequest>) -> Result<DcimDeviceTypesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceTypesBulkUpdateResponse::Http200(r#response.json::<Vec<DeviceType>>()?)) },
		_ => { Ok(DcimDeviceTypesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesCreateResponse {
	Http201(DeviceType),
	#[default]
	None
}
/// Post a list of device type objects.
pub fn dcim_device_types_create(state: &ThanixClient, body: WritableDeviceTypeRequest) -> Result<DcimDeviceTypesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/device-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimDeviceTypesCreateResponse::Http201(r#response.json::<DeviceType>()?)) },
		_ => { Ok(DcimDeviceTypesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of device type objects.
pub fn dcim_device_types_bulk_destroy(state: &ThanixClient, body: Vec<DeviceTypeRequest>) -> Result<DcimDeviceTypesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceTypesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesBulkPartialUpdateResponse {
	Http200(Vec<DeviceType>),
	#[default]
	None
}
/// Patch a list of device type objects.
pub fn dcim_device_types_bulk_partial_update(state: &ThanixClient, body: Vec<DeviceTypeRequest>) -> Result<DcimDeviceTypesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceTypesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<DeviceType>>()?)) },
		_ => { Ok(DcimDeviceTypesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesRetrieveResponse {
	Http200(DeviceType),
	#[default]
	None
}
/// Get a device type object.
pub fn dcim_device_types_retrieve(state: &ThanixClient, id: i64) -> Result<DcimDeviceTypesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/device-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceTypesRetrieveResponse::Http200(r#response.json::<DeviceType>()?)) },
		_ => { Ok(DcimDeviceTypesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesUpdateResponse {
	Http200(DeviceType),
	#[default]
	None
}
/// Put a device type object.
pub fn dcim_device_types_update(state: &ThanixClient, body: WritableDeviceTypeRequest, id: i64) -> Result<DcimDeviceTypesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/device-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceTypesUpdateResponse::Http200(r#response.json::<DeviceType>()?)) },
		_ => { Ok(DcimDeviceTypesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a device type object.
pub fn dcim_device_types_destroy(state: &ThanixClient, id: i64) -> Result<DcimDeviceTypesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/device-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDeviceTypesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDeviceTypesPartialUpdateResponse {
	Http200(DeviceType),
	#[default]
	None
}
/// Patch a device type object.
pub fn dcim_device_types_partial_update(state: &ThanixClient, body: PatchedWritableDeviceTypeRequest, id: i64) -> Result<DcimDeviceTypesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/device-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDeviceTypesPartialUpdateResponse::Http200(r#response.json::<DeviceType>()?)) },
		_ => { Ok(DcimDeviceTypesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimDevicesListQuery {
	airflow: Option<String>,
	airflow__n: Option<String>,
	asset_tag: Option<Vec<String>>,
	asset_tag__empty: Option<bool>,
	asset_tag__ic: Option<Vec<String>>,
	asset_tag__ie: Option<Vec<String>>,
	asset_tag__iew: Option<Vec<String>>,
	asset_tag__isw: Option<Vec<String>>,
	asset_tag__n: Option<Vec<String>>,
	asset_tag__nic: Option<Vec<String>>,
	asset_tag__nie: Option<Vec<String>>,
	asset_tag__niew: Option<Vec<String>>,
	asset_tag__nisw: Option<Vec<String>>,
	/// VM cluster (ID)
	cluster_id: Option<Vec<i64>>,
	/// VM cluster (ID)
	cluster_id__n: Option<Vec<i64>>,
	/// Config template (ID)
	config_template_id: Option<Vec<i64>>,
	/// Config template (ID)
	config_template_id__n: Option<Vec<i64>>,
	/// Has console ports
	console_ports: Option<bool>,
	/// Has console server ports
	console_server_ports: Option<bool>,
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Has device bays
	device_bays: Option<bool>,
	/// Device type (slug)
	device_type: Option<Vec<String>>,
	/// Device type (slug)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	face: Option<String>,
	face__n: Option<String>,
	/// Has an out-of-band IP
	has_oob_ip: Option<bool>,
	/// Has a primary IP
	has_primary_ip: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Has interfaces
	interfaces: Option<bool>,
	/// Is full depth
	is_full_depth: Option<bool>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	latitude: Option<Vec<f64>>,
	latitude__empty: Option<bool>,
	latitude__gt: Option<Vec<f64>>,
	latitude__gte: Option<Vec<f64>>,
	latitude__lt: Option<Vec<f64>>,
	latitude__lte: Option<Vec<f64>>,
	latitude__n: Option<Vec<f64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Has local config context data
	local_context_data: Option<bool>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	longitude: Option<Vec<f64>>,
	longitude__empty: Option<bool>,
	longitude__gt: Option<Vec<f64>>,
	longitude__gte: Option<Vec<f64>>,
	longitude__lt: Option<Vec<f64>>,
	longitude__lte: Option<Vec<f64>>,
	longitude__n: Option<Vec<f64>>,
	mac_address: Option<Vec<String>>,
	mac_address__ic: Option<Vec<String>>,
	mac_address__ie: Option<Vec<String>>,
	mac_address__iew: Option<Vec<String>>,
	mac_address__isw: Option<Vec<String>>,
	mac_address__n: Option<Vec<String>>,
	mac_address__nic: Option<Vec<String>>,
	mac_address__nie: Option<Vec<String>>,
	mac_address__niew: Option<Vec<String>>,
	mac_address__nisw: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	/// Device model (slug)
	model: Option<Vec<String>>,
	/// Device model (slug)
	model__n: Option<Vec<String>>,
	modified_by_request: Option<String>,
	/// Has module bays
	module_bays: Option<bool>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// OOB IP (ID)
	oob_ip_id: Option<Vec<i64>>,
	/// OOB IP (ID)
	oob_ip_id__n: Option<Vec<i64>>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent Device (ID)
	parent_device_id: Option<Vec<i64>>,
	/// Parent Device (ID)
	parent_device_id__n: Option<Vec<i64>>,
	/// Has pass-through ports
	pass_through_ports: Option<bool>,
	/// Platform (slug)
	platform: Option<Vec<String>>,
	/// Platform (slug)
	platform__n: Option<Vec<String>>,
	/// Platform (ID)
	platform_id: Option<Vec<i64>>,
	/// Platform (ID)
	platform_id__n: Option<Vec<i64>>,
	position: Option<Vec<f64>>,
	position__empty: Option<bool>,
	position__gt: Option<Vec<f64>>,
	position__gte: Option<Vec<f64>>,
	position__lt: Option<Vec<f64>>,
	position__lte: Option<Vec<f64>>,
	position__n: Option<Vec<f64>>,
	/// Has power outlets
	power_outlets: Option<bool>,
	/// Has power ports
	power_ports: Option<bool>,
	/// Primary IPv4 (ID)
	primary_ip4_id: Option<Vec<i64>>,
	/// Primary IPv4 (ID)
	primary_ip4_id__n: Option<Vec<i64>>,
	/// Primary IPv6 (ID)
	primary_ip6_id: Option<Vec<i64>>,
	/// Primary IPv6 (ID)
	primary_ip6_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	serial: Option<Vec<String>>,
	serial__empty: Option<bool>,
	serial__ic: Option<Vec<String>>,
	serial__ie: Option<Vec<String>>,
	serial__iew: Option<Vec<String>>,
	serial__isw: Option<Vec<String>>,
	serial__n: Option<Vec<String>>,
	serial__nic: Option<Vec<String>>,
	serial__nie: Option<Vec<String>>,
	serial__niew: Option<Vec<String>>,
	serial__nisw: Option<Vec<String>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	vc_position: Option<Vec<i64>>,
	vc_position__empty: Option<bool>,
	vc_position__gt: Option<Vec<i64>>,
	vc_position__gte: Option<Vec<i64>>,
	vc_position__lt: Option<Vec<i64>>,
	vc_position__lte: Option<Vec<i64>>,
	vc_position__n: Option<Vec<i64>>,
	vc_priority: Option<Vec<i64>>,
	vc_priority__empty: Option<bool>,
	vc_priority__gt: Option<Vec<i64>>,
	vc_priority__gte: Option<Vec<i64>>,
	vc_priority__lt: Option<Vec<i64>>,
	vc_priority__lte: Option<Vec<i64>>,
	vc_priority__n: Option<Vec<i64>>,
	/// Virtual chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,
	/// Is a virtual chassis member
	virtual_chassis_member: Option<bool>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesListResponse {
	Http200(PaginatedDeviceWithConfigContextList),
	#[default]
	None
}
/// Get a list of device objects.
pub fn dcim_devices_list(state: &ThanixClient, query: DcimDevicesListQuery) -> Result<DcimDevicesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/devices/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesListResponse::Http200(r#response.json::<PaginatedDeviceWithConfigContextList>()?)) },
		_ => { Ok(DcimDevicesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesBulkUpdateResponse {
	Http200(Vec<DeviceWithConfigContext>),
	#[default]
	None
}
/// Put a list of device objects.
pub fn dcim_devices_bulk_update(state: &ThanixClient, body: Vec<DeviceWithConfigContextRequest>) -> Result<DcimDevicesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/devices/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesBulkUpdateResponse::Http200(r#response.json::<Vec<DeviceWithConfigContext>>()?)) },
		_ => { Ok(DcimDevicesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesCreateResponse {
	Http201(DeviceWithConfigContext),
	#[default]
	None
}
/// Post a list of device objects.
pub fn dcim_devices_create(state: &ThanixClient, body: WritableDeviceWithConfigContextRequest) -> Result<DcimDevicesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/devices/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimDevicesCreateResponse::Http201(r#response.json::<DeviceWithConfigContext>()?)) },
		_ => { Ok(DcimDevicesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of device objects.
pub fn dcim_devices_bulk_destroy(state: &ThanixClient, body: Vec<DeviceWithConfigContextRequest>) -> Result<DcimDevicesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/devices/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDevicesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesBulkPartialUpdateResponse {
	Http200(Vec<DeviceWithConfigContext>),
	#[default]
	None
}
/// Patch a list of device objects.
pub fn dcim_devices_bulk_partial_update(state: &ThanixClient, body: Vec<DeviceWithConfigContextRequest>) -> Result<DcimDevicesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/devices/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<DeviceWithConfigContext>>()?)) },
		_ => { Ok(DcimDevicesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesRetrieveResponse {
	Http200(DeviceWithConfigContext),
	#[default]
	None
}
/// Get a device object.
pub fn dcim_devices_retrieve(state: &ThanixClient, id: i64) -> Result<DcimDevicesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/devices/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesRetrieveResponse::Http200(r#response.json::<DeviceWithConfigContext>()?)) },
		_ => { Ok(DcimDevicesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesUpdateResponse {
	Http200(DeviceWithConfigContext),
	#[default]
	None
}
/// Put a device object.
pub fn dcim_devices_update(state: &ThanixClient, body: WritableDeviceWithConfigContextRequest, id: i64) -> Result<DcimDevicesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/devices/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesUpdateResponse::Http200(r#response.json::<DeviceWithConfigContext>()?)) },
		_ => { Ok(DcimDevicesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a device object.
pub fn dcim_devices_destroy(state: &ThanixClient, id: i64) -> Result<DcimDevicesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/devices/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimDevicesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesPartialUpdateResponse {
	Http200(DeviceWithConfigContext),
	#[default]
	None
}
/// Patch a device object.
pub fn dcim_devices_partial_update(state: &ThanixClient, body: PatchedWritableDeviceWithConfigContextRequest, id: i64) -> Result<DcimDevicesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/devices/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesPartialUpdateResponse::Http200(r#response.json::<DeviceWithConfigContext>()?)) },
		_ => { Ok(DcimDevicesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimDevicesRenderConfigCreateQuery {
	format: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimDevicesRenderConfigCreateResponse {
	Http200(DeviceWithConfigContext),
	#[default]
	None
}
/// Resolve and render the preferred ConfigTemplate for this Device.
pub fn dcim_devices_render_config_create(state: &ThanixClient, query: DcimDevicesRenderConfigCreateQuery, body: WritableDeviceWithConfigContextRequest, id: i64) -> Result<DcimDevicesRenderConfigCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/devices/{id}/render-config/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimDevicesRenderConfigCreateResponse::Http200(r#response.json::<DeviceWithConfigContext>()?)) },
		_ => { Ok(DcimDevicesRenderConfigCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimFrontPortTemplatesListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesListResponse {
	Http200(PaginatedFrontPortTemplateList),
	#[default]
	None
}
/// Get a list of front port template objects.
pub fn dcim_front_port_templates_list(state: &ThanixClient, query: DcimFrontPortTemplatesListQuery) -> Result<DcimFrontPortTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/front-port-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortTemplatesListResponse::Http200(r#response.json::<PaginatedFrontPortTemplateList>()?)) },
		_ => { Ok(DcimFrontPortTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesBulkUpdateResponse {
	Http200(Vec<FrontPortTemplate>),
	#[default]
	None
}
/// Put a list of front port template objects.
pub fn dcim_front_port_templates_bulk_update(state: &ThanixClient, body: Vec<FrontPortTemplateRequest>) -> Result<DcimFrontPortTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/front-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<FrontPortTemplate>>()?)) },
		_ => { Ok(DcimFrontPortTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesCreateResponse {
	Http201(FrontPortTemplate),
	#[default]
	None
}
/// Post a list of front port template objects.
pub fn dcim_front_port_templates_create(state: &ThanixClient, body: WritableFrontPortTemplateRequest) -> Result<DcimFrontPortTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/front-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimFrontPortTemplatesCreateResponse::Http201(r#response.json::<FrontPortTemplate>()?)) },
		_ => { Ok(DcimFrontPortTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of front port template objects.
pub fn dcim_front_port_templates_bulk_destroy(state: &ThanixClient, body: Vec<FrontPortTemplateRequest>) -> Result<DcimFrontPortTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/front-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimFrontPortTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesBulkPartialUpdateResponse {
	Http200(Vec<FrontPortTemplate>),
	#[default]
	None
}
/// Patch a list of front port template objects.
pub fn dcim_front_port_templates_bulk_partial_update(state: &ThanixClient, body: Vec<FrontPortTemplateRequest>) -> Result<DcimFrontPortTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/front-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<FrontPortTemplate>>()?)) },
		_ => { Ok(DcimFrontPortTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesRetrieveResponse {
	Http200(FrontPortTemplate),
	#[default]
	None
}
/// Get a front port template object.
pub fn dcim_front_port_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimFrontPortTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/front-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortTemplatesRetrieveResponse::Http200(r#response.json::<FrontPortTemplate>()?)) },
		_ => { Ok(DcimFrontPortTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesUpdateResponse {
	Http200(FrontPortTemplate),
	#[default]
	None
}
/// Put a front port template object.
pub fn dcim_front_port_templates_update(state: &ThanixClient, body: WritableFrontPortTemplateRequest, id: i64) -> Result<DcimFrontPortTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/front-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortTemplatesUpdateResponse::Http200(r#response.json::<FrontPortTemplate>()?)) },
		_ => { Ok(DcimFrontPortTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a front port template object.
pub fn dcim_front_port_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimFrontPortTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/front-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimFrontPortTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortTemplatesPartialUpdateResponse {
	Http200(FrontPortTemplate),
	#[default]
	None
}
/// Patch a front port template object.
pub fn dcim_front_port_templates_partial_update(state: &ThanixClient, body: PatchedWritableFrontPortTemplateRequest, id: i64) -> Result<DcimFrontPortTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/front-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortTemplatesPartialUpdateResponse::Http200(r#response.json::<FrontPortTemplate>()?)) },
		_ => { Ok(DcimFrontPortTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimFrontPortsListQuery {
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsListResponse {
	Http200(PaginatedFrontPortList),
	#[default]
	None
}
/// Get a list of front port objects.
pub fn dcim_front_ports_list(state: &ThanixClient, query: DcimFrontPortsListQuery) -> Result<DcimFrontPortsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/front-ports/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsListResponse::Http200(r#response.json::<PaginatedFrontPortList>()?)) },
		_ => { Ok(DcimFrontPortsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsBulkUpdateResponse {
	Http200(Vec<FrontPort>),
	#[default]
	None
}
/// Put a list of front port objects.
pub fn dcim_front_ports_bulk_update(state: &ThanixClient, body: Vec<FrontPortRequest>) -> Result<DcimFrontPortsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/front-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsBulkUpdateResponse::Http200(r#response.json::<Vec<FrontPort>>()?)) },
		_ => { Ok(DcimFrontPortsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsCreateResponse {
	Http201(FrontPort),
	#[default]
	None
}
/// Post a list of front port objects.
pub fn dcim_front_ports_create(state: &ThanixClient, body: WritableFrontPortRequest) -> Result<DcimFrontPortsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/front-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimFrontPortsCreateResponse::Http201(r#response.json::<FrontPort>()?)) },
		_ => { Ok(DcimFrontPortsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of front port objects.
pub fn dcim_front_ports_bulk_destroy(state: &ThanixClient, body: Vec<FrontPortRequest>) -> Result<DcimFrontPortsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/front-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimFrontPortsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsBulkPartialUpdateResponse {
	Http200(Vec<FrontPort>),
	#[default]
	None
}
/// Patch a list of front port objects.
pub fn dcim_front_ports_bulk_partial_update(state: &ThanixClient, body: Vec<FrontPortRequest>) -> Result<DcimFrontPortsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/front-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<FrontPort>>()?)) },
		_ => { Ok(DcimFrontPortsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsRetrieveResponse {
	Http200(FrontPort),
	#[default]
	None
}
/// Get a front port object.
pub fn dcim_front_ports_retrieve(state: &ThanixClient, id: i64) -> Result<DcimFrontPortsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/front-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsRetrieveResponse::Http200(r#response.json::<FrontPort>()?)) },
		_ => { Ok(DcimFrontPortsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsUpdateResponse {
	Http200(FrontPort),
	#[default]
	None
}
/// Put a front port object.
pub fn dcim_front_ports_update(state: &ThanixClient, body: WritableFrontPortRequest, id: i64) -> Result<DcimFrontPortsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/front-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsUpdateResponse::Http200(r#response.json::<FrontPort>()?)) },
		_ => { Ok(DcimFrontPortsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a front port object.
pub fn dcim_front_ports_destroy(state: &ThanixClient, id: i64) -> Result<DcimFrontPortsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/front-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimFrontPortsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsPartialUpdateResponse {
	Http200(FrontPort),
	#[default]
	None
}
/// Patch a front port object.
pub fn dcim_front_ports_partial_update(state: &ThanixClient, body: PatchedWritableFrontPortRequest, id: i64) -> Result<DcimFrontPortsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/front-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsPartialUpdateResponse::Http200(r#response.json::<FrontPort>()?)) },
		_ => { Ok(DcimFrontPortsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimFrontPortsPathsRetrieveResponse {
	Http200(FrontPort),
	#[default]
	None
}
/// Return all CablePaths which traverse a given pass-through port.
pub fn dcim_front_ports_paths_retrieve(state: &ThanixClient, id: i64) -> Result<DcimFrontPortsPathsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/front-ports/{id}/paths/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimFrontPortsPathsRetrieveResponse::Http200(r#response.json::<FrontPort>()?)) },
		_ => { Ok(DcimFrontPortsPathsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimInterfaceTemplatesListQuery {
	bridge_id: Option<Vec<i64>>,
	bridge_id__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	enabled: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mgmt_only: Option<bool>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	poe_mode: Option<Vec<String>>,
	poe_mode__n: Option<Vec<String>>,
	poe_type: Option<Vec<String>>,
	poe_type__n: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	rf_role: Option<Vec<String>>,
	rf_role__n: Option<Vec<String>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesListResponse {
	Http200(PaginatedInterfaceTemplateList),
	#[default]
	None
}
/// Get a list of interface template objects.
pub fn dcim_interface_templates_list(state: &ThanixClient, query: DcimInterfaceTemplatesListQuery) -> Result<DcimInterfaceTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/interface-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfaceTemplatesListResponse::Http200(r#response.json::<PaginatedInterfaceTemplateList>()?)) },
		_ => { Ok(DcimInterfaceTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesBulkUpdateResponse {
	Http200(Vec<InterfaceTemplate>),
	#[default]
	None
}
/// Put a list of interface template objects.
pub fn dcim_interface_templates_bulk_update(state: &ThanixClient, body: Vec<InterfaceTemplateRequest>) -> Result<DcimInterfaceTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/interface-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfaceTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<InterfaceTemplate>>()?)) },
		_ => { Ok(DcimInterfaceTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesCreateResponse {
	Http201(InterfaceTemplate),
	#[default]
	None
}
/// Post a list of interface template objects.
pub fn dcim_interface_templates_create(state: &ThanixClient, body: WritableInterfaceTemplateRequest) -> Result<DcimInterfaceTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/interface-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimInterfaceTemplatesCreateResponse::Http201(r#response.json::<InterfaceTemplate>()?)) },
		_ => { Ok(DcimInterfaceTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of interface template objects.
pub fn dcim_interface_templates_bulk_destroy(state: &ThanixClient, body: Vec<InterfaceTemplateRequest>) -> Result<DcimInterfaceTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/interface-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInterfaceTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesBulkPartialUpdateResponse {
	Http200(Vec<InterfaceTemplate>),
	#[default]
	None
}
/// Patch a list of interface template objects.
pub fn dcim_interface_templates_bulk_partial_update(state: &ThanixClient, body: Vec<InterfaceTemplateRequest>) -> Result<DcimInterfaceTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/interface-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfaceTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<InterfaceTemplate>>()?)) },
		_ => { Ok(DcimInterfaceTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesRetrieveResponse {
	Http200(InterfaceTemplate),
	#[default]
	None
}
/// Get a interface template object.
pub fn dcim_interface_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimInterfaceTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/interface-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfaceTemplatesRetrieveResponse::Http200(r#response.json::<InterfaceTemplate>()?)) },
		_ => { Ok(DcimInterfaceTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesUpdateResponse {
	Http200(InterfaceTemplate),
	#[default]
	None
}
/// Put a interface template object.
pub fn dcim_interface_templates_update(state: &ThanixClient, body: WritableInterfaceTemplateRequest, id: i64) -> Result<DcimInterfaceTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/interface-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfaceTemplatesUpdateResponse::Http200(r#response.json::<InterfaceTemplate>()?)) },
		_ => { Ok(DcimInterfaceTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a interface template object.
pub fn dcim_interface_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimInterfaceTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/interface-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInterfaceTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfaceTemplatesPartialUpdateResponse {
	Http200(InterfaceTemplate),
	#[default]
	None
}
/// Patch a interface template object.
pub fn dcim_interface_templates_partial_update(state: &ThanixClient, body: PatchedWritableInterfaceTemplateRequest, id: i64) -> Result<DcimInterfaceTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/interface-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfaceTemplatesPartialUpdateResponse::Http200(r#response.json::<InterfaceTemplate>()?)) },
		_ => { Ok(DcimInterfaceTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimInterfacesListQuery {
	/// Bridged interface (ID)
	bridge_id: Option<Vec<i64>>,
	/// Bridged interface (ID)
	bridge_id__n: Option<Vec<i64>>,
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	connected: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	duplex: Option<Vec<Option<String>>>,
	duplex__n: Option<Vec<Option<String>>>,
	enabled: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Kind of interface
	kind: Option<String>,
	/// L2VPN
	l2vpn: Option<Vec<i64>>,
	/// L2VPN
	l2vpn__n: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	/// LAG interface (ID)
	lag_id: Option<Vec<i64>>,
	/// LAG interface (ID)
	lag_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	mac_address: Option<Vec<String>>,
	mac_address__ic: Option<Vec<String>>,
	mac_address__ie: Option<Vec<String>>,
	mac_address__iew: Option<Vec<String>>,
	mac_address__isw: Option<Vec<String>>,
	mac_address__n: Option<Vec<String>>,
	mac_address__nic: Option<Vec<String>>,
	mac_address__nie: Option<Vec<String>>,
	mac_address__niew: Option<Vec<String>>,
	mac_address__nisw: Option<Vec<String>>,
	mgmt_only: Option<bool>,
	/// IEEE 802.1Q tagging strategy
	mode: Option<String>,
	/// IEEE 802.1Q tagging strategy
	mode__n: Option<String>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	mtu: Option<Vec<i64>>,
	mtu__empty: Option<bool>,
	mtu__gt: Option<Vec<i64>>,
	mtu__gte: Option<Vec<i64>>,
	mtu__lt: Option<Vec<i64>>,
	mtu__lte: Option<Vec<i64>>,
	mtu__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent interface (ID)
	parent_id: Option<Vec<i64>>,
	/// Parent interface (ID)
	parent_id__n: Option<Vec<i64>>,
	poe_mode: Option<Vec<String>>,
	poe_mode__n: Option<Vec<String>>,
	poe_type: Option<Vec<String>>,
	poe_type__n: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	rf_channel: Option<Vec<String>>,
	rf_channel__n: Option<Vec<String>>,
	rf_channel_frequency: Option<Vec<f64>>,
	rf_channel_frequency__empty: Option<bool>,
	rf_channel_frequency__gt: Option<Vec<f64>>,
	rf_channel_frequency__gte: Option<Vec<f64>>,
	rf_channel_frequency__lt: Option<Vec<f64>>,
	rf_channel_frequency__lte: Option<Vec<f64>>,
	rf_channel_frequency__n: Option<Vec<f64>>,
	rf_channel_width: Option<Vec<f64>>,
	rf_channel_width__empty: Option<bool>,
	rf_channel_width__gt: Option<Vec<f64>>,
	rf_channel_width__gte: Option<Vec<f64>>,
	rf_channel_width__lt: Option<Vec<f64>>,
	rf_channel_width__lte: Option<Vec<f64>>,
	rf_channel_width__n: Option<Vec<f64>>,
	rf_role: Option<Vec<String>>,
	rf_role__n: Option<Vec<String>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	speed: Option<Vec<i64>>,
	speed__empty: Option<Vec<i64>>,
	speed__gt: Option<Vec<i64>>,
	speed__gte: Option<Vec<i64>>,
	speed__lt: Option<Vec<i64>>,
	speed__lte: Option<Vec<i64>>,
	speed__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	tx_power: Option<Vec<i64>>,
	tx_power__empty: Option<bool>,
	tx_power__gt: Option<Vec<i64>>,
	tx_power__gte: Option<Vec<i64>>,
	tx_power__lt: Option<Vec<i64>>,
	tx_power__lte: Option<Vec<i64>>,
	tx_power__n: Option<Vec<i64>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Device Context
	vdc: Option<Vec<String>>,
	/// Virtual Device Context
	vdc__n: Option<Vec<String>>,
	/// Virtual Device Context
	vdc_id: Option<Vec<i64>>,
	/// Virtual Device Context
	vdc_id__n: Option<Vec<i64>>,
	/// Virtual Device Context (Identifier)
	vdc_identifier: Option<Vec<u16>>,
	/// Virtual Device Context (Identifier)
	vdc_identifier__n: Option<Vec<u16>>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,
	virtual_chassis_member: Option<Vec<String>>,
	virtual_chassis_member_id: Option<Vec<i64>>,
	/// Assigned VID
	vlan: Option<String>,
	/// Assigned VLAN
	vlan_id: Option<String>,
	/// VRF (RD)
	vrf: Option<Vec<Option<String>>>,
	/// VRF (RD)
	vrf__n: Option<Vec<Option<String>>>,
	/// VRF
	vrf_id: Option<Vec<i64>>,
	/// VRF
	vrf_id__n: Option<Vec<i64>>,
	wwn: Option<Vec<String>>,
	wwn__ic: Option<Vec<String>>,
	wwn__ie: Option<Vec<String>>,
	wwn__iew: Option<Vec<String>>,
	wwn__isw: Option<Vec<String>>,
	wwn__n: Option<Vec<String>>,
	wwn__nic: Option<Vec<String>>,
	wwn__nie: Option<Vec<String>>,
	wwn__niew: Option<Vec<String>>,
	wwn__nisw: Option<Vec<String>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesListResponse {
	Http200(PaginatedInterfaceList),
	#[default]
	None
}
/// Get a list of interface objects.
pub fn dcim_interfaces_list(state: &ThanixClient, query: DcimInterfacesListQuery) -> Result<DcimInterfacesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/interfaces/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesListResponse::Http200(r#response.json::<PaginatedInterfaceList>()?)) },
		_ => { Ok(DcimInterfacesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesBulkUpdateResponse {
	Http200(Vec<Interface>),
	#[default]
	None
}
/// Put a list of interface objects.
pub fn dcim_interfaces_bulk_update(state: &ThanixClient, body: Vec<InterfaceRequest>) -> Result<DcimInterfacesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesBulkUpdateResponse::Http200(r#response.json::<Vec<Interface>>()?)) },
		_ => { Ok(DcimInterfacesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesCreateResponse {
	Http201(Interface),
	#[default]
	None
}
/// Post a list of interface objects.
pub fn dcim_interfaces_create(state: &ThanixClient, body: WritableInterfaceRequest) -> Result<DcimInterfacesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimInterfacesCreateResponse::Http201(r#response.json::<Interface>()?)) },
		_ => { Ok(DcimInterfacesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of interface objects.
pub fn dcim_interfaces_bulk_destroy(state: &ThanixClient, body: Vec<InterfaceRequest>) -> Result<DcimInterfacesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInterfacesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesBulkPartialUpdateResponse {
	Http200(Vec<Interface>),
	#[default]
	None
}
/// Patch a list of interface objects.
pub fn dcim_interfaces_bulk_partial_update(state: &ThanixClient, body: Vec<InterfaceRequest>) -> Result<DcimInterfacesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Interface>>()?)) },
		_ => { Ok(DcimInterfacesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesRetrieveResponse {
	Http200(Interface),
	#[default]
	None
}
/// Get a interface object.
pub fn dcim_interfaces_retrieve(state: &ThanixClient, id: i64) -> Result<DcimInterfacesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesRetrieveResponse::Http200(r#response.json::<Interface>()?)) },
		_ => { Ok(DcimInterfacesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesUpdateResponse {
	Http200(Interface),
	#[default]
	None
}
/// Put a interface object.
pub fn dcim_interfaces_update(state: &ThanixClient, body: WritableInterfaceRequest, id: i64) -> Result<DcimInterfacesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesUpdateResponse::Http200(r#response.json::<Interface>()?)) },
		_ => { Ok(DcimInterfacesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a interface object.
pub fn dcim_interfaces_destroy(state: &ThanixClient, id: i64) -> Result<DcimInterfacesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInterfacesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesPartialUpdateResponse {
	Http200(Interface),
	#[default]
	None
}
/// Patch a interface object.
pub fn dcim_interfaces_partial_update(state: &ThanixClient, body: PatchedWritableInterfaceRequest, id: i64) -> Result<DcimInterfacesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesPartialUpdateResponse::Http200(r#response.json::<Interface>()?)) },
		_ => { Ok(DcimInterfacesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInterfacesTraceRetrieveResponse {
	Http200(Interface),
	#[default]
	None
}
/// Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
pub fn dcim_interfaces_trace_retrieve(state: &ThanixClient, id: i64) -> Result<DcimInterfacesTraceRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/interfaces/{id}/trace/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInterfacesTraceRetrieveResponse::Http200(r#response.json::<Interface>()?)) },
		_ => { Ok(DcimInterfacesTraceRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimInventoryItemRolesListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesListResponse {
	Http200(PaginatedInventoryItemRoleList),
	#[default]
	None
}
/// Get a list of inventory item role objects.
pub fn dcim_inventory_item_roles_list(state: &ThanixClient, query: DcimInventoryItemRolesListQuery) -> Result<DcimInventoryItemRolesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/inventory-item-roles/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemRolesListResponse::Http200(r#response.json::<PaginatedInventoryItemRoleList>()?)) },
		_ => { Ok(DcimInventoryItemRolesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesBulkUpdateResponse {
	Http200(Vec<InventoryItemRole>),
	#[default]
	None
}
/// Put a list of inventory item role objects.
pub fn dcim_inventory_item_roles_bulk_update(state: &ThanixClient, body: Vec<InventoryItemRoleRequest>) -> Result<DcimInventoryItemRolesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/inventory-item-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemRolesBulkUpdateResponse::Http200(r#response.json::<Vec<InventoryItemRole>>()?)) },
		_ => { Ok(DcimInventoryItemRolesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesCreateResponse {
	Http201(InventoryItemRole),
	#[default]
	None
}
/// Post a list of inventory item role objects.
pub fn dcim_inventory_item_roles_create(state: &ThanixClient, body: InventoryItemRoleRequest) -> Result<DcimInventoryItemRolesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/inventory-item-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimInventoryItemRolesCreateResponse::Http201(r#response.json::<InventoryItemRole>()?)) },
		_ => { Ok(DcimInventoryItemRolesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of inventory item role objects.
pub fn dcim_inventory_item_roles_bulk_destroy(state: &ThanixClient, body: Vec<InventoryItemRoleRequest>) -> Result<DcimInventoryItemRolesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/inventory-item-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInventoryItemRolesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesBulkPartialUpdateResponse {
	Http200(Vec<InventoryItemRole>),
	#[default]
	None
}
/// Patch a list of inventory item role objects.
pub fn dcim_inventory_item_roles_bulk_partial_update(state: &ThanixClient, body: Vec<InventoryItemRoleRequest>) -> Result<DcimInventoryItemRolesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/inventory-item-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemRolesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<InventoryItemRole>>()?)) },
		_ => { Ok(DcimInventoryItemRolesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesRetrieveResponse {
	Http200(InventoryItemRole),
	#[default]
	None
}
/// Get a inventory item role object.
pub fn dcim_inventory_item_roles_retrieve(state: &ThanixClient, id: i64) -> Result<DcimInventoryItemRolesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/inventory-item-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemRolesRetrieveResponse::Http200(r#response.json::<InventoryItemRole>()?)) },
		_ => { Ok(DcimInventoryItemRolesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesUpdateResponse {
	Http200(InventoryItemRole),
	#[default]
	None
}
/// Put a inventory item role object.
pub fn dcim_inventory_item_roles_update(state: &ThanixClient, body: InventoryItemRoleRequest, id: i64) -> Result<DcimInventoryItemRolesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/inventory-item-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemRolesUpdateResponse::Http200(r#response.json::<InventoryItemRole>()?)) },
		_ => { Ok(DcimInventoryItemRolesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a inventory item role object.
pub fn dcim_inventory_item_roles_destroy(state: &ThanixClient, id: i64) -> Result<DcimInventoryItemRolesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/inventory-item-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInventoryItemRolesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemRolesPartialUpdateResponse {
	Http200(InventoryItemRole),
	#[default]
	None
}
/// Patch a inventory item role object.
pub fn dcim_inventory_item_roles_partial_update(state: &ThanixClient, body: PatchedInventoryItemRoleRequest, id: i64) -> Result<DcimInventoryItemRolesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/inventory-item-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemRolesPartialUpdateResponse::Http200(r#response.json::<InventoryItemRole>()?)) },
		_ => { Ok(DcimInventoryItemRolesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimInventoryItemTemplatesListQuery {
	component_id: Option<Vec<i64>>,
	component_id__empty: Option<Vec<i64>>,
	component_id__gt: Option<Vec<i64>>,
	component_id__gte: Option<Vec<i64>>,
	component_id__lt: Option<Vec<i64>>,
	component_id__lte: Option<Vec<i64>>,
	component_id__n: Option<Vec<i64>>,
	component_type: Option<String>,
	component_type__n: Option<String>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent inventory item (ID)
	parent_id: Option<Vec<i64>>,
	/// Parent inventory item (ID)
	parent_id__n: Option<Vec<i64>>,
	part_id: Option<Vec<String>>,
	part_id__empty: Option<bool>,
	part_id__ic: Option<Vec<String>>,
	part_id__ie: Option<Vec<String>>,
	part_id__iew: Option<Vec<String>>,
	part_id__isw: Option<Vec<String>>,
	part_id__n: Option<Vec<String>>,
	part_id__nic: Option<Vec<String>>,
	part_id__nie: Option<Vec<String>>,
	part_id__niew: Option<Vec<String>>,
	part_id__nisw: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesListResponse {
	Http200(PaginatedInventoryItemTemplateList),
	#[default]
	None
}
/// Get a list of inventory item template objects.
pub fn dcim_inventory_item_templates_list(state: &ThanixClient, query: DcimInventoryItemTemplatesListQuery) -> Result<DcimInventoryItemTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/inventory-item-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemTemplatesListResponse::Http200(r#response.json::<PaginatedInventoryItemTemplateList>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesBulkUpdateResponse {
	Http200(Vec<InventoryItemTemplate>),
	#[default]
	None
}
/// Put a list of inventory item template objects.
pub fn dcim_inventory_item_templates_bulk_update(state: &ThanixClient, body: Vec<InventoryItemTemplateRequest>) -> Result<DcimInventoryItemTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/inventory-item-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<InventoryItemTemplate>>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesCreateResponse {
	Http201(InventoryItemTemplate),
	#[default]
	None
}
/// Post a list of inventory item template objects.
pub fn dcim_inventory_item_templates_create(state: &ThanixClient, body: WritableInventoryItemTemplateRequest) -> Result<DcimInventoryItemTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/inventory-item-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimInventoryItemTemplatesCreateResponse::Http201(r#response.json::<InventoryItemTemplate>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of inventory item template objects.
pub fn dcim_inventory_item_templates_bulk_destroy(state: &ThanixClient, body: Vec<InventoryItemTemplateRequest>) -> Result<DcimInventoryItemTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/inventory-item-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInventoryItemTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesBulkPartialUpdateResponse {
	Http200(Vec<InventoryItemTemplate>),
	#[default]
	None
}
/// Patch a list of inventory item template objects.
pub fn dcim_inventory_item_templates_bulk_partial_update(state: &ThanixClient, body: Vec<InventoryItemTemplateRequest>) -> Result<DcimInventoryItemTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/inventory-item-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<InventoryItemTemplate>>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesRetrieveResponse {
	Http200(InventoryItemTemplate),
	#[default]
	None
}
/// Get a inventory item template object.
pub fn dcim_inventory_item_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimInventoryItemTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/inventory-item-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemTemplatesRetrieveResponse::Http200(r#response.json::<InventoryItemTemplate>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesUpdateResponse {
	Http200(InventoryItemTemplate),
	#[default]
	None
}
/// Put a inventory item template object.
pub fn dcim_inventory_item_templates_update(state: &ThanixClient, body: WritableInventoryItemTemplateRequest, id: i64) -> Result<DcimInventoryItemTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/inventory-item-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemTemplatesUpdateResponse::Http200(r#response.json::<InventoryItemTemplate>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a inventory item template object.
pub fn dcim_inventory_item_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimInventoryItemTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/inventory-item-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInventoryItemTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemTemplatesPartialUpdateResponse {
	Http200(InventoryItemTemplate),
	#[default]
	None
}
/// Patch a inventory item template object.
pub fn dcim_inventory_item_templates_partial_update(state: &ThanixClient, body: PatchedWritableInventoryItemTemplateRequest, id: i64) -> Result<DcimInventoryItemTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/inventory-item-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemTemplatesPartialUpdateResponse::Http200(r#response.json::<InventoryItemTemplate>()?)) },
		_ => { Ok(DcimInventoryItemTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimInventoryItemsListQuery {
	asset_tag: Option<Vec<String>>,
	asset_tag__empty: Option<bool>,
	asset_tag__ic: Option<Vec<String>>,
	asset_tag__ie: Option<Vec<String>>,
	asset_tag__iew: Option<Vec<String>>,
	asset_tag__isw: Option<Vec<String>>,
	asset_tag__n: Option<Vec<String>>,
	asset_tag__nic: Option<Vec<String>>,
	asset_tag__nie: Option<Vec<String>>,
	asset_tag__niew: Option<Vec<String>>,
	asset_tag__nisw: Option<Vec<String>>,
	component_id: Option<Vec<i64>>,
	component_id__empty: Option<Vec<i64>>,
	component_id__gt: Option<Vec<i64>>,
	component_id__gte: Option<Vec<i64>>,
	component_id__lt: Option<Vec<i64>>,
	component_id__lte: Option<Vec<i64>>,
	component_id__n: Option<Vec<i64>>,
	component_type: Option<String>,
	component_type__n: Option<String>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	discovered: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent inventory item (ID)
	parent_id: Option<Vec<i64>>,
	/// Parent inventory item (ID)
	parent_id__n: Option<Vec<i64>>,
	part_id: Option<Vec<String>>,
	part_id__empty: Option<bool>,
	part_id__ic: Option<Vec<String>>,
	part_id__ie: Option<Vec<String>>,
	part_id__iew: Option<Vec<String>>,
	part_id__isw: Option<Vec<String>>,
	part_id__n: Option<Vec<String>>,
	part_id__nic: Option<Vec<String>>,
	part_id__nie: Option<Vec<String>>,
	part_id__niew: Option<Vec<String>>,
	part_id__nisw: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	serial: Option<Vec<String>>,
	serial__empty: Option<bool>,
	serial__ic: Option<Vec<String>>,
	serial__ie: Option<Vec<String>>,
	serial__iew: Option<Vec<String>>,
	serial__isw: Option<Vec<String>>,
	serial__n: Option<Vec<String>>,
	serial__nic: Option<Vec<String>>,
	serial__nie: Option<Vec<String>>,
	serial__niew: Option<Vec<String>>,
	serial__nisw: Option<Vec<String>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsListResponse {
	Http200(PaginatedInventoryItemList),
	#[default]
	None
}
/// Get a list of inventory item objects.
pub fn dcim_inventory_items_list(state: &ThanixClient, query: DcimInventoryItemsListQuery) -> Result<DcimInventoryItemsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/inventory-items/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemsListResponse::Http200(r#response.json::<PaginatedInventoryItemList>()?)) },
		_ => { Ok(DcimInventoryItemsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsBulkUpdateResponse {
	Http200(Vec<InventoryItem>),
	#[default]
	None
}
/// Put a list of inventory item objects.
pub fn dcim_inventory_items_bulk_update(state: &ThanixClient, body: Vec<InventoryItemRequest>) -> Result<DcimInventoryItemsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/inventory-items/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemsBulkUpdateResponse::Http200(r#response.json::<Vec<InventoryItem>>()?)) },
		_ => { Ok(DcimInventoryItemsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsCreateResponse {
	Http201(InventoryItem),
	#[default]
	None
}
/// Post a list of inventory item objects.
pub fn dcim_inventory_items_create(state: &ThanixClient, body: WritableInventoryItemRequest) -> Result<DcimInventoryItemsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/inventory-items/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimInventoryItemsCreateResponse::Http201(r#response.json::<InventoryItem>()?)) },
		_ => { Ok(DcimInventoryItemsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of inventory item objects.
pub fn dcim_inventory_items_bulk_destroy(state: &ThanixClient, body: Vec<InventoryItemRequest>) -> Result<DcimInventoryItemsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/inventory-items/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInventoryItemsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsBulkPartialUpdateResponse {
	Http200(Vec<InventoryItem>),
	#[default]
	None
}
/// Patch a list of inventory item objects.
pub fn dcim_inventory_items_bulk_partial_update(state: &ThanixClient, body: Vec<InventoryItemRequest>) -> Result<DcimInventoryItemsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/inventory-items/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<InventoryItem>>()?)) },
		_ => { Ok(DcimInventoryItemsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsRetrieveResponse {
	Http200(InventoryItem),
	#[default]
	None
}
/// Get a inventory item object.
pub fn dcim_inventory_items_retrieve(state: &ThanixClient, id: i64) -> Result<DcimInventoryItemsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/inventory-items/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemsRetrieveResponse::Http200(r#response.json::<InventoryItem>()?)) },
		_ => { Ok(DcimInventoryItemsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsUpdateResponse {
	Http200(InventoryItem),
	#[default]
	None
}
/// Put a inventory item object.
pub fn dcim_inventory_items_update(state: &ThanixClient, body: WritableInventoryItemRequest, id: i64) -> Result<DcimInventoryItemsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/inventory-items/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemsUpdateResponse::Http200(r#response.json::<InventoryItem>()?)) },
		_ => { Ok(DcimInventoryItemsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a inventory item object.
pub fn dcim_inventory_items_destroy(state: &ThanixClient, id: i64) -> Result<DcimInventoryItemsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/inventory-items/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimInventoryItemsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimInventoryItemsPartialUpdateResponse {
	Http200(InventoryItem),
	#[default]
	None
}
/// Patch a inventory item object.
pub fn dcim_inventory_items_partial_update(state: &ThanixClient, body: PatchedWritableInventoryItemRequest, id: i64) -> Result<DcimInventoryItemsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/inventory-items/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimInventoryItemsPartialUpdateResponse::Http200(r#response.json::<InventoryItem>()?)) },
		_ => { Ok(DcimInventoryItemsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimLocationsListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Location (slug)
	parent: Option<Vec<i64>>,
	/// Location (slug)
	parent__n: Option<Vec<i64>>,
	/// Location (ID)
	parent_id: Option<Vec<i64>>,
	/// Location (ID)
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsListResponse {
	Http200(PaginatedLocationList),
	#[default]
	None
}
/// Get a list of location objects.
pub fn dcim_locations_list(state: &ThanixClient, query: DcimLocationsListQuery) -> Result<DcimLocationsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/locations/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimLocationsListResponse::Http200(r#response.json::<PaginatedLocationList>()?)) },
		_ => { Ok(DcimLocationsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsBulkUpdateResponse {
	Http200(Vec<Location>),
	#[default]
	None
}
/// Put a list of location objects.
pub fn dcim_locations_bulk_update(state: &ThanixClient, body: Vec<LocationRequest>) -> Result<DcimLocationsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/locations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimLocationsBulkUpdateResponse::Http200(r#response.json::<Vec<Location>>()?)) },
		_ => { Ok(DcimLocationsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsCreateResponse {
	Http201(Location),
	#[default]
	None
}
/// Post a list of location objects.
pub fn dcim_locations_create(state: &ThanixClient, body: WritableLocationRequest) -> Result<DcimLocationsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/locations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimLocationsCreateResponse::Http201(r#response.json::<Location>()?)) },
		_ => { Ok(DcimLocationsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of location objects.
pub fn dcim_locations_bulk_destroy(state: &ThanixClient, body: Vec<LocationRequest>) -> Result<DcimLocationsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/locations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimLocationsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsBulkPartialUpdateResponse {
	Http200(Vec<Location>),
	#[default]
	None
}
/// Patch a list of location objects.
pub fn dcim_locations_bulk_partial_update(state: &ThanixClient, body: Vec<LocationRequest>) -> Result<DcimLocationsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/locations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimLocationsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Location>>()?)) },
		_ => { Ok(DcimLocationsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsRetrieveResponse {
	Http200(Location),
	#[default]
	None
}
/// Get a location object.
pub fn dcim_locations_retrieve(state: &ThanixClient, id: i64) -> Result<DcimLocationsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/locations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimLocationsRetrieveResponse::Http200(r#response.json::<Location>()?)) },
		_ => { Ok(DcimLocationsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsUpdateResponse {
	Http200(Location),
	#[default]
	None
}
/// Put a location object.
pub fn dcim_locations_update(state: &ThanixClient, body: WritableLocationRequest, id: i64) -> Result<DcimLocationsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/locations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimLocationsUpdateResponse::Http200(r#response.json::<Location>()?)) },
		_ => { Ok(DcimLocationsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a location object.
pub fn dcim_locations_destroy(state: &ThanixClient, id: i64) -> Result<DcimLocationsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/locations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimLocationsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimLocationsPartialUpdateResponse {
	Http200(Location),
	#[default]
	None
}
/// Patch a location object.
pub fn dcim_locations_partial_update(state: &ThanixClient, body: PatchedWritableLocationRequest, id: i64) -> Result<DcimLocationsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/locations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimLocationsPartialUpdateResponse::Http200(r#response.json::<Location>()?)) },
		_ => { Ok(DcimLocationsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimManufacturersListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersListResponse {
	Http200(PaginatedManufacturerList),
	#[default]
	None
}
/// Get a list of manufacturer objects.
pub fn dcim_manufacturers_list(state: &ThanixClient, query: DcimManufacturersListQuery) -> Result<DcimManufacturersListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/manufacturers/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimManufacturersListResponse::Http200(r#response.json::<PaginatedManufacturerList>()?)) },
		_ => { Ok(DcimManufacturersListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersBulkUpdateResponse {
	Http200(Vec<Manufacturer>),
	#[default]
	None
}
/// Put a list of manufacturer objects.
pub fn dcim_manufacturers_bulk_update(state: &ThanixClient, body: Vec<ManufacturerRequest>) -> Result<DcimManufacturersBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/manufacturers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimManufacturersBulkUpdateResponse::Http200(r#response.json::<Vec<Manufacturer>>()?)) },
		_ => { Ok(DcimManufacturersBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersCreateResponse {
	Http201(Manufacturer),
	#[default]
	None
}
/// Post a list of manufacturer objects.
pub fn dcim_manufacturers_create(state: &ThanixClient, body: ManufacturerRequest) -> Result<DcimManufacturersCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/manufacturers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimManufacturersCreateResponse::Http201(r#response.json::<Manufacturer>()?)) },
		_ => { Ok(DcimManufacturersCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of manufacturer objects.
pub fn dcim_manufacturers_bulk_destroy(state: &ThanixClient, body: Vec<ManufacturerRequest>) -> Result<DcimManufacturersBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/manufacturers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimManufacturersBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersBulkPartialUpdateResponse {
	Http200(Vec<Manufacturer>),
	#[default]
	None
}
/// Patch a list of manufacturer objects.
pub fn dcim_manufacturers_bulk_partial_update(state: &ThanixClient, body: Vec<ManufacturerRequest>) -> Result<DcimManufacturersBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/manufacturers/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimManufacturersBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Manufacturer>>()?)) },
		_ => { Ok(DcimManufacturersBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersRetrieveResponse {
	Http200(Manufacturer),
	#[default]
	None
}
/// Get a manufacturer object.
pub fn dcim_manufacturers_retrieve(state: &ThanixClient, id: i64) -> Result<DcimManufacturersRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/manufacturers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimManufacturersRetrieveResponse::Http200(r#response.json::<Manufacturer>()?)) },
		_ => { Ok(DcimManufacturersRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersUpdateResponse {
	Http200(Manufacturer),
	#[default]
	None
}
/// Put a manufacturer object.
pub fn dcim_manufacturers_update(state: &ThanixClient, body: ManufacturerRequest, id: i64) -> Result<DcimManufacturersUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/manufacturers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimManufacturersUpdateResponse::Http200(r#response.json::<Manufacturer>()?)) },
		_ => { Ok(DcimManufacturersUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a manufacturer object.
pub fn dcim_manufacturers_destroy(state: &ThanixClient, id: i64) -> Result<DcimManufacturersDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/manufacturers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimManufacturersDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimManufacturersPartialUpdateResponse {
	Http200(Manufacturer),
	#[default]
	None
}
/// Patch a manufacturer object.
pub fn dcim_manufacturers_partial_update(state: &ThanixClient, body: PatchedManufacturerRequest, id: i64) -> Result<DcimManufacturersPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/manufacturers/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimManufacturersPartialUpdateResponse::Http200(r#response.json::<Manufacturer>()?)) },
		_ => { Ok(DcimManufacturersPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimModuleBayTemplatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesListResponse {
	Http200(PaginatedModuleBayTemplateList),
	#[default]
	None
}
/// Get a list of module bay template objects.
pub fn dcim_module_bay_templates_list(state: &ThanixClient, query: DcimModuleBayTemplatesListQuery) -> Result<DcimModuleBayTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/module-bay-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBayTemplatesListResponse::Http200(r#response.json::<PaginatedModuleBayTemplateList>()?)) },
		_ => { Ok(DcimModuleBayTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesBulkUpdateResponse {
	Http200(Vec<ModuleBayTemplate>),
	#[default]
	None
}
/// Put a list of module bay template objects.
pub fn dcim_module_bay_templates_bulk_update(state: &ThanixClient, body: Vec<ModuleBayTemplateRequest>) -> Result<DcimModuleBayTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/module-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBayTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<ModuleBayTemplate>>()?)) },
		_ => { Ok(DcimModuleBayTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesCreateResponse {
	Http201(ModuleBayTemplate),
	#[default]
	None
}
/// Post a list of module bay template objects.
pub fn dcim_module_bay_templates_create(state: &ThanixClient, body: WritableModuleBayTemplateRequest) -> Result<DcimModuleBayTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/module-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimModuleBayTemplatesCreateResponse::Http201(r#response.json::<ModuleBayTemplate>()?)) },
		_ => { Ok(DcimModuleBayTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of module bay template objects.
pub fn dcim_module_bay_templates_bulk_destroy(state: &ThanixClient, body: Vec<ModuleBayTemplateRequest>) -> Result<DcimModuleBayTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/module-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModuleBayTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesBulkPartialUpdateResponse {
	Http200(Vec<ModuleBayTemplate>),
	#[default]
	None
}
/// Patch a list of module bay template objects.
pub fn dcim_module_bay_templates_bulk_partial_update(state: &ThanixClient, body: Vec<ModuleBayTemplateRequest>) -> Result<DcimModuleBayTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/module-bay-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBayTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ModuleBayTemplate>>()?)) },
		_ => { Ok(DcimModuleBayTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesRetrieveResponse {
	Http200(ModuleBayTemplate),
	#[default]
	None
}
/// Get a module bay template object.
pub fn dcim_module_bay_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimModuleBayTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/module-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBayTemplatesRetrieveResponse::Http200(r#response.json::<ModuleBayTemplate>()?)) },
		_ => { Ok(DcimModuleBayTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesUpdateResponse {
	Http200(ModuleBayTemplate),
	#[default]
	None
}
/// Put a module bay template object.
pub fn dcim_module_bay_templates_update(state: &ThanixClient, body: WritableModuleBayTemplateRequest, id: i64) -> Result<DcimModuleBayTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/module-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBayTemplatesUpdateResponse::Http200(r#response.json::<ModuleBayTemplate>()?)) },
		_ => { Ok(DcimModuleBayTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a module bay template object.
pub fn dcim_module_bay_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimModuleBayTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/module-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModuleBayTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBayTemplatesPartialUpdateResponse {
	Http200(ModuleBayTemplate),
	#[default]
	None
}
/// Patch a module bay template object.
pub fn dcim_module_bay_templates_partial_update(state: &ThanixClient, body: PatchedWritableModuleBayTemplateRequest, id: i64) -> Result<DcimModuleBayTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/module-bay-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBayTemplatesPartialUpdateResponse::Http200(r#response.json::<ModuleBayTemplate>()?)) },
		_ => { Ok(DcimModuleBayTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimModuleBaysListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysListResponse {
	Http200(PaginatedModuleBayList),
	#[default]
	None
}
/// Get a list of module bay objects.
pub fn dcim_module_bays_list(state: &ThanixClient, query: DcimModuleBaysListQuery) -> Result<DcimModuleBaysListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/module-bays/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBaysListResponse::Http200(r#response.json::<PaginatedModuleBayList>()?)) },
		_ => { Ok(DcimModuleBaysListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysBulkUpdateResponse {
	Http200(Vec<ModuleBay>),
	#[default]
	None
}
/// Put a list of module bay objects.
pub fn dcim_module_bays_bulk_update(state: &ThanixClient, body: Vec<ModuleBayRequest>) -> Result<DcimModuleBaysBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/module-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBaysBulkUpdateResponse::Http200(r#response.json::<Vec<ModuleBay>>()?)) },
		_ => { Ok(DcimModuleBaysBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysCreateResponse {
	Http201(ModuleBay),
	#[default]
	None
}
/// Post a list of module bay objects.
pub fn dcim_module_bays_create(state: &ThanixClient, body: WritableModuleBayRequest) -> Result<DcimModuleBaysCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/module-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimModuleBaysCreateResponse::Http201(r#response.json::<ModuleBay>()?)) },
		_ => { Ok(DcimModuleBaysCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of module bay objects.
pub fn dcim_module_bays_bulk_destroy(state: &ThanixClient, body: Vec<ModuleBayRequest>) -> Result<DcimModuleBaysBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/module-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModuleBaysBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysBulkPartialUpdateResponse {
	Http200(Vec<ModuleBay>),
	#[default]
	None
}
/// Patch a list of module bay objects.
pub fn dcim_module_bays_bulk_partial_update(state: &ThanixClient, body: Vec<ModuleBayRequest>) -> Result<DcimModuleBaysBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/module-bays/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBaysBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ModuleBay>>()?)) },
		_ => { Ok(DcimModuleBaysBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysRetrieveResponse {
	Http200(ModuleBay),
	#[default]
	None
}
/// Get a module bay object.
pub fn dcim_module_bays_retrieve(state: &ThanixClient, id: i64) -> Result<DcimModuleBaysRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/module-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBaysRetrieveResponse::Http200(r#response.json::<ModuleBay>()?)) },
		_ => { Ok(DcimModuleBaysRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysUpdateResponse {
	Http200(ModuleBay),
	#[default]
	None
}
/// Put a module bay object.
pub fn dcim_module_bays_update(state: &ThanixClient, body: WritableModuleBayRequest, id: i64) -> Result<DcimModuleBaysUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/module-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBaysUpdateResponse::Http200(r#response.json::<ModuleBay>()?)) },
		_ => { Ok(DcimModuleBaysUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a module bay object.
pub fn dcim_module_bays_destroy(state: &ThanixClient, id: i64) -> Result<DcimModuleBaysDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/module-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModuleBaysDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleBaysPartialUpdateResponse {
	Http200(ModuleBay),
	#[default]
	None
}
/// Patch a module bay object.
pub fn dcim_module_bays_partial_update(state: &ThanixClient, body: PatchedWritableModuleBayRequest, id: i64) -> Result<DcimModuleBaysPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/module-bays/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleBaysPartialUpdateResponse::Http200(r#response.json::<ModuleBay>()?)) },
		_ => { Ok(DcimModuleBaysPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimModuleTypesListQuery {
	/// Has console ports
	console_ports: Option<bool>,
	/// Has console server ports
	console_server_ports: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Has interfaces
	interfaces: Option<bool>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	model: Option<Vec<String>>,
	model__empty: Option<bool>,
	model__ic: Option<Vec<String>>,
	model__ie: Option<Vec<String>>,
	model__iew: Option<Vec<String>>,
	model__isw: Option<Vec<String>>,
	model__n: Option<Vec<String>>,
	model__nic: Option<Vec<String>>,
	model__nie: Option<Vec<String>>,
	model__niew: Option<Vec<String>>,
	model__nisw: Option<Vec<String>>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	part_number: Option<Vec<String>>,
	part_number__empty: Option<bool>,
	part_number__ic: Option<Vec<String>>,
	part_number__ie: Option<Vec<String>>,
	part_number__iew: Option<Vec<String>>,
	part_number__isw: Option<Vec<String>>,
	part_number__n: Option<Vec<String>>,
	part_number__nic: Option<Vec<String>>,
	part_number__nie: Option<Vec<String>>,
	part_number__niew: Option<Vec<String>>,
	part_number__nisw: Option<Vec<String>>,
	/// Has pass-through ports
	pass_through_ports: Option<bool>,
	/// Has power outlets
	power_outlets: Option<bool>,
	/// Has power ports
	power_ports: Option<bool>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	weight: Option<Vec<f64>>,
	weight__empty: Option<bool>,
	weight__gt: Option<Vec<f64>>,
	weight__gte: Option<Vec<f64>>,
	weight__lt: Option<Vec<f64>>,
	weight__lte: Option<Vec<f64>>,
	weight__n: Option<Vec<f64>>,
	weight_unit: Option<String>,
	weight_unit__n: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesListResponse {
	Http200(PaginatedModuleTypeList),
	#[default]
	None
}
/// Get a list of module type objects.
pub fn dcim_module_types_list(state: &ThanixClient, query: DcimModuleTypesListQuery) -> Result<DcimModuleTypesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/module-types/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleTypesListResponse::Http200(r#response.json::<PaginatedModuleTypeList>()?)) },
		_ => { Ok(DcimModuleTypesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesBulkUpdateResponse {
	Http200(Vec<ModuleType>),
	#[default]
	None
}
/// Put a list of module type objects.
pub fn dcim_module_types_bulk_update(state: &ThanixClient, body: Vec<ModuleTypeRequest>) -> Result<DcimModuleTypesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/module-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleTypesBulkUpdateResponse::Http200(r#response.json::<Vec<ModuleType>>()?)) },
		_ => { Ok(DcimModuleTypesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesCreateResponse {
	Http201(ModuleType),
	#[default]
	None
}
/// Post a list of module type objects.
pub fn dcim_module_types_create(state: &ThanixClient, body: WritableModuleTypeRequest) -> Result<DcimModuleTypesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/module-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimModuleTypesCreateResponse::Http201(r#response.json::<ModuleType>()?)) },
		_ => { Ok(DcimModuleTypesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of module type objects.
pub fn dcim_module_types_bulk_destroy(state: &ThanixClient, body: Vec<ModuleTypeRequest>) -> Result<DcimModuleTypesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/module-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModuleTypesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesBulkPartialUpdateResponse {
	Http200(Vec<ModuleType>),
	#[default]
	None
}
/// Patch a list of module type objects.
pub fn dcim_module_types_bulk_partial_update(state: &ThanixClient, body: Vec<ModuleTypeRequest>) -> Result<DcimModuleTypesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/module-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleTypesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ModuleType>>()?)) },
		_ => { Ok(DcimModuleTypesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesRetrieveResponse {
	Http200(ModuleType),
	#[default]
	None
}
/// Get a module type object.
pub fn dcim_module_types_retrieve(state: &ThanixClient, id: i64) -> Result<DcimModuleTypesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/module-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleTypesRetrieveResponse::Http200(r#response.json::<ModuleType>()?)) },
		_ => { Ok(DcimModuleTypesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesUpdateResponse {
	Http200(ModuleType),
	#[default]
	None
}
/// Put a module type object.
pub fn dcim_module_types_update(state: &ThanixClient, body: WritableModuleTypeRequest, id: i64) -> Result<DcimModuleTypesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/module-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleTypesUpdateResponse::Http200(r#response.json::<ModuleType>()?)) },
		_ => { Ok(DcimModuleTypesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a module type object.
pub fn dcim_module_types_destroy(state: &ThanixClient, id: i64) -> Result<DcimModuleTypesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/module-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModuleTypesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModuleTypesPartialUpdateResponse {
	Http200(ModuleType),
	#[default]
	None
}
/// Patch a module type object.
pub fn dcim_module_types_partial_update(state: &ThanixClient, body: PatchedWritableModuleTypeRequest, id: i64) -> Result<DcimModuleTypesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/module-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModuleTypesPartialUpdateResponse::Http200(r#response.json::<ModuleType>()?)) },
		_ => { Ok(DcimModuleTypesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimModulesListQuery {
	asset_tag: Option<Vec<String>>,
	asset_tag__empty: Option<bool>,
	asset_tag__ic: Option<Vec<String>>,
	asset_tag__ie: Option<Vec<String>>,
	asset_tag__iew: Option<Vec<String>>,
	asset_tag__isw: Option<Vec<String>>,
	asset_tag__n: Option<Vec<String>>,
	asset_tag__nic: Option<Vec<String>>,
	asset_tag__nie: Option<Vec<String>>,
	asset_tag__niew: Option<Vec<String>>,
	asset_tag__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module Bay (ID)
	module_bay_id: Option<Vec<i64>>,
	/// Module Bay (ID)
	module_bay_id__n: Option<Vec<i64>>,
	/// Module type (model)
	module_type: Option<Vec<String>>,
	/// Module type (model)
	module_type__n: Option<Vec<String>>,
	/// Module type (ID)
	module_type_id: Option<Vec<i64>>,
	/// Module type (ID)
	module_type_id__n: Option<Vec<i64>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	serial: Option<Vec<String>>,
	serial__empty: Option<bool>,
	serial__ic: Option<Vec<String>>,
	serial__ie: Option<Vec<String>>,
	serial__iew: Option<Vec<String>>,
	serial__isw: Option<Vec<String>>,
	serial__n: Option<Vec<String>>,
	serial__nic: Option<Vec<String>>,
	serial__nie: Option<Vec<String>>,
	serial__niew: Option<Vec<String>>,
	serial__nisw: Option<Vec<String>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesListResponse {
	Http200(PaginatedModuleList),
	#[default]
	None
}
/// Get a list of module objects.
pub fn dcim_modules_list(state: &ThanixClient, query: DcimModulesListQuery) -> Result<DcimModulesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/modules/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModulesListResponse::Http200(r#response.json::<PaginatedModuleList>()?)) },
		_ => { Ok(DcimModulesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesBulkUpdateResponse {
	Http200(Vec<Module>),
	#[default]
	None
}
/// Put a list of module objects.
pub fn dcim_modules_bulk_update(state: &ThanixClient, body: Vec<ModuleRequest>) -> Result<DcimModulesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/modules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModulesBulkUpdateResponse::Http200(r#response.json::<Vec<Module>>()?)) },
		_ => { Ok(DcimModulesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesCreateResponse {
	Http201(Module),
	#[default]
	None
}
/// Post a list of module objects.
pub fn dcim_modules_create(state: &ThanixClient, body: WritableModuleRequest) -> Result<DcimModulesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/modules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimModulesCreateResponse::Http201(r#response.json::<Module>()?)) },
		_ => { Ok(DcimModulesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of module objects.
pub fn dcim_modules_bulk_destroy(state: &ThanixClient, body: Vec<ModuleRequest>) -> Result<DcimModulesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/modules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModulesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesBulkPartialUpdateResponse {
	Http200(Vec<Module>),
	#[default]
	None
}
/// Patch a list of module objects.
pub fn dcim_modules_bulk_partial_update(state: &ThanixClient, body: Vec<ModuleRequest>) -> Result<DcimModulesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/modules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModulesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Module>>()?)) },
		_ => { Ok(DcimModulesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesRetrieveResponse {
	Http200(Module),
	#[default]
	None
}
/// Get a module object.
pub fn dcim_modules_retrieve(state: &ThanixClient, id: i64) -> Result<DcimModulesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/modules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModulesRetrieveResponse::Http200(r#response.json::<Module>()?)) },
		_ => { Ok(DcimModulesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesUpdateResponse {
	Http200(Module),
	#[default]
	None
}
/// Put a module object.
pub fn dcim_modules_update(state: &ThanixClient, body: WritableModuleRequest, id: i64) -> Result<DcimModulesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/modules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModulesUpdateResponse::Http200(r#response.json::<Module>()?)) },
		_ => { Ok(DcimModulesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a module object.
pub fn dcim_modules_destroy(state: &ThanixClient, id: i64) -> Result<DcimModulesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/modules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimModulesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimModulesPartialUpdateResponse {
	Http200(Module),
	#[default]
	None
}
/// Patch a module object.
pub fn dcim_modules_partial_update(state: &ThanixClient, body: PatchedWritableModuleRequest, id: i64) -> Result<DcimModulesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/modules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimModulesPartialUpdateResponse::Http200(r#response.json::<Module>()?)) },
		_ => { Ok(DcimModulesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPlatformsListQuery {
	/// Config template (ID)
	config_template_id: Option<Vec<i64>>,
	/// Config template (ID)
	config_template_id__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Manufacturer (slug)
	manufacturer: Option<Vec<String>>,
	/// Manufacturer (slug)
	manufacturer__n: Option<Vec<String>>,
	/// Manufacturer (ID)
	manufacturer_id: Option<Vec<i64>>,
	/// Manufacturer (ID)
	manufacturer_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsListResponse {
	Http200(PaginatedPlatformList),
	#[default]
	None
}
/// Get a list of platform objects.
pub fn dcim_platforms_list(state: &ThanixClient, query: DcimPlatformsListQuery) -> Result<DcimPlatformsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/platforms/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPlatformsListResponse::Http200(r#response.json::<PaginatedPlatformList>()?)) },
		_ => { Ok(DcimPlatformsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsBulkUpdateResponse {
	Http200(Vec<Platform>),
	#[default]
	None
}
/// Put a list of platform objects.
pub fn dcim_platforms_bulk_update(state: &ThanixClient, body: Vec<PlatformRequest>) -> Result<DcimPlatformsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/platforms/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPlatformsBulkUpdateResponse::Http200(r#response.json::<Vec<Platform>>()?)) },
		_ => { Ok(DcimPlatformsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsCreateResponse {
	Http201(Platform),
	#[default]
	None
}
/// Post a list of platform objects.
pub fn dcim_platforms_create(state: &ThanixClient, body: WritablePlatformRequest) -> Result<DcimPlatformsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/platforms/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPlatformsCreateResponse::Http201(r#response.json::<Platform>()?)) },
		_ => { Ok(DcimPlatformsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of platform objects.
pub fn dcim_platforms_bulk_destroy(state: &ThanixClient, body: Vec<PlatformRequest>) -> Result<DcimPlatformsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/platforms/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPlatformsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsBulkPartialUpdateResponse {
	Http200(Vec<Platform>),
	#[default]
	None
}
/// Patch a list of platform objects.
pub fn dcim_platforms_bulk_partial_update(state: &ThanixClient, body: Vec<PlatformRequest>) -> Result<DcimPlatformsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/platforms/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPlatformsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Platform>>()?)) },
		_ => { Ok(DcimPlatformsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsRetrieveResponse {
	Http200(Platform),
	#[default]
	None
}
/// Get a platform object.
pub fn dcim_platforms_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPlatformsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/platforms/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPlatformsRetrieveResponse::Http200(r#response.json::<Platform>()?)) },
		_ => { Ok(DcimPlatformsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsUpdateResponse {
	Http200(Platform),
	#[default]
	None
}
/// Put a platform object.
pub fn dcim_platforms_update(state: &ThanixClient, body: WritablePlatformRequest, id: i64) -> Result<DcimPlatformsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/platforms/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPlatformsUpdateResponse::Http200(r#response.json::<Platform>()?)) },
		_ => { Ok(DcimPlatformsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a platform object.
pub fn dcim_platforms_destroy(state: &ThanixClient, id: i64) -> Result<DcimPlatformsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/platforms/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPlatformsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPlatformsPartialUpdateResponse {
	Http200(Platform),
	#[default]
	None
}
/// Patch a platform object.
pub fn dcim_platforms_partial_update(state: &ThanixClient, body: PatchedWritablePlatformRequest, id: i64) -> Result<DcimPlatformsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/platforms/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPlatformsPartialUpdateResponse::Http200(r#response.json::<Platform>()?)) },
		_ => { Ok(DcimPlatformsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPowerFeedsListQuery {
	amperage: Option<Vec<i64>>,
	amperage__empty: Option<bool>,
	amperage__gt: Option<Vec<i64>>,
	amperage__gte: Option<Vec<i64>>,
	amperage__lt: Option<Vec<i64>>,
	amperage__lte: Option<Vec<i64>>,
	amperage__n: Option<Vec<i64>>,
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	connected: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	max_utilization: Option<Vec<i64>>,
	max_utilization__empty: Option<bool>,
	max_utilization__gt: Option<Vec<i64>>,
	max_utilization__gte: Option<Vec<i64>>,
	max_utilization__lt: Option<Vec<i64>>,
	max_utilization__lte: Option<Vec<i64>>,
	max_utilization__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	phase: Option<String>,
	phase__n: Option<String>,
	/// Power panel (ID)
	power_panel_id: Option<Vec<i64>>,
	/// Power panel (ID)
	power_panel_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	supply: Option<String>,
	supply__n: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	r#type: Option<String>,
	type__n: Option<String>,
	updated_by_request: Option<String>,
	voltage: Option<Vec<i64>>,
	voltage__empty: Option<bool>,
	voltage__gt: Option<Vec<i64>>,
	voltage__gte: Option<Vec<i64>>,
	voltage__lt: Option<Vec<i64>>,
	voltage__lte: Option<Vec<i64>>,
	voltage__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsListResponse {
	Http200(PaginatedPowerFeedList),
	#[default]
	None
}
/// Get a list of power feed objects.
pub fn dcim_power_feeds_list(state: &ThanixClient, query: DcimPowerFeedsListQuery) -> Result<DcimPowerFeedsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-feeds/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsListResponse::Http200(r#response.json::<PaginatedPowerFeedList>()?)) },
		_ => { Ok(DcimPowerFeedsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsBulkUpdateResponse {
	Http200(Vec<PowerFeed>),
	#[default]
	None
}
/// Put a list of power feed objects.
pub fn dcim_power_feeds_bulk_update(state: &ThanixClient, body: Vec<PowerFeedRequest>) -> Result<DcimPowerFeedsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-feeds/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsBulkUpdateResponse::Http200(r#response.json::<Vec<PowerFeed>>()?)) },
		_ => { Ok(DcimPowerFeedsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsCreateResponse {
	Http201(PowerFeed),
	#[default]
	None
}
/// Post a list of power feed objects.
pub fn dcim_power_feeds_create(state: &ThanixClient, body: WritablePowerFeedRequest) -> Result<DcimPowerFeedsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/power-feeds/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPowerFeedsCreateResponse::Http201(r#response.json::<PowerFeed>()?)) },
		_ => { Ok(DcimPowerFeedsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of power feed objects.
pub fn dcim_power_feeds_bulk_destroy(state: &ThanixClient, body: Vec<PowerFeedRequest>) -> Result<DcimPowerFeedsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-feeds/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerFeedsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsBulkPartialUpdateResponse {
	Http200(Vec<PowerFeed>),
	#[default]
	None
}
/// Patch a list of power feed objects.
pub fn dcim_power_feeds_bulk_partial_update(state: &ThanixClient, body: Vec<PowerFeedRequest>) -> Result<DcimPowerFeedsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-feeds/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<PowerFeed>>()?)) },
		_ => { Ok(DcimPowerFeedsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsRetrieveResponse {
	Http200(PowerFeed),
	#[default]
	None
}
/// Get a power feed object.
pub fn dcim_power_feeds_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerFeedsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-feeds/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsRetrieveResponse::Http200(r#response.json::<PowerFeed>()?)) },
		_ => { Ok(DcimPowerFeedsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsUpdateResponse {
	Http200(PowerFeed),
	#[default]
	None
}
/// Put a power feed object.
pub fn dcim_power_feeds_update(state: &ThanixClient, body: WritablePowerFeedRequest, id: i64) -> Result<DcimPowerFeedsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-feeds/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsUpdateResponse::Http200(r#response.json::<PowerFeed>()?)) },
		_ => { Ok(DcimPowerFeedsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a power feed object.
pub fn dcim_power_feeds_destroy(state: &ThanixClient, id: i64) -> Result<DcimPowerFeedsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-feeds/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerFeedsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsPartialUpdateResponse {
	Http200(PowerFeed),
	#[default]
	None
}
/// Patch a power feed object.
pub fn dcim_power_feeds_partial_update(state: &ThanixClient, body: PatchedWritablePowerFeedRequest, id: i64) -> Result<DcimPowerFeedsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-feeds/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsPartialUpdateResponse::Http200(r#response.json::<PowerFeed>()?)) },
		_ => { Ok(DcimPowerFeedsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerFeedsTraceRetrieveResponse {
	Http200(PowerFeed),
	#[default]
	None
}
/// Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
pub fn dcim_power_feeds_trace_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerFeedsTraceRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-feeds/{id}/trace/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerFeedsTraceRetrieveResponse::Http200(r#response.json::<PowerFeed>()?)) },
		_ => { Ok(DcimPowerFeedsTraceRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPowerOutletTemplatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	/// Phase (for three-phase feeds)
	feed_leg: Option<Vec<String>>,
	/// Phase (for three-phase feeds)
	feed_leg__n: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	r#type: Option<String>,
	type__n: Option<String>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesListResponse {
	Http200(PaginatedPowerOutletTemplateList),
	#[default]
	None
}
/// Get a list of power outlet template objects.
pub fn dcim_power_outlet_templates_list(state: &ThanixClient, query: DcimPowerOutletTemplatesListQuery) -> Result<DcimPowerOutletTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-outlet-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletTemplatesListResponse::Http200(r#response.json::<PaginatedPowerOutletTemplateList>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesBulkUpdateResponse {
	Http200(Vec<PowerOutletTemplate>),
	#[default]
	None
}
/// Put a list of power outlet template objects.
pub fn dcim_power_outlet_templates_bulk_update(state: &ThanixClient, body: Vec<PowerOutletTemplateRequest>) -> Result<DcimPowerOutletTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-outlet-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<PowerOutletTemplate>>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesCreateResponse {
	Http201(PowerOutletTemplate),
	#[default]
	None
}
/// Post a list of power outlet template objects.
pub fn dcim_power_outlet_templates_create(state: &ThanixClient, body: WritablePowerOutletTemplateRequest) -> Result<DcimPowerOutletTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/power-outlet-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPowerOutletTemplatesCreateResponse::Http201(r#response.json::<PowerOutletTemplate>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of power outlet template objects.
pub fn dcim_power_outlet_templates_bulk_destroy(state: &ThanixClient, body: Vec<PowerOutletTemplateRequest>) -> Result<DcimPowerOutletTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-outlet-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerOutletTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesBulkPartialUpdateResponse {
	Http200(Vec<PowerOutletTemplate>),
	#[default]
	None
}
/// Patch a list of power outlet template objects.
pub fn dcim_power_outlet_templates_bulk_partial_update(state: &ThanixClient, body: Vec<PowerOutletTemplateRequest>) -> Result<DcimPowerOutletTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-outlet-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<PowerOutletTemplate>>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesRetrieveResponse {
	Http200(PowerOutletTemplate),
	#[default]
	None
}
/// Get a power outlet template object.
pub fn dcim_power_outlet_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerOutletTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-outlet-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletTemplatesRetrieveResponse::Http200(r#response.json::<PowerOutletTemplate>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesUpdateResponse {
	Http200(PowerOutletTemplate),
	#[default]
	None
}
/// Put a power outlet template object.
pub fn dcim_power_outlet_templates_update(state: &ThanixClient, body: WritablePowerOutletTemplateRequest, id: i64) -> Result<DcimPowerOutletTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-outlet-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletTemplatesUpdateResponse::Http200(r#response.json::<PowerOutletTemplate>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a power outlet template object.
pub fn dcim_power_outlet_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimPowerOutletTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-outlet-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerOutletTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletTemplatesPartialUpdateResponse {
	Http200(PowerOutletTemplate),
	#[default]
	None
}
/// Patch a power outlet template object.
pub fn dcim_power_outlet_templates_partial_update(state: &ThanixClient, body: PatchedWritablePowerOutletTemplateRequest, id: i64) -> Result<DcimPowerOutletTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-outlet-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletTemplatesPartialUpdateResponse::Http200(r#response.json::<PowerOutletTemplate>()?)) },
		_ => { Ok(DcimPowerOutletTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPowerOutletsListQuery {
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	connected: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	/// Phase (for three-phase feeds)
	feed_leg: Option<Vec<String>>,
	/// Phase (for three-phase feeds)
	feed_leg__n: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Physical port type
	r#type: Option<Vec<String>>,
	/// Physical port type
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsListResponse {
	Http200(PaginatedPowerOutletList),
	#[default]
	None
}
/// Get a list of power outlet objects.
pub fn dcim_power_outlets_list(state: &ThanixClient, query: DcimPowerOutletsListQuery) -> Result<DcimPowerOutletsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-outlets/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsListResponse::Http200(r#response.json::<PaginatedPowerOutletList>()?)) },
		_ => { Ok(DcimPowerOutletsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsBulkUpdateResponse {
	Http200(Vec<PowerOutlet>),
	#[default]
	None
}
/// Put a list of power outlet objects.
pub fn dcim_power_outlets_bulk_update(state: &ThanixClient, body: Vec<PowerOutletRequest>) -> Result<DcimPowerOutletsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-outlets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsBulkUpdateResponse::Http200(r#response.json::<Vec<PowerOutlet>>()?)) },
		_ => { Ok(DcimPowerOutletsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsCreateResponse {
	Http201(PowerOutlet),
	#[default]
	None
}
/// Post a list of power outlet objects.
pub fn dcim_power_outlets_create(state: &ThanixClient, body: WritablePowerOutletRequest) -> Result<DcimPowerOutletsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/power-outlets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPowerOutletsCreateResponse::Http201(r#response.json::<PowerOutlet>()?)) },
		_ => { Ok(DcimPowerOutletsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of power outlet objects.
pub fn dcim_power_outlets_bulk_destroy(state: &ThanixClient, body: Vec<PowerOutletRequest>) -> Result<DcimPowerOutletsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-outlets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerOutletsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsBulkPartialUpdateResponse {
	Http200(Vec<PowerOutlet>),
	#[default]
	None
}
/// Patch a list of power outlet objects.
pub fn dcim_power_outlets_bulk_partial_update(state: &ThanixClient, body: Vec<PowerOutletRequest>) -> Result<DcimPowerOutletsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-outlets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<PowerOutlet>>()?)) },
		_ => { Ok(DcimPowerOutletsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsRetrieveResponse {
	Http200(PowerOutlet),
	#[default]
	None
}
/// Get a power outlet object.
pub fn dcim_power_outlets_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerOutletsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-outlets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsRetrieveResponse::Http200(r#response.json::<PowerOutlet>()?)) },
		_ => { Ok(DcimPowerOutletsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsUpdateResponse {
	Http200(PowerOutlet),
	#[default]
	None
}
/// Put a power outlet object.
pub fn dcim_power_outlets_update(state: &ThanixClient, body: WritablePowerOutletRequest, id: i64) -> Result<DcimPowerOutletsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-outlets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsUpdateResponse::Http200(r#response.json::<PowerOutlet>()?)) },
		_ => { Ok(DcimPowerOutletsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a power outlet object.
pub fn dcim_power_outlets_destroy(state: &ThanixClient, id: i64) -> Result<DcimPowerOutletsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-outlets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerOutletsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsPartialUpdateResponse {
	Http200(PowerOutlet),
	#[default]
	None
}
/// Patch a power outlet object.
pub fn dcim_power_outlets_partial_update(state: &ThanixClient, body: PatchedWritablePowerOutletRequest, id: i64) -> Result<DcimPowerOutletsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-outlets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsPartialUpdateResponse::Http200(r#response.json::<PowerOutlet>()?)) },
		_ => { Ok(DcimPowerOutletsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerOutletsTraceRetrieveResponse {
	Http200(PowerOutlet),
	#[default]
	None
}
/// Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
pub fn dcim_power_outlets_trace_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerOutletsTraceRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-outlets/{id}/trace/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerOutletsTraceRetrieveResponse::Http200(r#response.json::<PowerOutlet>()?)) },
		_ => { Ok(DcimPowerOutletsTraceRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPowerPanelsListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsListResponse {
	Http200(PaginatedPowerPanelList),
	#[default]
	None
}
/// Get a list of power panel objects.
pub fn dcim_power_panels_list(state: &ThanixClient, query: DcimPowerPanelsListQuery) -> Result<DcimPowerPanelsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-panels/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPanelsListResponse::Http200(r#response.json::<PaginatedPowerPanelList>()?)) },
		_ => { Ok(DcimPowerPanelsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsBulkUpdateResponse {
	Http200(Vec<PowerPanel>),
	#[default]
	None
}
/// Put a list of power panel objects.
pub fn dcim_power_panels_bulk_update(state: &ThanixClient, body: Vec<PowerPanelRequest>) -> Result<DcimPowerPanelsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-panels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPanelsBulkUpdateResponse::Http200(r#response.json::<Vec<PowerPanel>>()?)) },
		_ => { Ok(DcimPowerPanelsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsCreateResponse {
	Http201(PowerPanel),
	#[default]
	None
}
/// Post a list of power panel objects.
pub fn dcim_power_panels_create(state: &ThanixClient, body: WritablePowerPanelRequest) -> Result<DcimPowerPanelsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/power-panels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPowerPanelsCreateResponse::Http201(r#response.json::<PowerPanel>()?)) },
		_ => { Ok(DcimPowerPanelsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of power panel objects.
pub fn dcim_power_panels_bulk_destroy(state: &ThanixClient, body: Vec<PowerPanelRequest>) -> Result<DcimPowerPanelsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-panels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerPanelsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsBulkPartialUpdateResponse {
	Http200(Vec<PowerPanel>),
	#[default]
	None
}
/// Patch a list of power panel objects.
pub fn dcim_power_panels_bulk_partial_update(state: &ThanixClient, body: Vec<PowerPanelRequest>) -> Result<DcimPowerPanelsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-panels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPanelsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<PowerPanel>>()?)) },
		_ => { Ok(DcimPowerPanelsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsRetrieveResponse {
	Http200(PowerPanel),
	#[default]
	None
}
/// Get a power panel object.
pub fn dcim_power_panels_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerPanelsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-panels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPanelsRetrieveResponse::Http200(r#response.json::<PowerPanel>()?)) },
		_ => { Ok(DcimPowerPanelsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsUpdateResponse {
	Http200(PowerPanel),
	#[default]
	None
}
/// Put a power panel object.
pub fn dcim_power_panels_update(state: &ThanixClient, body: WritablePowerPanelRequest, id: i64) -> Result<DcimPowerPanelsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-panels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPanelsUpdateResponse::Http200(r#response.json::<PowerPanel>()?)) },
		_ => { Ok(DcimPowerPanelsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a power panel object.
pub fn dcim_power_panels_destroy(state: &ThanixClient, id: i64) -> Result<DcimPowerPanelsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-panels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerPanelsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPanelsPartialUpdateResponse {
	Http200(PowerPanel),
	#[default]
	None
}
/// Patch a power panel object.
pub fn dcim_power_panels_partial_update(state: &ThanixClient, body: PatchedWritablePowerPanelRequest, id: i64) -> Result<DcimPowerPanelsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-panels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPanelsPartialUpdateResponse::Http200(r#response.json::<PowerPanel>()?)) },
		_ => { Ok(DcimPowerPanelsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPowerPortTemplatesListQuery {
	allocated_draw: Option<Vec<i64>>,
	allocated_draw__empty: Option<bool>,
	allocated_draw__gt: Option<Vec<i64>>,
	allocated_draw__gte: Option<Vec<i64>>,
	allocated_draw__lt: Option<Vec<i64>>,
	allocated_draw__lte: Option<Vec<i64>>,
	allocated_draw__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	maximum_draw: Option<Vec<i64>>,
	maximum_draw__empty: Option<bool>,
	maximum_draw__gt: Option<Vec<i64>>,
	maximum_draw__gte: Option<Vec<i64>>,
	maximum_draw__lt: Option<Vec<i64>>,
	maximum_draw__lte: Option<Vec<i64>>,
	maximum_draw__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	r#type: Option<String>,
	type__n: Option<String>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesListResponse {
	Http200(PaginatedPowerPortTemplateList),
	#[default]
	None
}
/// Get a list of power port template objects.
pub fn dcim_power_port_templates_list(state: &ThanixClient, query: DcimPowerPortTemplatesListQuery) -> Result<DcimPowerPortTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-port-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortTemplatesListResponse::Http200(r#response.json::<PaginatedPowerPortTemplateList>()?)) },
		_ => { Ok(DcimPowerPortTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesBulkUpdateResponse {
	Http200(Vec<PowerPortTemplate>),
	#[default]
	None
}
/// Put a list of power port template objects.
pub fn dcim_power_port_templates_bulk_update(state: &ThanixClient, body: Vec<PowerPortTemplateRequest>) -> Result<DcimPowerPortTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<PowerPortTemplate>>()?)) },
		_ => { Ok(DcimPowerPortTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesCreateResponse {
	Http201(PowerPortTemplate),
	#[default]
	None
}
/// Post a list of power port template objects.
pub fn dcim_power_port_templates_create(state: &ThanixClient, body: WritablePowerPortTemplateRequest) -> Result<DcimPowerPortTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/power-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPowerPortTemplatesCreateResponse::Http201(r#response.json::<PowerPortTemplate>()?)) },
		_ => { Ok(DcimPowerPortTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of power port template objects.
pub fn dcim_power_port_templates_bulk_destroy(state: &ThanixClient, body: Vec<PowerPortTemplateRequest>) -> Result<DcimPowerPortTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerPortTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesBulkPartialUpdateResponse {
	Http200(Vec<PowerPortTemplate>),
	#[default]
	None
}
/// Patch a list of power port template objects.
pub fn dcim_power_port_templates_bulk_partial_update(state: &ThanixClient, body: Vec<PowerPortTemplateRequest>) -> Result<DcimPowerPortTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<PowerPortTemplate>>()?)) },
		_ => { Ok(DcimPowerPortTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesRetrieveResponse {
	Http200(PowerPortTemplate),
	#[default]
	None
}
/// Get a power port template object.
pub fn dcim_power_port_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerPortTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortTemplatesRetrieveResponse::Http200(r#response.json::<PowerPortTemplate>()?)) },
		_ => { Ok(DcimPowerPortTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesUpdateResponse {
	Http200(PowerPortTemplate),
	#[default]
	None
}
/// Put a power port template object.
pub fn dcim_power_port_templates_update(state: &ThanixClient, body: WritablePowerPortTemplateRequest, id: i64) -> Result<DcimPowerPortTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortTemplatesUpdateResponse::Http200(r#response.json::<PowerPortTemplate>()?)) },
		_ => { Ok(DcimPowerPortTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a power port template object.
pub fn dcim_power_port_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimPowerPortTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerPortTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortTemplatesPartialUpdateResponse {
	Http200(PowerPortTemplate),
	#[default]
	None
}
/// Patch a power port template object.
pub fn dcim_power_port_templates_partial_update(state: &ThanixClient, body: PatchedWritablePowerPortTemplateRequest, id: i64) -> Result<DcimPowerPortTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortTemplatesPartialUpdateResponse::Http200(r#response.json::<PowerPortTemplate>()?)) },
		_ => { Ok(DcimPowerPortTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimPowerPortsListQuery {
	allocated_draw: Option<Vec<i64>>,
	allocated_draw__empty: Option<bool>,
	allocated_draw__gt: Option<Vec<i64>>,
	allocated_draw__gte: Option<Vec<i64>>,
	allocated_draw__lt: Option<Vec<i64>>,
	allocated_draw__lte: Option<Vec<i64>>,
	allocated_draw__n: Option<Vec<i64>>,
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	connected: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	maximum_draw: Option<Vec<i64>>,
	maximum_draw__empty: Option<bool>,
	maximum_draw__gt: Option<Vec<i64>>,
	maximum_draw__gte: Option<Vec<i64>>,
	maximum_draw__lt: Option<Vec<i64>>,
	maximum_draw__lte: Option<Vec<i64>>,
	maximum_draw__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Physical port type
	r#type: Option<Vec<String>>,
	/// Physical port type
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsListResponse {
	Http200(PaginatedPowerPortList),
	#[default]
	None
}
/// Get a list of power port objects.
pub fn dcim_power_ports_list(state: &ThanixClient, query: DcimPowerPortsListQuery) -> Result<DcimPowerPortsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-ports/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsListResponse::Http200(r#response.json::<PaginatedPowerPortList>()?)) },
		_ => { Ok(DcimPowerPortsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsBulkUpdateResponse {
	Http200(Vec<PowerPort>),
	#[default]
	None
}
/// Put a list of power port objects.
pub fn dcim_power_ports_bulk_update(state: &ThanixClient, body: Vec<PowerPortRequest>) -> Result<DcimPowerPortsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsBulkUpdateResponse::Http200(r#response.json::<Vec<PowerPort>>()?)) },
		_ => { Ok(DcimPowerPortsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsCreateResponse {
	Http201(PowerPort),
	#[default]
	None
}
/// Post a list of power port objects.
pub fn dcim_power_ports_create(state: &ThanixClient, body: WritablePowerPortRequest) -> Result<DcimPowerPortsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/power-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimPowerPortsCreateResponse::Http201(r#response.json::<PowerPort>()?)) },
		_ => { Ok(DcimPowerPortsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of power port objects.
pub fn dcim_power_ports_bulk_destroy(state: &ThanixClient, body: Vec<PowerPortRequest>) -> Result<DcimPowerPortsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerPortsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsBulkPartialUpdateResponse {
	Http200(Vec<PowerPort>),
	#[default]
	None
}
/// Patch a list of power port objects.
pub fn dcim_power_ports_bulk_partial_update(state: &ThanixClient, body: Vec<PowerPortRequest>) -> Result<DcimPowerPortsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<PowerPort>>()?)) },
		_ => { Ok(DcimPowerPortsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsRetrieveResponse {
	Http200(PowerPort),
	#[default]
	None
}
/// Get a power port object.
pub fn dcim_power_ports_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerPortsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsRetrieveResponse::Http200(r#response.json::<PowerPort>()?)) },
		_ => { Ok(DcimPowerPortsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsUpdateResponse {
	Http200(PowerPort),
	#[default]
	None
}
/// Put a power port object.
pub fn dcim_power_ports_update(state: &ThanixClient, body: WritablePowerPortRequest, id: i64) -> Result<DcimPowerPortsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/power-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsUpdateResponse::Http200(r#response.json::<PowerPort>()?)) },
		_ => { Ok(DcimPowerPortsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a power port object.
pub fn dcim_power_ports_destroy(state: &ThanixClient, id: i64) -> Result<DcimPowerPortsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/power-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimPowerPortsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsPartialUpdateResponse {
	Http200(PowerPort),
	#[default]
	None
}
/// Patch a power port object.
pub fn dcim_power_ports_partial_update(state: &ThanixClient, body: PatchedWritablePowerPortRequest, id: i64) -> Result<DcimPowerPortsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/power-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsPartialUpdateResponse::Http200(r#response.json::<PowerPort>()?)) },
		_ => { Ok(DcimPowerPortsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimPowerPortsTraceRetrieveResponse {
	Http200(PowerPort),
	#[default]
	None
}
/// Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
pub fn dcim_power_ports_trace_retrieve(state: &ThanixClient, id: i64) -> Result<DcimPowerPortsTraceRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/power-ports/{id}/trace/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimPowerPortsTraceRetrieveResponse::Http200(r#response.json::<PowerPort>()?)) },
		_ => { Ok(DcimPowerPortsTraceRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimRackReservationsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<i64>>,
	/// Location (slug)
	location__n: Option<Vec<i64>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	/// User (name)
	user: Option<Vec<String>>,
	/// User (name)
	user__n: Option<Vec<String>>,
	/// User (ID)
	user_id: Option<Vec<i64>>,
	/// User (ID)
	user_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsListResponse {
	Http200(PaginatedRackReservationList),
	#[default]
	None
}
/// Get a list of rack reservation objects.
pub fn dcim_rack_reservations_list(state: &ThanixClient, query: DcimRackReservationsListQuery) -> Result<DcimRackReservationsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rack-reservations/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackReservationsListResponse::Http200(r#response.json::<PaginatedRackReservationList>()?)) },
		_ => { Ok(DcimRackReservationsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsBulkUpdateResponse {
	Http200(Vec<RackReservation>),
	#[default]
	None
}
/// Put a list of rack reservation objects.
pub fn dcim_rack_reservations_bulk_update(state: &ThanixClient, body: Vec<RackReservationRequest>) -> Result<DcimRackReservationsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rack-reservations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackReservationsBulkUpdateResponse::Http200(r#response.json::<Vec<RackReservation>>()?)) },
		_ => { Ok(DcimRackReservationsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsCreateResponse {
	Http201(RackReservation),
	#[default]
	None
}
/// Post a list of rack reservation objects.
pub fn dcim_rack_reservations_create(state: &ThanixClient, body: WritableRackReservationRequest) -> Result<DcimRackReservationsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/rack-reservations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimRackReservationsCreateResponse::Http201(r#response.json::<RackReservation>()?)) },
		_ => { Ok(DcimRackReservationsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of rack reservation objects.
pub fn dcim_rack_reservations_bulk_destroy(state: &ThanixClient, body: Vec<RackReservationRequest>) -> Result<DcimRackReservationsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rack-reservations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRackReservationsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsBulkPartialUpdateResponse {
	Http200(Vec<RackReservation>),
	#[default]
	None
}
/// Patch a list of rack reservation objects.
pub fn dcim_rack_reservations_bulk_partial_update(state: &ThanixClient, body: Vec<RackReservationRequest>) -> Result<DcimRackReservationsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rack-reservations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackReservationsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<RackReservation>>()?)) },
		_ => { Ok(DcimRackReservationsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsRetrieveResponse {
	Http200(RackReservation),
	#[default]
	None
}
/// Get a rack reservation object.
pub fn dcim_rack_reservations_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRackReservationsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rack-reservations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackReservationsRetrieveResponse::Http200(r#response.json::<RackReservation>()?)) },
		_ => { Ok(DcimRackReservationsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsUpdateResponse {
	Http200(RackReservation),
	#[default]
	None
}
/// Put a rack reservation object.
pub fn dcim_rack_reservations_update(state: &ThanixClient, body: WritableRackReservationRequest, id: i64) -> Result<DcimRackReservationsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rack-reservations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackReservationsUpdateResponse::Http200(r#response.json::<RackReservation>()?)) },
		_ => { Ok(DcimRackReservationsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a rack reservation object.
pub fn dcim_rack_reservations_destroy(state: &ThanixClient, id: i64) -> Result<DcimRackReservationsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rack-reservations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRackReservationsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackReservationsPartialUpdateResponse {
	Http200(RackReservation),
	#[default]
	None
}
/// Patch a rack reservation object.
pub fn dcim_rack_reservations_partial_update(state: &ThanixClient, body: PatchedWritableRackReservationRequest, id: i64) -> Result<DcimRackReservationsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rack-reservations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackReservationsPartialUpdateResponse::Http200(r#response.json::<RackReservation>()?)) },
		_ => { Ok(DcimRackReservationsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimRackRolesListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesListResponse {
	Http200(PaginatedRackRoleList),
	#[default]
	None
}
/// Get a list of rack role objects.
pub fn dcim_rack_roles_list(state: &ThanixClient, query: DcimRackRolesListQuery) -> Result<DcimRackRolesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rack-roles/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackRolesListResponse::Http200(r#response.json::<PaginatedRackRoleList>()?)) },
		_ => { Ok(DcimRackRolesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesBulkUpdateResponse {
	Http200(Vec<RackRole>),
	#[default]
	None
}
/// Put a list of rack role objects.
pub fn dcim_rack_roles_bulk_update(state: &ThanixClient, body: Vec<RackRoleRequest>) -> Result<DcimRackRolesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rack-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackRolesBulkUpdateResponse::Http200(r#response.json::<Vec<RackRole>>()?)) },
		_ => { Ok(DcimRackRolesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesCreateResponse {
	Http201(RackRole),
	#[default]
	None
}
/// Post a list of rack role objects.
pub fn dcim_rack_roles_create(state: &ThanixClient, body: RackRoleRequest) -> Result<DcimRackRolesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/rack-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimRackRolesCreateResponse::Http201(r#response.json::<RackRole>()?)) },
		_ => { Ok(DcimRackRolesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of rack role objects.
pub fn dcim_rack_roles_bulk_destroy(state: &ThanixClient, body: Vec<RackRoleRequest>) -> Result<DcimRackRolesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rack-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRackRolesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesBulkPartialUpdateResponse {
	Http200(Vec<RackRole>),
	#[default]
	None
}
/// Patch a list of rack role objects.
pub fn dcim_rack_roles_bulk_partial_update(state: &ThanixClient, body: Vec<RackRoleRequest>) -> Result<DcimRackRolesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rack-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackRolesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<RackRole>>()?)) },
		_ => { Ok(DcimRackRolesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesRetrieveResponse {
	Http200(RackRole),
	#[default]
	None
}
/// Get a rack role object.
pub fn dcim_rack_roles_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRackRolesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rack-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackRolesRetrieveResponse::Http200(r#response.json::<RackRole>()?)) },
		_ => { Ok(DcimRackRolesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesUpdateResponse {
	Http200(RackRole),
	#[default]
	None
}
/// Put a rack role object.
pub fn dcim_rack_roles_update(state: &ThanixClient, body: RackRoleRequest, id: i64) -> Result<DcimRackRolesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rack-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackRolesUpdateResponse::Http200(r#response.json::<RackRole>()?)) },
		_ => { Ok(DcimRackRolesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a rack role object.
pub fn dcim_rack_roles_destroy(state: &ThanixClient, id: i64) -> Result<DcimRackRolesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rack-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRackRolesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRackRolesPartialUpdateResponse {
	Http200(RackRole),
	#[default]
	None
}
/// Patch a rack role object.
pub fn dcim_rack_roles_partial_update(state: &ThanixClient, body: PatchedRackRoleRequest, id: i64) -> Result<DcimRackRolesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rack-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRackRolesPartialUpdateResponse::Http200(r#response.json::<RackRole>()?)) },
		_ => { Ok(DcimRackRolesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimRacksListQuery {
	asset_tag: Option<Vec<String>>,
	asset_tag__empty: Option<bool>,
	asset_tag__ic: Option<Vec<String>>,
	asset_tag__ie: Option<Vec<String>>,
	asset_tag__iew: Option<Vec<String>>,
	asset_tag__isw: Option<Vec<String>>,
	asset_tag__n: Option<Vec<String>>,
	asset_tag__nic: Option<Vec<String>>,
	asset_tag__nie: Option<Vec<String>>,
	asset_tag__niew: Option<Vec<String>>,
	asset_tag__nisw: Option<Vec<String>>,
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	desc_units: Option<bool>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	facility_id: Option<Vec<String>>,
	facility_id__empty: Option<bool>,
	facility_id__ic: Option<Vec<String>>,
	facility_id__ie: Option<Vec<String>>,
	facility_id__iew: Option<Vec<String>>,
	facility_id__isw: Option<Vec<String>>,
	facility_id__n: Option<Vec<String>>,
	facility_id__nic: Option<Vec<String>>,
	facility_id__nie: Option<Vec<String>>,
	facility_id__niew: Option<Vec<String>>,
	facility_id__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<i64>>,
	/// Location (slug)
	location__n: Option<Vec<i64>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	max_weight: Option<Vec<i64>>,
	max_weight__empty: Option<bool>,
	max_weight__gt: Option<Vec<i64>>,
	max_weight__gte: Option<Vec<i64>>,
	max_weight__lt: Option<Vec<i64>>,
	max_weight__lte: Option<Vec<i64>>,
	max_weight__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	mounting_depth: Option<Vec<i64>>,
	mounting_depth__empty: Option<bool>,
	mounting_depth__gt: Option<Vec<i64>>,
	mounting_depth__gte: Option<Vec<i64>>,
	mounting_depth__lt: Option<Vec<i64>>,
	mounting_depth__lte: Option<Vec<i64>>,
	mounting_depth__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	outer_depth: Option<Vec<i64>>,
	outer_depth__empty: Option<bool>,
	outer_depth__gt: Option<Vec<i64>>,
	outer_depth__gte: Option<Vec<i64>>,
	outer_depth__lt: Option<Vec<i64>>,
	outer_depth__lte: Option<Vec<i64>>,
	outer_depth__n: Option<Vec<i64>>,
	outer_unit: Option<String>,
	outer_unit__n: Option<String>,
	outer_width: Option<Vec<i64>>,
	outer_width__empty: Option<bool>,
	outer_width__gt: Option<Vec<i64>>,
	outer_width__gte: Option<Vec<i64>>,
	outer_width__lt: Option<Vec<i64>>,
	outer_width__lte: Option<Vec<i64>>,
	outer_width__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	serial: Option<Vec<String>>,
	serial__empty: Option<bool>,
	serial__ic: Option<Vec<String>>,
	serial__ie: Option<Vec<String>>,
	serial__iew: Option<Vec<String>>,
	serial__isw: Option<Vec<String>>,
	serial__n: Option<Vec<String>>,
	serial__nic: Option<Vec<String>>,
	serial__nie: Option<Vec<String>>,
	serial__niew: Option<Vec<String>>,
	serial__nisw: Option<Vec<String>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	starting_unit: Option<Vec<i64>>,
	starting_unit__empty: Option<bool>,
	starting_unit__gt: Option<Vec<i64>>,
	starting_unit__gte: Option<Vec<i64>>,
	starting_unit__lt: Option<Vec<i64>>,
	starting_unit__lte: Option<Vec<i64>>,
	starting_unit__n: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	u_height: Option<Vec<i64>>,
	u_height__empty: Option<bool>,
	u_height__gt: Option<Vec<i64>>,
	u_height__gte: Option<Vec<i64>>,
	u_height__lt: Option<Vec<i64>>,
	u_height__lte: Option<Vec<i64>>,
	u_height__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	weight: Option<Vec<f64>>,
	weight__empty: Option<bool>,
	weight__gt: Option<Vec<f64>>,
	weight__gte: Option<Vec<f64>>,
	weight__lt: Option<Vec<f64>>,
	weight__lte: Option<Vec<f64>>,
	weight__n: Option<Vec<f64>>,
	weight_unit: Option<String>,
	weight_unit__n: Option<String>,
	/// Rail-to-rail width
	width: Option<Vec<i64>>,
	/// Rail-to-rail width
	width__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksListResponse {
	Http200(PaginatedRackList),
	#[default]
	None
}
/// Get a list of rack objects.
pub fn dcim_racks_list(state: &ThanixClient, query: DcimRacksListQuery) -> Result<DcimRacksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/racks/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksListResponse::Http200(r#response.json::<PaginatedRackList>()?)) },
		_ => { Ok(DcimRacksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksBulkUpdateResponse {
	Http200(Vec<Rack>),
	#[default]
	None
}
/// Put a list of rack objects.
pub fn dcim_racks_bulk_update(state: &ThanixClient, body: Vec<RackRequest>) -> Result<DcimRacksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/racks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksBulkUpdateResponse::Http200(r#response.json::<Vec<Rack>>()?)) },
		_ => { Ok(DcimRacksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksCreateResponse {
	Http201(Rack),
	#[default]
	None
}
/// Post a list of rack objects.
pub fn dcim_racks_create(state: &ThanixClient, body: WritableRackRequest) -> Result<DcimRacksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/racks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimRacksCreateResponse::Http201(r#response.json::<Rack>()?)) },
		_ => { Ok(DcimRacksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of rack objects.
pub fn dcim_racks_bulk_destroy(state: &ThanixClient, body: Vec<RackRequest>) -> Result<DcimRacksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/racks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRacksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksBulkPartialUpdateResponse {
	Http200(Vec<Rack>),
	#[default]
	None
}
/// Patch a list of rack objects.
pub fn dcim_racks_bulk_partial_update(state: &ThanixClient, body: Vec<RackRequest>) -> Result<DcimRacksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/racks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Rack>>()?)) },
		_ => { Ok(DcimRacksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksRetrieveResponse {
	Http200(Rack),
	#[default]
	None
}
/// Get a rack object.
pub fn dcim_racks_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRacksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/racks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksRetrieveResponse::Http200(r#response.json::<Rack>()?)) },
		_ => { Ok(DcimRacksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksUpdateResponse {
	Http200(Rack),
	#[default]
	None
}
/// Put a rack object.
pub fn dcim_racks_update(state: &ThanixClient, body: WritableRackRequest, id: i64) -> Result<DcimRacksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/racks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksUpdateResponse::Http200(r#response.json::<Rack>()?)) },
		_ => { Ok(DcimRacksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a rack object.
pub fn dcim_racks_destroy(state: &ThanixClient, id: i64) -> Result<DcimRacksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/racks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRacksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksPartialUpdateResponse {
	Http200(Rack),
	#[default]
	None
}
/// Patch a rack object.
pub fn dcim_racks_partial_update(state: &ThanixClient, body: PatchedWritableRackRequest, id: i64) -> Result<DcimRacksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/racks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksPartialUpdateResponse::Http200(r#response.json::<Rack>()?)) },
		_ => { Ok(DcimRacksPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRacksElevationRetrieveResponse {
	Http200(Rack),
	#[default]
	None
}
/// Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
pub fn dcim_racks_elevation_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRacksElevationRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/racks/{id}/elevation/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRacksElevationRetrieveResponse::Http200(r#response.json::<Rack>()?)) },
		_ => { Ok(DcimRacksElevationRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimRearPortTemplatesListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type (ID)
	devicetype_id: Option<Vec<i64>>,
	/// Device type (ID)
	devicetype_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// Module type (ID)
	moduletype_id: Option<Vec<i64>>,
	/// Module type (ID)
	moduletype_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	positions: Option<Vec<i64>>,
	positions__empty: Option<bool>,
	positions__gt: Option<Vec<i64>>,
	positions__gte: Option<Vec<i64>>,
	positions__lt: Option<Vec<i64>>,
	positions__lte: Option<Vec<i64>>,
	positions__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesListResponse {
	Http200(PaginatedRearPortTemplateList),
	#[default]
	None
}
/// Get a list of rear port template objects.
pub fn dcim_rear_port_templates_list(state: &ThanixClient, query: DcimRearPortTemplatesListQuery) -> Result<DcimRearPortTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rear-port-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortTemplatesListResponse::Http200(r#response.json::<PaginatedRearPortTemplateList>()?)) },
		_ => { Ok(DcimRearPortTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesBulkUpdateResponse {
	Http200(Vec<RearPortTemplate>),
	#[default]
	None
}
/// Put a list of rear port template objects.
pub fn dcim_rear_port_templates_bulk_update(state: &ThanixClient, body: Vec<RearPortTemplateRequest>) -> Result<DcimRearPortTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rear-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<RearPortTemplate>>()?)) },
		_ => { Ok(DcimRearPortTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesCreateResponse {
	Http201(RearPortTemplate),
	#[default]
	None
}
/// Post a list of rear port template objects.
pub fn dcim_rear_port_templates_create(state: &ThanixClient, body: WritableRearPortTemplateRequest) -> Result<DcimRearPortTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/rear-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimRearPortTemplatesCreateResponse::Http201(r#response.json::<RearPortTemplate>()?)) },
		_ => { Ok(DcimRearPortTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of rear port template objects.
pub fn dcim_rear_port_templates_bulk_destroy(state: &ThanixClient, body: Vec<RearPortTemplateRequest>) -> Result<DcimRearPortTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rear-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRearPortTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesBulkPartialUpdateResponse {
	Http200(Vec<RearPortTemplate>),
	#[default]
	None
}
/// Patch a list of rear port template objects.
pub fn dcim_rear_port_templates_bulk_partial_update(state: &ThanixClient, body: Vec<RearPortTemplateRequest>) -> Result<DcimRearPortTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rear-port-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<RearPortTemplate>>()?)) },
		_ => { Ok(DcimRearPortTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesRetrieveResponse {
	Http200(RearPortTemplate),
	#[default]
	None
}
/// Get a rear port template object.
pub fn dcim_rear_port_templates_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRearPortTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rear-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortTemplatesRetrieveResponse::Http200(r#response.json::<RearPortTemplate>()?)) },
		_ => { Ok(DcimRearPortTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesUpdateResponse {
	Http200(RearPortTemplate),
	#[default]
	None
}
/// Put a rear port template object.
pub fn dcim_rear_port_templates_update(state: &ThanixClient, body: WritableRearPortTemplateRequest, id: i64) -> Result<DcimRearPortTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rear-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortTemplatesUpdateResponse::Http200(r#response.json::<RearPortTemplate>()?)) },
		_ => { Ok(DcimRearPortTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a rear port template object.
pub fn dcim_rear_port_templates_destroy(state: &ThanixClient, id: i64) -> Result<DcimRearPortTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rear-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRearPortTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortTemplatesPartialUpdateResponse {
	Http200(RearPortTemplate),
	#[default]
	None
}
/// Patch a rear port template object.
pub fn dcim_rear_port_templates_partial_update(state: &ThanixClient, body: PatchedWritableRearPortTemplateRequest, id: i64) -> Result<DcimRearPortTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rear-port-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortTemplatesPartialUpdateResponse::Http200(r#response.json::<RearPortTemplate>()?)) },
		_ => { Ok(DcimRearPortTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimRearPortsListQuery {
	cable_end: Option<String>,
	cable_end__n: Option<String>,
	cabled: Option<bool>,
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	device_role: Option<Vec<String>>,
	/// Device role (slug)
	device_role__n: Option<Vec<String>>,
	/// Device role (ID)
	device_role_id: Option<Vec<i64>>,
	/// Device role (ID)
	device_role_id__n: Option<Vec<i64>>,
	/// Device type (model)
	device_type: Option<Vec<String>>,
	/// Device type (model)
	device_type__n: Option<Vec<String>>,
	/// Device type (ID)
	device_type_id: Option<Vec<i64>>,
	/// Device type (ID)
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	label: Option<Vec<String>>,
	label__empty: Option<bool>,
	label__ic: Option<Vec<String>>,
	label__ie: Option<Vec<String>>,
	label__iew: Option<Vec<String>>,
	label__isw: Option<Vec<String>>,
	label__n: Option<Vec<String>>,
	label__nic: Option<Vec<String>>,
	label__nie: Option<Vec<String>>,
	label__niew: Option<Vec<String>>,
	label__nisw: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location (ID)
	location_id: Option<Vec<i64>>,
	/// Location (ID)
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	/// Module (ID)
	module_id: Option<Vec<i64>>,
	/// Module (ID)
	module_id__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	occupied: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	positions: Option<Vec<i64>>,
	positions__empty: Option<bool>,
	positions__gt: Option<Vec<i64>>,
	positions__gte: Option<Vec<i64>>,
	positions__lt: Option<Vec<i64>>,
	positions__lte: Option<Vec<i64>>,
	positions__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Rack (name)
	rack: Option<Vec<String>>,
	/// Rack (name)
	rack__n: Option<Vec<String>>,
	/// Rack (ID)
	rack_id: Option<Vec<i64>>,
	/// Rack (ID)
	rack_id__n: Option<Vec<i64>>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Device role (slug)
	role: Option<Vec<String>>,
	/// Device role (slug)
	role__n: Option<Vec<String>>,
	/// Device role (ID)
	role_id: Option<Vec<i64>>,
	/// Device role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual Chassis
	virtual_chassis: Option<Vec<String>>,
	/// Virtual Chassis
	virtual_chassis__n: Option<Vec<String>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id: Option<Vec<i64>>,
	/// Virtual Chassis (ID)
	virtual_chassis_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsListResponse {
	Http200(PaginatedRearPortList),
	#[default]
	None
}
/// Get a list of rear port objects.
pub fn dcim_rear_ports_list(state: &ThanixClient, query: DcimRearPortsListQuery) -> Result<DcimRearPortsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rear-ports/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsListResponse::Http200(r#response.json::<PaginatedRearPortList>()?)) },
		_ => { Ok(DcimRearPortsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsBulkUpdateResponse {
	Http200(Vec<RearPort>),
	#[default]
	None
}
/// Put a list of rear port objects.
pub fn dcim_rear_ports_bulk_update(state: &ThanixClient, body: Vec<RearPortRequest>) -> Result<DcimRearPortsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rear-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsBulkUpdateResponse::Http200(r#response.json::<Vec<RearPort>>()?)) },
		_ => { Ok(DcimRearPortsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsCreateResponse {
	Http201(RearPort),
	#[default]
	None
}
/// Post a list of rear port objects.
pub fn dcim_rear_ports_create(state: &ThanixClient, body: WritableRearPortRequest) -> Result<DcimRearPortsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/rear-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimRearPortsCreateResponse::Http201(r#response.json::<RearPort>()?)) },
		_ => { Ok(DcimRearPortsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of rear port objects.
pub fn dcim_rear_ports_bulk_destroy(state: &ThanixClient, body: Vec<RearPortRequest>) -> Result<DcimRearPortsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rear-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRearPortsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsBulkPartialUpdateResponse {
	Http200(Vec<RearPort>),
	#[default]
	None
}
/// Patch a list of rear port objects.
pub fn dcim_rear_ports_bulk_partial_update(state: &ThanixClient, body: Vec<RearPortRequest>) -> Result<DcimRearPortsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rear-ports/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<RearPort>>()?)) },
		_ => { Ok(DcimRearPortsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsRetrieveResponse {
	Http200(RearPort),
	#[default]
	None
}
/// Get a rear port object.
pub fn dcim_rear_ports_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRearPortsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rear-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsRetrieveResponse::Http200(r#response.json::<RearPort>()?)) },
		_ => { Ok(DcimRearPortsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsUpdateResponse {
	Http200(RearPort),
	#[default]
	None
}
/// Put a rear port object.
pub fn dcim_rear_ports_update(state: &ThanixClient, body: WritableRearPortRequest, id: i64) -> Result<DcimRearPortsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/rear-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsUpdateResponse::Http200(r#response.json::<RearPort>()?)) },
		_ => { Ok(DcimRearPortsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a rear port object.
pub fn dcim_rear_ports_destroy(state: &ThanixClient, id: i64) -> Result<DcimRearPortsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/rear-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRearPortsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsPartialUpdateResponse {
	Http200(RearPort),
	#[default]
	None
}
/// Patch a rear port object.
pub fn dcim_rear_ports_partial_update(state: &ThanixClient, body: PatchedWritableRearPortRequest, id: i64) -> Result<DcimRearPortsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/rear-ports/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsPartialUpdateResponse::Http200(r#response.json::<RearPort>()?)) },
		_ => { Ok(DcimRearPortsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRearPortsPathsRetrieveResponse {
	Http200(RearPort),
	#[default]
	None
}
/// Return all CablePaths which traverse a given pass-through port.
pub fn dcim_rear_ports_paths_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRearPortsPathsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/rear-ports/{id}/paths/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRearPortsPathsRetrieveResponse::Http200(r#response.json::<RearPort>()?)) },
		_ => { Ok(DcimRearPortsPathsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimRegionsListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent region (slug)
	parent: Option<Vec<String>>,
	/// Parent region (slug)
	parent__n: Option<Vec<String>>,
	/// Parent region (ID)
	parent_id: Option<Vec<i64>>,
	/// Parent region (ID)
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsListResponse {
	Http200(PaginatedRegionList),
	#[default]
	None
}
/// Get a list of region objects.
pub fn dcim_regions_list(state: &ThanixClient, query: DcimRegionsListQuery) -> Result<DcimRegionsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/regions/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRegionsListResponse::Http200(r#response.json::<PaginatedRegionList>()?)) },
		_ => { Ok(DcimRegionsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsBulkUpdateResponse {
	Http200(Vec<Region>),
	#[default]
	None
}
/// Put a list of region objects.
pub fn dcim_regions_bulk_update(state: &ThanixClient, body: Vec<RegionRequest>) -> Result<DcimRegionsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/regions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRegionsBulkUpdateResponse::Http200(r#response.json::<Vec<Region>>()?)) },
		_ => { Ok(DcimRegionsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsCreateResponse {
	Http201(Region),
	#[default]
	None
}
/// Post a list of region objects.
pub fn dcim_regions_create(state: &ThanixClient, body: WritableRegionRequest) -> Result<DcimRegionsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/regions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimRegionsCreateResponse::Http201(r#response.json::<Region>()?)) },
		_ => { Ok(DcimRegionsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of region objects.
pub fn dcim_regions_bulk_destroy(state: &ThanixClient, body: Vec<RegionRequest>) -> Result<DcimRegionsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/regions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRegionsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsBulkPartialUpdateResponse {
	Http200(Vec<Region>),
	#[default]
	None
}
/// Patch a list of region objects.
pub fn dcim_regions_bulk_partial_update(state: &ThanixClient, body: Vec<RegionRequest>) -> Result<DcimRegionsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/regions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRegionsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Region>>()?)) },
		_ => { Ok(DcimRegionsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsRetrieveResponse {
	Http200(Region),
	#[default]
	None
}
/// Get a region object.
pub fn dcim_regions_retrieve(state: &ThanixClient, id: i64) -> Result<DcimRegionsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/regions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRegionsRetrieveResponse::Http200(r#response.json::<Region>()?)) },
		_ => { Ok(DcimRegionsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsUpdateResponse {
	Http200(Region),
	#[default]
	None
}
/// Put a region object.
pub fn dcim_regions_update(state: &ThanixClient, body: WritableRegionRequest, id: i64) -> Result<DcimRegionsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/regions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRegionsUpdateResponse::Http200(r#response.json::<Region>()?)) },
		_ => { Ok(DcimRegionsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a region object.
pub fn dcim_regions_destroy(state: &ThanixClient, id: i64) -> Result<DcimRegionsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/regions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimRegionsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimRegionsPartialUpdateResponse {
	Http200(Region),
	#[default]
	None
}
/// Patch a region object.
pub fn dcim_regions_partial_update(state: &ThanixClient, body: PatchedWritableRegionRequest, id: i64) -> Result<DcimRegionsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/regions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimRegionsPartialUpdateResponse::Http200(r#response.json::<Region>()?)) },
		_ => { Ok(DcimRegionsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimSiteGroupsListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent site group (slug)
	parent: Option<Vec<String>>,
	/// Parent site group (slug)
	parent__n: Option<Vec<String>>,
	/// Parent site group (ID)
	parent_id: Option<Vec<i64>>,
	/// Parent site group (ID)
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsListResponse {
	Http200(PaginatedSiteGroupList),
	#[default]
	None
}
/// Get a list of site group objects.
pub fn dcim_site_groups_list(state: &ThanixClient, query: DcimSiteGroupsListQuery) -> Result<DcimSiteGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/site-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSiteGroupsListResponse::Http200(r#response.json::<PaginatedSiteGroupList>()?)) },
		_ => { Ok(DcimSiteGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsBulkUpdateResponse {
	Http200(Vec<SiteGroup>),
	#[default]
	None
}
/// Put a list of site group objects.
pub fn dcim_site_groups_bulk_update(state: &ThanixClient, body: Vec<SiteGroupRequest>) -> Result<DcimSiteGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/site-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSiteGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<SiteGroup>>()?)) },
		_ => { Ok(DcimSiteGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsCreateResponse {
	Http201(SiteGroup),
	#[default]
	None
}
/// Post a list of site group objects.
pub fn dcim_site_groups_create(state: &ThanixClient, body: WritableSiteGroupRequest) -> Result<DcimSiteGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/site-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimSiteGroupsCreateResponse::Http201(r#response.json::<SiteGroup>()?)) },
		_ => { Ok(DcimSiteGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of site group objects.
pub fn dcim_site_groups_bulk_destroy(state: &ThanixClient, body: Vec<SiteGroupRequest>) -> Result<DcimSiteGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/site-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimSiteGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsBulkPartialUpdateResponse {
	Http200(Vec<SiteGroup>),
	#[default]
	None
}
/// Patch a list of site group objects.
pub fn dcim_site_groups_bulk_partial_update(state: &ThanixClient, body: Vec<SiteGroupRequest>) -> Result<DcimSiteGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/site-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSiteGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<SiteGroup>>()?)) },
		_ => { Ok(DcimSiteGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsRetrieveResponse {
	Http200(SiteGroup),
	#[default]
	None
}
/// Get a site group object.
pub fn dcim_site_groups_retrieve(state: &ThanixClient, id: i64) -> Result<DcimSiteGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/site-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSiteGroupsRetrieveResponse::Http200(r#response.json::<SiteGroup>()?)) },
		_ => { Ok(DcimSiteGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsUpdateResponse {
	Http200(SiteGroup),
	#[default]
	None
}
/// Put a site group object.
pub fn dcim_site_groups_update(state: &ThanixClient, body: WritableSiteGroupRequest, id: i64) -> Result<DcimSiteGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/site-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSiteGroupsUpdateResponse::Http200(r#response.json::<SiteGroup>()?)) },
		_ => { Ok(DcimSiteGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a site group object.
pub fn dcim_site_groups_destroy(state: &ThanixClient, id: i64) -> Result<DcimSiteGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/site-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimSiteGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSiteGroupsPartialUpdateResponse {
	Http200(SiteGroup),
	#[default]
	None
}
/// Patch a site group object.
pub fn dcim_site_groups_partial_update(state: &ThanixClient, body: PatchedWritableSiteGroupRequest, id: i64) -> Result<DcimSiteGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/site-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSiteGroupsPartialUpdateResponse::Http200(r#response.json::<SiteGroup>()?)) },
		_ => { Ok(DcimSiteGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimSitesListQuery {
	/// AS (ID)
	asn: Option<Vec<u32>>,
	/// AS (ID)
	asn__n: Option<Vec<u32>>,
	/// AS (ID)
	asn_id: Option<Vec<i64>>,
	/// AS (ID)
	asn_id__n: Option<Vec<i64>>,
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	facility: Option<Vec<String>>,
	facility__empty: Option<bool>,
	facility__ic: Option<Vec<String>>,
	facility__ie: Option<Vec<String>>,
	facility__iew: Option<Vec<String>>,
	facility__isw: Option<Vec<String>>,
	facility__n: Option<Vec<String>>,
	facility__nic: Option<Vec<String>>,
	facility__nie: Option<Vec<String>>,
	facility__niew: Option<Vec<String>>,
	facility__nisw: Option<Vec<String>>,
	/// Group (slug)
	group: Option<Vec<i64>>,
	/// Group (slug)
	group__n: Option<Vec<i64>>,
	/// Group (ID)
	group_id: Option<Vec<i64>>,
	/// Group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	latitude: Option<Vec<f64>>,
	latitude__empty: Option<bool>,
	latitude__gt: Option<Vec<f64>>,
	latitude__gte: Option<Vec<f64>>,
	latitude__lt: Option<Vec<f64>>,
	latitude__lte: Option<Vec<f64>>,
	latitude__n: Option<Vec<f64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	longitude: Option<Vec<f64>>,
	longitude__empty: Option<bool>,
	longitude__gt: Option<Vec<f64>>,
	longitude__gte: Option<Vec<f64>>,
	longitude__lt: Option<Vec<f64>>,
	longitude__lte: Option<Vec<f64>>,
	longitude__n: Option<Vec<f64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesListResponse {
	Http200(PaginatedSiteList),
	#[default]
	None
}
/// Get a list of site objects.
pub fn dcim_sites_list(state: &ThanixClient, query: DcimSitesListQuery) -> Result<DcimSitesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/sites/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSitesListResponse::Http200(r#response.json::<PaginatedSiteList>()?)) },
		_ => { Ok(DcimSitesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesBulkUpdateResponse {
	Http200(Vec<Site>),
	#[default]
	None
}
/// Put a list of site objects.
pub fn dcim_sites_bulk_update(state: &ThanixClient, body: Vec<SiteRequest>) -> Result<DcimSitesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/sites/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSitesBulkUpdateResponse::Http200(r#response.json::<Vec<Site>>()?)) },
		_ => { Ok(DcimSitesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesCreateResponse {
	Http201(Site),
	#[default]
	None
}
/// Post a list of site objects.
pub fn dcim_sites_create(state: &ThanixClient, body: WritableSiteRequest) -> Result<DcimSitesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/sites/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimSitesCreateResponse::Http201(r#response.json::<Site>()?)) },
		_ => { Ok(DcimSitesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of site objects.
pub fn dcim_sites_bulk_destroy(state: &ThanixClient, body: Vec<SiteRequest>) -> Result<DcimSitesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/sites/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimSitesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesBulkPartialUpdateResponse {
	Http200(Vec<Site>),
	#[default]
	None
}
/// Patch a list of site objects.
pub fn dcim_sites_bulk_partial_update(state: &ThanixClient, body: Vec<SiteRequest>) -> Result<DcimSitesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/sites/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSitesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Site>>()?)) },
		_ => { Ok(DcimSitesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesRetrieveResponse {
	Http200(Site),
	#[default]
	None
}
/// Get a site object.
pub fn dcim_sites_retrieve(state: &ThanixClient, id: i64) -> Result<DcimSitesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/sites/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSitesRetrieveResponse::Http200(r#response.json::<Site>()?)) },
		_ => { Ok(DcimSitesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesUpdateResponse {
	Http200(Site),
	#[default]
	None
}
/// Put a site object.
pub fn dcim_sites_update(state: &ThanixClient, body: WritableSiteRequest, id: i64) -> Result<DcimSitesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/sites/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSitesUpdateResponse::Http200(r#response.json::<Site>()?)) },
		_ => { Ok(DcimSitesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a site object.
pub fn dcim_sites_destroy(state: &ThanixClient, id: i64) -> Result<DcimSitesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/sites/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimSitesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimSitesPartialUpdateResponse {
	Http200(Site),
	#[default]
	None
}
/// Patch a site object.
pub fn dcim_sites_partial_update(state: &ThanixClient, body: PatchedWritableSiteRequest, id: i64) -> Result<DcimSitesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/sites/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimSitesPartialUpdateResponse::Http200(r#response.json::<Site>()?)) },
		_ => { Ok(DcimSitesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimVirtualChassisListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	domain: Option<Vec<String>>,
	domain__empty: Option<bool>,
	domain__ic: Option<Vec<String>>,
	domain__ie: Option<Vec<String>>,
	domain__iew: Option<Vec<String>>,
	domain__isw: Option<Vec<String>>,
	domain__n: Option<Vec<String>>,
	domain__nic: Option<Vec<String>>,
	domain__nie: Option<Vec<String>>,
	domain__niew: Option<Vec<String>>,
	domain__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Master (name)
	master: Option<Vec<Option<String>>>,
	/// Master (name)
	master__n: Option<Vec<Option<String>>>,
	/// Master (ID)
	master_id: Option<Vec<i64>>,
	/// Master (ID)
	master_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site name (slug)
	site: Option<Vec<String>>,
	/// Site name (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisListResponse {
	Http200(PaginatedVirtualChassisList),
	#[default]
	None
}
/// Get a list of virtual chassis objects.
pub fn dcim_virtual_chassis_list(state: &ThanixClient, query: DcimVirtualChassisListQuery) -> Result<DcimVirtualChassisListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/virtual-chassis/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualChassisListResponse::Http200(r#response.json::<PaginatedVirtualChassisList>()?)) },
		_ => { Ok(DcimVirtualChassisListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisBulkUpdateResponse {
	Http200(Vec<VirtualChassis>),
	#[default]
	None
}
/// Put a list of virtual chassis objects.
pub fn dcim_virtual_chassis_bulk_update(state: &ThanixClient, body: Vec<VirtualChassisRequest>) -> Result<DcimVirtualChassisBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/virtual-chassis/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualChassisBulkUpdateResponse::Http200(r#response.json::<Vec<VirtualChassis>>()?)) },
		_ => { Ok(DcimVirtualChassisBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisCreateResponse {
	Http201(VirtualChassis),
	#[default]
	None
}
/// Post a list of virtual chassis objects.
pub fn dcim_virtual_chassis_create(state: &ThanixClient, body: WritableVirtualChassisRequest) -> Result<DcimVirtualChassisCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/virtual-chassis/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimVirtualChassisCreateResponse::Http201(r#response.json::<VirtualChassis>()?)) },
		_ => { Ok(DcimVirtualChassisCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of virtual chassis objects.
pub fn dcim_virtual_chassis_bulk_destroy(state: &ThanixClient, body: Vec<VirtualChassisRequest>) -> Result<DcimVirtualChassisBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/virtual-chassis/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimVirtualChassisBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisBulkPartialUpdateResponse {
	Http200(Vec<VirtualChassis>),
	#[default]
	None
}
/// Patch a list of virtual chassis objects.
pub fn dcim_virtual_chassis_bulk_partial_update(state: &ThanixClient, body: Vec<VirtualChassisRequest>) -> Result<DcimVirtualChassisBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/virtual-chassis/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualChassisBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VirtualChassis>>()?)) },
		_ => { Ok(DcimVirtualChassisBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisRetrieveResponse {
	Http200(VirtualChassis),
	#[default]
	None
}
/// Get a virtual chassis object.
pub fn dcim_virtual_chassis_retrieve(state: &ThanixClient, id: i64) -> Result<DcimVirtualChassisRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/virtual-chassis/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualChassisRetrieveResponse::Http200(r#response.json::<VirtualChassis>()?)) },
		_ => { Ok(DcimVirtualChassisRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisUpdateResponse {
	Http200(VirtualChassis),
	#[default]
	None
}
/// Put a virtual chassis object.
pub fn dcim_virtual_chassis_update(state: &ThanixClient, body: WritableVirtualChassisRequest, id: i64) -> Result<DcimVirtualChassisUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/virtual-chassis/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualChassisUpdateResponse::Http200(r#response.json::<VirtualChassis>()?)) },
		_ => { Ok(DcimVirtualChassisUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a virtual chassis object.
pub fn dcim_virtual_chassis_destroy(state: &ThanixClient, id: i64) -> Result<DcimVirtualChassisDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/virtual-chassis/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimVirtualChassisDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualChassisPartialUpdateResponse {
	Http200(VirtualChassis),
	#[default]
	None
}
/// Patch a virtual chassis object.
pub fn dcim_virtual_chassis_partial_update(state: &ThanixClient, body: PatchedWritableVirtualChassisRequest, id: i64) -> Result<DcimVirtualChassisPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/virtual-chassis/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualChassisPartialUpdateResponse::Http200(r#response.json::<VirtualChassis>()?)) },
		_ => { Ok(DcimVirtualChassisPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct DcimVirtualDeviceContextsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device model
	device: Option<Vec<i64>>,
	/// Device model
	device__n: Option<Vec<i64>>,
	/// VDC (ID)
	device_id: Option<Vec<i64>>,
	/// VDC (ID)
	device_id__n: Option<Vec<i64>>,
	/// Has a primary IP
	has_primary_ip: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Primary IPv4 (ID)
	primary_ip4_id: Option<Vec<i64>>,
	/// Primary IPv4 (ID)
	primary_ip4_id__n: Option<Vec<i64>>,
	/// Primary IPv6 (ID)
	primary_ip6_id: Option<Vec<i64>>,
	/// Primary IPv6 (ID)
	primary_ip6_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsListResponse {
	Http200(PaginatedVirtualDeviceContextList),
	#[default]
	None
}
/// Get a list of virtual device context objects.
pub fn dcim_virtual_device_contexts_list(state: &ThanixClient, query: DcimVirtualDeviceContextsListQuery) -> Result<DcimVirtualDeviceContextsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/virtual-device-contexts/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualDeviceContextsListResponse::Http200(r#response.json::<PaginatedVirtualDeviceContextList>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsBulkUpdateResponse {
	Http200(Vec<VirtualDeviceContext>),
	#[default]
	None
}
/// Put a list of virtual device context objects.
pub fn dcim_virtual_device_contexts_bulk_update(state: &ThanixClient, body: Vec<VirtualDeviceContextRequest>) -> Result<DcimVirtualDeviceContextsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/virtual-device-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualDeviceContextsBulkUpdateResponse::Http200(r#response.json::<Vec<VirtualDeviceContext>>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsCreateResponse {
	Http201(VirtualDeviceContext),
	#[default]
	None
}
/// Post a list of virtual device context objects.
pub fn dcim_virtual_device_contexts_create(state: &ThanixClient, body: WritableVirtualDeviceContextRequest) -> Result<DcimVirtualDeviceContextsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/dcim/virtual-device-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(DcimVirtualDeviceContextsCreateResponse::Http201(r#response.json::<VirtualDeviceContext>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of virtual device context objects.
pub fn dcim_virtual_device_contexts_bulk_destroy(state: &ThanixClient, body: Vec<VirtualDeviceContextRequest>) -> Result<DcimVirtualDeviceContextsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/virtual-device-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimVirtualDeviceContextsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsBulkPartialUpdateResponse {
	Http200(Vec<VirtualDeviceContext>),
	#[default]
	None
}
/// Patch a list of virtual device context objects.
pub fn dcim_virtual_device_contexts_bulk_partial_update(state: &ThanixClient, body: Vec<VirtualDeviceContextRequest>) -> Result<DcimVirtualDeviceContextsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/virtual-device-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualDeviceContextsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VirtualDeviceContext>>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsRetrieveResponse {
	Http200(VirtualDeviceContext),
	#[default]
	None
}
/// Get a virtual device context object.
pub fn dcim_virtual_device_contexts_retrieve(state: &ThanixClient, id: i64) -> Result<DcimVirtualDeviceContextsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/dcim/virtual-device-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualDeviceContextsRetrieveResponse::Http200(r#response.json::<VirtualDeviceContext>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsUpdateResponse {
	Http200(VirtualDeviceContext),
	#[default]
	None
}
/// Put a virtual device context object.
pub fn dcim_virtual_device_contexts_update(state: &ThanixClient, body: WritableVirtualDeviceContextRequest, id: i64) -> Result<DcimVirtualDeviceContextsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/dcim/virtual-device-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualDeviceContextsUpdateResponse::Http200(r#response.json::<VirtualDeviceContext>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a virtual device context object.
pub fn dcim_virtual_device_contexts_destroy(state: &ThanixClient, id: i64) -> Result<DcimVirtualDeviceContextsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/dcim/virtual-device-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(DcimVirtualDeviceContextsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum DcimVirtualDeviceContextsPartialUpdateResponse {
	Http200(VirtualDeviceContext),
	#[default]
	None
}
/// Patch a virtual device context object.
pub fn dcim_virtual_device_contexts_partial_update(state: &ThanixClient, body: PatchedWritableVirtualDeviceContextRequest, id: i64) -> Result<DcimVirtualDeviceContextsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/dcim/virtual-device-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(DcimVirtualDeviceContextsPartialUpdateResponse::Http200(r#response.json::<VirtualDeviceContext>()?)) },
		_ => { Ok(DcimVirtualDeviceContextsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasBookmarksListQuery {
	created: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	object_id: Option<Vec<i64>>,
	object_id__empty: Option<bool>,
	object_id__gt: Option<Vec<i64>>,
	object_id__gte: Option<Vec<i64>>,
	object_id__lt: Option<Vec<i64>>,
	object_id__lte: Option<Vec<i64>>,
	object_id__n: Option<Vec<i64>>,
	object_type: Option<String>,
	object_type__n: Option<String>,
	object_type_id: Option<Vec<i64>>,
	object_type_id__empty: Option<Vec<i64>>,
	object_type_id__gt: Option<Vec<i64>>,
	object_type_id__gte: Option<Vec<i64>>,
	object_type_id__lt: Option<Vec<i64>>,
	object_type_id__lte: Option<Vec<i64>>,
	object_type_id__n: Option<Vec<i64>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// User (name)
	user: Option<Vec<String>>,
	/// User (name)
	user__n: Option<Vec<String>>,
	/// User (ID)
	user_id: Option<Vec<i64>>,
	/// User (ID)
	user_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksListResponse {
	Http200(PaginatedBookmarkList),
	#[default]
	None
}
/// Get a list of bookmark objects.
pub fn extras_bookmarks_list(state: &ThanixClient, query: ExtrasBookmarksListQuery) -> Result<ExtrasBookmarksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/bookmarks/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasBookmarksListResponse::Http200(r#response.json::<PaginatedBookmarkList>()?)) },
		_ => { Ok(ExtrasBookmarksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksBulkUpdateResponse {
	Http200(Vec<Bookmark>),
	#[default]
	None
}
/// Put a list of bookmark objects.
pub fn extras_bookmarks_bulk_update(state: &ThanixClient, body: Vec<BookmarkRequest>) -> Result<ExtrasBookmarksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/bookmarks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasBookmarksBulkUpdateResponse::Http200(r#response.json::<Vec<Bookmark>>()?)) },
		_ => { Ok(ExtrasBookmarksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksCreateResponse {
	Http201(Bookmark),
	#[default]
	None
}
/// Post a list of bookmark objects.
pub fn extras_bookmarks_create(state: &ThanixClient, body: WritableBookmarkRequest) -> Result<ExtrasBookmarksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/bookmarks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasBookmarksCreateResponse::Http201(r#response.json::<Bookmark>()?)) },
		_ => { Ok(ExtrasBookmarksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of bookmark objects.
pub fn extras_bookmarks_bulk_destroy(state: &ThanixClient, body: Vec<BookmarkRequest>) -> Result<ExtrasBookmarksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/bookmarks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasBookmarksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksBulkPartialUpdateResponse {
	Http200(Vec<Bookmark>),
	#[default]
	None
}
/// Patch a list of bookmark objects.
pub fn extras_bookmarks_bulk_partial_update(state: &ThanixClient, body: Vec<BookmarkRequest>) -> Result<ExtrasBookmarksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/bookmarks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasBookmarksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Bookmark>>()?)) },
		_ => { Ok(ExtrasBookmarksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksRetrieveResponse {
	Http200(Bookmark),
	#[default]
	None
}
/// Get a bookmark object.
pub fn extras_bookmarks_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasBookmarksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/bookmarks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasBookmarksRetrieveResponse::Http200(r#response.json::<Bookmark>()?)) },
		_ => { Ok(ExtrasBookmarksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksUpdateResponse {
	Http200(Bookmark),
	#[default]
	None
}
/// Put a bookmark object.
pub fn extras_bookmarks_update(state: &ThanixClient, body: WritableBookmarkRequest, id: i64) -> Result<ExtrasBookmarksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/bookmarks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasBookmarksUpdateResponse::Http200(r#response.json::<Bookmark>()?)) },
		_ => { Ok(ExtrasBookmarksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a bookmark object.
pub fn extras_bookmarks_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasBookmarksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/bookmarks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasBookmarksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasBookmarksPartialUpdateResponse {
	Http200(Bookmark),
	#[default]
	None
}
/// Patch a bookmark object.
pub fn extras_bookmarks_partial_update(state: &ThanixClient, body: PatchedWritableBookmarkRequest, id: i64) -> Result<ExtrasBookmarksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/bookmarks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasBookmarksPartialUpdateResponse::Http200(r#response.json::<Bookmark>()?)) },
		_ => { Ok(ExtrasBookmarksPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasConfigContextsListQuery {
	/// Cluster group (slug)
	cluster_group: Option<Vec<String>>,
	/// Cluster group (slug)
	cluster_group__n: Option<Vec<String>>,
	/// Cluster group
	cluster_group_id: Option<Vec<i64>>,
	/// Cluster group
	cluster_group_id__n: Option<Vec<i64>>,
	/// Cluster
	cluster_id: Option<Vec<i64>>,
	/// Cluster
	cluster_id__n: Option<Vec<i64>>,
	/// Cluster type (slug)
	cluster_type: Option<Vec<String>>,
	/// Cluster type (slug)
	cluster_type__n: Option<Vec<String>>,
	/// Cluster type
	cluster_type_id: Option<Vec<i64>>,
	/// Cluster type
	cluster_type_id__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	/// Data file (ID)
	data_file_id: Option<Vec<i64>>,
	/// Data file (ID)
	data_file_id__n: Option<Vec<i64>>,
	/// Data source (ID)
	data_source_id: Option<Vec<i64>>,
	/// Data source (ID)
	data_source_id__n: Option<Vec<i64>>,
	data_synced: Option<Vec<String>>,
	data_synced__empty: Option<bool>,
	data_synced__gt: Option<Vec<String>>,
	data_synced__gte: Option<Vec<String>>,
	data_synced__lt: Option<Vec<String>>,
	data_synced__lte: Option<Vec<String>>,
	data_synced__n: Option<Vec<String>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device type
	device_type_id: Option<Vec<i64>>,
	/// Device type
	device_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	is_active: Option<bool>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Location (slug)
	location: Option<Vec<String>>,
	/// Location (slug)
	location__n: Option<Vec<String>>,
	/// Location
	location_id: Option<Vec<i64>>,
	/// Location
	location_id__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Platform (slug)
	platform: Option<Vec<String>>,
	/// Platform (slug)
	platform__n: Option<Vec<String>>,
	/// Platform
	platform_id: Option<Vec<i64>>,
	/// Platform
	platform_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<String>>,
	/// Region (slug)
	region__n: Option<Vec<String>>,
	/// Region
	region_id: Option<Vec<i64>>,
	/// Region
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role
	role_id: Option<Vec<i64>>,
	/// Role
	role_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<String>>,
	/// Site group (slug)
	site_group__n: Option<Vec<String>>,
	/// Site group
	site_group_id: Option<Vec<i64>>,
	/// Site group
	site_group_id__n: Option<Vec<i64>>,
	/// Site
	site_id: Option<Vec<i64>>,
	/// Site
	site_id__n: Option<Vec<i64>>,
	/// Tag (slug)
	tag: Option<Vec<String>>,
	/// Tag (slug)
	tag__n: Option<Vec<String>>,
	/// Tag
	tag_id: Option<Vec<i64>>,
	/// Tag
	tag_id__n: Option<Vec<i64>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant group (slug)
	tenant_group: Option<Vec<String>>,
	/// Tenant group (slug)
	tenant_group__n: Option<Vec<String>>,
	/// Tenant group
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant group
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant
	tenant_id: Option<Vec<i64>>,
	/// Tenant
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsListResponse {
	Http200(PaginatedConfigContextList),
	#[default]
	None
}
/// Get a list of config context objects.
pub fn extras_config_contexts_list(state: &ThanixClient, query: ExtrasConfigContextsListQuery) -> Result<ExtrasConfigContextsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/config-contexts/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsListResponse::Http200(r#response.json::<PaginatedConfigContextList>()?)) },
		_ => { Ok(ExtrasConfigContextsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsBulkUpdateResponse {
	Http200(Vec<ConfigContext>),
	#[default]
	None
}
/// Put a list of config context objects.
pub fn extras_config_contexts_bulk_update(state: &ThanixClient, body: Vec<ConfigContextRequest>) -> Result<ExtrasConfigContextsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/config-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsBulkUpdateResponse::Http200(r#response.json::<Vec<ConfigContext>>()?)) },
		_ => { Ok(ExtrasConfigContextsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsCreateResponse {
	Http201(ConfigContext),
	#[default]
	None
}
/// Post a list of config context objects.
pub fn extras_config_contexts_create(state: &ThanixClient, body: WritableConfigContextRequest) -> Result<ExtrasConfigContextsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/config-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasConfigContextsCreateResponse::Http201(r#response.json::<ConfigContext>()?)) },
		_ => { Ok(ExtrasConfigContextsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of config context objects.
pub fn extras_config_contexts_bulk_destroy(state: &ThanixClient, body: Vec<ConfigContextRequest>) -> Result<ExtrasConfigContextsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/config-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasConfigContextsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsBulkPartialUpdateResponse {
	Http200(Vec<ConfigContext>),
	#[default]
	None
}
/// Patch a list of config context objects.
pub fn extras_config_contexts_bulk_partial_update(state: &ThanixClient, body: Vec<ConfigContextRequest>) -> Result<ExtrasConfigContextsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/config-contexts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ConfigContext>>()?)) },
		_ => { Ok(ExtrasConfigContextsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsRetrieveResponse {
	Http200(ConfigContext),
	#[default]
	None
}
/// Get a config context object.
pub fn extras_config_contexts_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasConfigContextsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/config-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsRetrieveResponse::Http200(r#response.json::<ConfigContext>()?)) },
		_ => { Ok(ExtrasConfigContextsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsUpdateResponse {
	Http200(ConfigContext),
	#[default]
	None
}
/// Put a config context object.
pub fn extras_config_contexts_update(state: &ThanixClient, body: WritableConfigContextRequest, id: i64) -> Result<ExtrasConfigContextsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/config-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsUpdateResponse::Http200(r#response.json::<ConfigContext>()?)) },
		_ => { Ok(ExtrasConfigContextsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a config context object.
pub fn extras_config_contexts_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasConfigContextsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/config-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasConfigContextsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsPartialUpdateResponse {
	Http200(ConfigContext),
	#[default]
	None
}
/// Patch a config context object.
pub fn extras_config_contexts_partial_update(state: &ThanixClient, body: PatchedWritableConfigContextRequest, id: i64) -> Result<ExtrasConfigContextsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/config-contexts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsPartialUpdateResponse::Http200(r#response.json::<ConfigContext>()?)) },
		_ => { Ok(ExtrasConfigContextsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigContextsSyncCreateResponse {
	Http200(ConfigContext),
	#[default]
	None
}
/// Provide a /sync API endpoint to synchronize an object's data from its associated DataFile (if any).
pub fn extras_config_contexts_sync_create(state: &ThanixClient, body: WritableConfigContextRequest, id: i64) -> Result<ExtrasConfigContextsSyncCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/config-contexts/{id}/sync/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigContextsSyncCreateResponse::Http200(r#response.json::<ConfigContext>()?)) },
		_ => { Ok(ExtrasConfigContextsSyncCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasConfigTemplatesListQuery {
	/// Data file (ID)
	data_file_id: Option<Vec<i64>>,
	/// Data file (ID)
	data_file_id__n: Option<Vec<i64>>,
	/// Data source (ID)
	data_source_id: Option<Vec<i64>>,
	/// Data source (ID)
	data_source_id__n: Option<Vec<i64>>,
	data_synced: Option<Vec<String>>,
	data_synced__empty: Option<bool>,
	data_synced__gt: Option<Vec<String>>,
	data_synced__gte: Option<Vec<String>>,
	data_synced__lt: Option<Vec<String>>,
	data_synced__lte: Option<Vec<String>>,
	data_synced__n: Option<Vec<String>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesListResponse {
	Http200(PaginatedConfigTemplateList),
	#[default]
	None
}
/// Get a list of config template objects.
pub fn extras_config_templates_list(state: &ThanixClient, query: ExtrasConfigTemplatesListQuery) -> Result<ExtrasConfigTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/config-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesListResponse::Http200(r#response.json::<PaginatedConfigTemplateList>()?)) },
		_ => { Ok(ExtrasConfigTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesBulkUpdateResponse {
	Http200(Vec<ConfigTemplate>),
	#[default]
	None
}
/// Put a list of config template objects.
pub fn extras_config_templates_bulk_update(state: &ThanixClient, body: Vec<ConfigTemplateRequest>) -> Result<ExtrasConfigTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/config-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<ConfigTemplate>>()?)) },
		_ => { Ok(ExtrasConfigTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesCreateResponse {
	Http201(ConfigTemplate),
	#[default]
	None
}
/// Post a list of config template objects.
pub fn extras_config_templates_create(state: &ThanixClient, body: WritableConfigTemplateRequest) -> Result<ExtrasConfigTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/config-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasConfigTemplatesCreateResponse::Http201(r#response.json::<ConfigTemplate>()?)) },
		_ => { Ok(ExtrasConfigTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of config template objects.
pub fn extras_config_templates_bulk_destroy(state: &ThanixClient, body: Vec<ConfigTemplateRequest>) -> Result<ExtrasConfigTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/config-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasConfigTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesBulkPartialUpdateResponse {
	Http200(Vec<ConfigTemplate>),
	#[default]
	None
}
/// Patch a list of config template objects.
pub fn extras_config_templates_bulk_partial_update(state: &ThanixClient, body: Vec<ConfigTemplateRequest>) -> Result<ExtrasConfigTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/config-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ConfigTemplate>>()?)) },
		_ => { Ok(ExtrasConfigTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesRetrieveResponse {
	Http200(ConfigTemplate),
	#[default]
	None
}
/// Get a config template object.
pub fn extras_config_templates_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasConfigTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/config-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesRetrieveResponse::Http200(r#response.json::<ConfigTemplate>()?)) },
		_ => { Ok(ExtrasConfigTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesUpdateResponse {
	Http200(ConfigTemplate),
	#[default]
	None
}
/// Put a config template object.
pub fn extras_config_templates_update(state: &ThanixClient, body: WritableConfigTemplateRequest, id: i64) -> Result<ExtrasConfigTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/config-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesUpdateResponse::Http200(r#response.json::<ConfigTemplate>()?)) },
		_ => { Ok(ExtrasConfigTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a config template object.
pub fn extras_config_templates_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasConfigTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/config-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasConfigTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesPartialUpdateResponse {
	Http200(ConfigTemplate),
	#[default]
	None
}
/// Patch a config template object.
pub fn extras_config_templates_partial_update(state: &ThanixClient, body: PatchedWritableConfigTemplateRequest, id: i64) -> Result<ExtrasConfigTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/config-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesPartialUpdateResponse::Http200(r#response.json::<ConfigTemplate>()?)) },
		_ => { Ok(ExtrasConfigTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasConfigTemplatesRenderCreateQuery {
	format: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesRenderCreateResponse {
	Http200(ConfigTemplate),
	#[default]
	None
}
/// Render a ConfigTemplate using the context data provided (if any). If the client requests "text/plain" data,
/// return the raw rendered content, rather than serialized JSON.
pub fn extras_config_templates_render_create(state: &ThanixClient, query: ExtrasConfigTemplatesRenderCreateQuery, body: WritableConfigTemplateRequest, id: i64) -> Result<ExtrasConfigTemplatesRenderCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/config-templates/{id}/render/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesRenderCreateResponse::Http200(r#response.json::<ConfigTemplate>()?)) },
		_ => { Ok(ExtrasConfigTemplatesRenderCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasConfigTemplatesSyncCreateResponse {
	Http200(ConfigTemplate),
	#[default]
	None
}
/// Provide a /sync API endpoint to synchronize an object's data from its associated DataFile (if any).
pub fn extras_config_templates_sync_create(state: &ThanixClient, body: WritableConfigTemplateRequest, id: i64) -> Result<ExtrasConfigTemplatesSyncCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/config-templates/{id}/sync/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasConfigTemplatesSyncCreateResponse::Http200(r#response.json::<ConfigTemplate>()?)) },
		_ => { Ok(ExtrasConfigTemplatesSyncCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasContentTypesListQuery {
	app_label: Option<String>,
	id: Option<i64>,
	/// Number of results to return per page.
	limit: Option<i64>,
	model: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasContentTypesListResponse {
	Http200(PaginatedContentTypeList),
	#[default]
	None
}
/// Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
pub fn extras_content_types_list(state: &ThanixClient, query: ExtrasContentTypesListQuery) -> Result<ExtrasContentTypesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/content-types/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasContentTypesListResponse::Http200(r#response.json::<PaginatedContentTypeList>()?)) },
		_ => { Ok(ExtrasContentTypesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasContentTypesRetrieveResponse {
	Http200(ContentType),
	#[default]
	None
}
/// Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
pub fn extras_content_types_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasContentTypesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/content-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasContentTypesRetrieveResponse::Http200(r#response.json::<ContentType>()?)) },
		_ => { Ok(ExtrasContentTypesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasCustomFieldChoiceSetsListQuery {
	/// Base set of predefined choices (optional)
	base_choices: Option<String>,
	/// Base set of predefined choices (optional)
	base_choices__n: Option<String>,
	choice: Option<Vec<String>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	order_alphabetically: Option<bool>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsListResponse {
	Http200(PaginatedCustomFieldChoiceSetList),
	#[default]
	None
}
/// Get a list of custom field choice set objects.
pub fn extras_custom_field_choice_sets_list(state: &ThanixClient, query: ExtrasCustomFieldChoiceSetsListQuery) -> Result<ExtrasCustomFieldChoiceSetsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-field-choice-sets/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsListResponse::Http200(r#response.json::<PaginatedCustomFieldChoiceSetList>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsBulkUpdateResponse {
	Http200(Vec<CustomFieldChoiceSet>),
	#[default]
	None
}
/// Put a list of custom field choice set objects.
pub fn extras_custom_field_choice_sets_bulk_update(state: &ThanixClient, body: Vec<CustomFieldChoiceSetRequest>) -> Result<ExtrasCustomFieldChoiceSetsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/custom-field-choice-sets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsBulkUpdateResponse::Http200(r#response.json::<Vec<CustomFieldChoiceSet>>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsCreateResponse {
	Http201(CustomFieldChoiceSet),
	#[default]
	None
}
/// Post a list of custom field choice set objects.
pub fn extras_custom_field_choice_sets_create(state: &ThanixClient, body: WritableCustomFieldChoiceSetRequest) -> Result<ExtrasCustomFieldChoiceSetsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/custom-field-choice-sets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasCustomFieldChoiceSetsCreateResponse::Http201(r#response.json::<CustomFieldChoiceSet>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of custom field choice set objects.
pub fn extras_custom_field_choice_sets_bulk_destroy(state: &ThanixClient, body: Vec<CustomFieldChoiceSetRequest>) -> Result<ExtrasCustomFieldChoiceSetsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/custom-field-choice-sets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasCustomFieldChoiceSetsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsBulkPartialUpdateResponse {
	Http200(Vec<CustomFieldChoiceSet>),
	#[default]
	None
}
/// Patch a list of custom field choice set objects.
pub fn extras_custom_field_choice_sets_bulk_partial_update(state: &ThanixClient, body: Vec<CustomFieldChoiceSetRequest>) -> Result<ExtrasCustomFieldChoiceSetsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/custom-field-choice-sets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<CustomFieldChoiceSet>>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsRetrieveResponse {
	Http200(CustomFieldChoiceSet),
	#[default]
	None
}
/// Get a custom field choice set object.
pub fn extras_custom_field_choice_sets_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasCustomFieldChoiceSetsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-field-choice-sets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsRetrieveResponse::Http200(r#response.json::<CustomFieldChoiceSet>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsUpdateResponse {
	Http200(CustomFieldChoiceSet),
	#[default]
	None
}
/// Put a custom field choice set object.
pub fn extras_custom_field_choice_sets_update(state: &ThanixClient, body: WritableCustomFieldChoiceSetRequest, id: i64) -> Result<ExtrasCustomFieldChoiceSetsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/custom-field-choice-sets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsUpdateResponse::Http200(r#response.json::<CustomFieldChoiceSet>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a custom field choice set object.
pub fn extras_custom_field_choice_sets_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasCustomFieldChoiceSetsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/custom-field-choice-sets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasCustomFieldChoiceSetsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsPartialUpdateResponse {
	Http200(CustomFieldChoiceSet),
	#[default]
	None
}
/// Patch a custom field choice set object.
pub fn extras_custom_field_choice_sets_partial_update(state: &ThanixClient, body: PatchedWritableCustomFieldChoiceSetRequest, id: i64) -> Result<ExtrasCustomFieldChoiceSetsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/custom-field-choice-sets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsPartialUpdateResponse::Http200(r#response.json::<CustomFieldChoiceSet>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldChoiceSetsChoicesRetrieveResponse {
	Http200(CustomFieldChoiceSet),
	#[default]
	None
}
/// Provides an endpoint to iterate through each choice in a set.
pub fn extras_custom_field_choice_sets_choices_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasCustomFieldChoiceSetsChoicesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-field-choice-sets/{id}/choices/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldChoiceSetsChoicesRetrieveResponse::Http200(r#response.json::<CustomFieldChoiceSet>()?)) },
		_ => { Ok(ExtrasCustomFieldChoiceSetsChoicesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasCustomFieldsListQuery {
	choice_set: Option<Vec<String>>,
	choice_set__n: Option<Vec<String>>,
	choice_set_id: Option<Vec<i64>>,
	choice_set_id__n: Option<Vec<i64>>,
	content_type_id: Option<Vec<i64>>,
	content_type_id__empty: Option<Vec<i64>>,
	content_type_id__gt: Option<Vec<i64>>,
	content_type_id__gte: Option<Vec<i64>>,
	content_type_id__lt: Option<Vec<i64>>,
	content_type_id__lte: Option<Vec<i64>>,
	content_type_id__n: Option<Vec<i64>>,
	content_types: Option<String>,
	content_types__ic: Option<String>,
	content_types__ie: Option<String>,
	content_types__iew: Option<String>,
	content_types__isw: Option<String>,
	content_types__n: Option<String>,
	content_types__nic: Option<String>,
	content_types__nie: Option<String>,
	content_types__niew: Option<String>,
	content_types__nisw: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Loose matches any instance of a given string; exact matches the entire field.
	filter_logic: Option<String>,
	/// Loose matches any instance of a given string; exact matches the entire field.
	filter_logic__n: Option<String>,
	group_name: Option<Vec<String>>,
	group_name__empty: Option<bool>,
	group_name__ic: Option<Vec<String>>,
	group_name__ie: Option<Vec<String>>,
	group_name__iew: Option<Vec<String>>,
	group_name__isw: Option<Vec<String>>,
	group_name__n: Option<Vec<String>>,
	group_name__nic: Option<Vec<String>>,
	group_name__nie: Option<Vec<String>>,
	group_name__niew: Option<Vec<String>>,
	group_name__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	is_cloneable: Option<bool>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	required: Option<bool>,
	search_weight: Option<Vec<i64>>,
	search_weight__empty: Option<bool>,
	search_weight__gt: Option<Vec<i64>>,
	search_weight__gte: Option<Vec<i64>>,
	search_weight__lt: Option<Vec<i64>>,
	search_weight__lte: Option<Vec<i64>>,
	search_weight__n: Option<Vec<i64>>,
	/// The type of data this custom field holds
	r#type: Option<Vec<String>>,
	/// The type of data this custom field holds
	type__n: Option<Vec<String>>,
	/// Specifies whether the custom field value can be edited in the UI
	ui_editable: Option<String>,
	/// Specifies whether the custom field value can be edited in the UI
	ui_editable__n: Option<String>,
	/// Specifies whether the custom field is displayed in the UI
	ui_visible: Option<String>,
	/// Specifies whether the custom field is displayed in the UI
	ui_visible__n: Option<String>,
	weight: Option<Vec<i64>>,
	weight__empty: Option<bool>,
	weight__gt: Option<Vec<i64>>,
	weight__gte: Option<Vec<i64>>,
	weight__lt: Option<Vec<i64>>,
	weight__lte: Option<Vec<i64>>,
	weight__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsListResponse {
	Http200(PaginatedCustomFieldList),
	#[default]
	None
}
/// Get a list of custom field objects.
pub fn extras_custom_fields_list(state: &ThanixClient, query: ExtrasCustomFieldsListQuery) -> Result<ExtrasCustomFieldsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-fields/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldsListResponse::Http200(r#response.json::<PaginatedCustomFieldList>()?)) },
		_ => { Ok(ExtrasCustomFieldsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsBulkUpdateResponse {
	Http200(Vec<CustomField>),
	#[default]
	None
}
/// Put a list of custom field objects.
pub fn extras_custom_fields_bulk_update(state: &ThanixClient, body: Vec<CustomFieldRequest>) -> Result<ExtrasCustomFieldsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/custom-fields/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldsBulkUpdateResponse::Http200(r#response.json::<Vec<CustomField>>()?)) },
		_ => { Ok(ExtrasCustomFieldsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsCreateResponse {
	Http201(CustomField),
	#[default]
	None
}
/// Post a list of custom field objects.
pub fn extras_custom_fields_create(state: &ThanixClient, body: WritableCustomFieldRequest) -> Result<ExtrasCustomFieldsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/custom-fields/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasCustomFieldsCreateResponse::Http201(r#response.json::<CustomField>()?)) },
		_ => { Ok(ExtrasCustomFieldsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of custom field objects.
pub fn extras_custom_fields_bulk_destroy(state: &ThanixClient, body: Vec<CustomFieldRequest>) -> Result<ExtrasCustomFieldsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/custom-fields/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasCustomFieldsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsBulkPartialUpdateResponse {
	Http200(Vec<CustomField>),
	#[default]
	None
}
/// Patch a list of custom field objects.
pub fn extras_custom_fields_bulk_partial_update(state: &ThanixClient, body: Vec<CustomFieldRequest>) -> Result<ExtrasCustomFieldsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/custom-fields/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<CustomField>>()?)) },
		_ => { Ok(ExtrasCustomFieldsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsRetrieveResponse {
	Http200(CustomField),
	#[default]
	None
}
/// Get a custom field object.
pub fn extras_custom_fields_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasCustomFieldsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-fields/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldsRetrieveResponse::Http200(r#response.json::<CustomField>()?)) },
		_ => { Ok(ExtrasCustomFieldsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsUpdateResponse {
	Http200(CustomField),
	#[default]
	None
}
/// Put a custom field object.
pub fn extras_custom_fields_update(state: &ThanixClient, body: WritableCustomFieldRequest, id: i64) -> Result<ExtrasCustomFieldsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/custom-fields/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldsUpdateResponse::Http200(r#response.json::<CustomField>()?)) },
		_ => { Ok(ExtrasCustomFieldsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a custom field object.
pub fn extras_custom_fields_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasCustomFieldsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/custom-fields/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasCustomFieldsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomFieldsPartialUpdateResponse {
	Http200(CustomField),
	#[default]
	None
}
/// Patch a custom field object.
pub fn extras_custom_fields_partial_update(state: &ThanixClient, body: PatchedWritableCustomFieldRequest, id: i64) -> Result<ExtrasCustomFieldsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/custom-fields/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomFieldsPartialUpdateResponse::Http200(r#response.json::<CustomField>()?)) },
		_ => { Ok(ExtrasCustomFieldsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasCustomLinksListQuery {
	content_type_id: Option<Vec<i64>>,
	content_type_id__empty: Option<Vec<i64>>,
	content_type_id__gt: Option<Vec<i64>>,
	content_type_id__gte: Option<Vec<i64>>,
	content_type_id__lt: Option<Vec<i64>>,
	content_type_id__lte: Option<Vec<i64>>,
	content_type_id__n: Option<Vec<i64>>,
	content_types: Option<String>,
	content_types__ic: Option<String>,
	content_types__ie: Option<String>,
	content_types__iew: Option<String>,
	content_types__isw: Option<String>,
	content_types__n: Option<String>,
	content_types__nic: Option<String>,
	content_types__nie: Option<String>,
	content_types__niew: Option<String>,
	content_types__nisw: Option<String>,
	enabled: Option<bool>,
	group_name: Option<Vec<String>>,
	group_name__empty: Option<bool>,
	group_name__ic: Option<Vec<String>>,
	group_name__ie: Option<Vec<String>>,
	group_name__iew: Option<Vec<String>>,
	group_name__isw: Option<Vec<String>>,
	group_name__n: Option<Vec<String>>,
	group_name__nic: Option<Vec<String>>,
	group_name__nie: Option<Vec<String>>,
	group_name__niew: Option<Vec<String>>,
	group_name__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	link_text: Option<String>,
	link_text__ic: Option<String>,
	link_text__ie: Option<String>,
	link_text__iew: Option<String>,
	link_text__isw: Option<String>,
	link_text__n: Option<String>,
	link_text__nic: Option<String>,
	link_text__nie: Option<String>,
	link_text__niew: Option<String>,
	link_text__nisw: Option<String>,
	link_url: Option<String>,
	link_url__ic: Option<String>,
	link_url__ie: Option<String>,
	link_url__iew: Option<String>,
	link_url__isw: Option<String>,
	link_url__n: Option<String>,
	link_url__nic: Option<String>,
	link_url__nie: Option<String>,
	link_url__niew: Option<String>,
	link_url__nisw: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	new_window: Option<bool>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	weight: Option<Vec<i64>>,
	weight__empty: Option<bool>,
	weight__gt: Option<Vec<i64>>,
	weight__gte: Option<Vec<i64>>,
	weight__lt: Option<Vec<i64>>,
	weight__lte: Option<Vec<i64>>,
	weight__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksListResponse {
	Http200(PaginatedCustomLinkList),
	#[default]
	None
}
/// Get a list of custom link objects.
pub fn extras_custom_links_list(state: &ThanixClient, query: ExtrasCustomLinksListQuery) -> Result<ExtrasCustomLinksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-links/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomLinksListResponse::Http200(r#response.json::<PaginatedCustomLinkList>()?)) },
		_ => { Ok(ExtrasCustomLinksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksBulkUpdateResponse {
	Http200(Vec<CustomLink>),
	#[default]
	None
}
/// Put a list of custom link objects.
pub fn extras_custom_links_bulk_update(state: &ThanixClient, body: Vec<CustomLinkRequest>) -> Result<ExtrasCustomLinksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/custom-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomLinksBulkUpdateResponse::Http200(r#response.json::<Vec<CustomLink>>()?)) },
		_ => { Ok(ExtrasCustomLinksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksCreateResponse {
	Http201(CustomLink),
	#[default]
	None
}
/// Post a list of custom link objects.
pub fn extras_custom_links_create(state: &ThanixClient, body: CustomLinkRequest) -> Result<ExtrasCustomLinksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/custom-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasCustomLinksCreateResponse::Http201(r#response.json::<CustomLink>()?)) },
		_ => { Ok(ExtrasCustomLinksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of custom link objects.
pub fn extras_custom_links_bulk_destroy(state: &ThanixClient, body: Vec<CustomLinkRequest>) -> Result<ExtrasCustomLinksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/custom-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasCustomLinksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksBulkPartialUpdateResponse {
	Http200(Vec<CustomLink>),
	#[default]
	None
}
/// Patch a list of custom link objects.
pub fn extras_custom_links_bulk_partial_update(state: &ThanixClient, body: Vec<CustomLinkRequest>) -> Result<ExtrasCustomLinksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/custom-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomLinksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<CustomLink>>()?)) },
		_ => { Ok(ExtrasCustomLinksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksRetrieveResponse {
	Http200(CustomLink),
	#[default]
	None
}
/// Get a custom link object.
pub fn extras_custom_links_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasCustomLinksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/custom-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomLinksRetrieveResponse::Http200(r#response.json::<CustomLink>()?)) },
		_ => { Ok(ExtrasCustomLinksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksUpdateResponse {
	Http200(CustomLink),
	#[default]
	None
}
/// Put a custom link object.
pub fn extras_custom_links_update(state: &ThanixClient, body: CustomLinkRequest, id: i64) -> Result<ExtrasCustomLinksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/custom-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomLinksUpdateResponse::Http200(r#response.json::<CustomLink>()?)) },
		_ => { Ok(ExtrasCustomLinksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a custom link object.
pub fn extras_custom_links_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasCustomLinksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/custom-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasCustomLinksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasCustomLinksPartialUpdateResponse {
	Http200(CustomLink),
	#[default]
	None
}
/// Patch a custom link object.
pub fn extras_custom_links_partial_update(state: &ThanixClient, body: PatchedCustomLinkRequest, id: i64) -> Result<ExtrasCustomLinksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/custom-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasCustomLinksPartialUpdateResponse::Http200(r#response.json::<CustomLink>()?)) },
		_ => { Ok(ExtrasCustomLinksPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasDashboardRetrieveResponse {
	Http200(Dashboard),
	#[default]
	None
}
/// Get a list of dashboard objects.
pub fn extras_dashboard_retrieve(state: &ThanixClient) -> Result<ExtrasDashboardRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/dashboard/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasDashboardRetrieveResponse::Http200(r#response.json::<Dashboard>()?)) },
		_ => { Ok(ExtrasDashboardRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasDashboardUpdateResponse {
	Http200(Dashboard),
	#[default]
	None
}
/// Put a list of dashboard objects.
pub fn extras_dashboard_update(state: &ThanixClient, body: DashboardRequest) -> Result<ExtrasDashboardUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/dashboard/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasDashboardUpdateResponse::Http200(r#response.json::<Dashboard>()?)) },
		_ => { Ok(ExtrasDashboardUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasDashboardDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of dashboard objects.
pub fn extras_dashboard_destroy(state: &ThanixClient) -> Result<ExtrasDashboardDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/dashboard/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasDashboardDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasDashboardPartialUpdateResponse {
	Http200(Dashboard),
	#[default]
	None
}
/// Patch a list of dashboard objects.
pub fn extras_dashboard_partial_update(state: &ThanixClient, body: PatchedDashboardRequest) -> Result<ExtrasDashboardPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/dashboard/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasDashboardPartialUpdateResponse::Http200(r#response.json::<Dashboard>()?)) },
		_ => { Ok(ExtrasDashboardPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasEventRulesListQuery {
	action_object_id: Option<Vec<i64>>,
	action_object_id__empty: Option<Vec<i64>>,
	action_object_id__gt: Option<Vec<i64>>,
	action_object_id__gte: Option<Vec<i64>>,
	action_object_id__lt: Option<Vec<i64>>,
	action_object_id__lte: Option<Vec<i64>>,
	action_object_id__n: Option<Vec<i64>>,
	action_object_type: Option<String>,
	action_object_type__n: Option<String>,
	action_type: Option<Vec<String>>,
	action_type__n: Option<Vec<String>>,
	content_type_id: Option<Vec<i64>>,
	content_type_id__empty: Option<Vec<i64>>,
	content_type_id__gt: Option<Vec<i64>>,
	content_type_id__gte: Option<Vec<i64>>,
	content_type_id__lt: Option<Vec<i64>>,
	content_type_id__lte: Option<Vec<i64>>,
	content_type_id__n: Option<Vec<i64>>,
	content_types: Option<String>,
	content_types__ic: Option<String>,
	content_types__ie: Option<String>,
	content_types__iew: Option<String>,
	content_types__isw: Option<String>,
	content_types__n: Option<String>,
	content_types__nic: Option<String>,
	content_types__nie: Option<String>,
	content_types__niew: Option<String>,
	content_types__nisw: Option<String>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	enabled: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	type_create: Option<bool>,
	type_delete: Option<bool>,
	type_job_end: Option<bool>,
	type_job_start: Option<bool>,
	type_update: Option<bool>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesListResponse {
	Http200(PaginatedEventRuleList),
	#[default]
	None
}
/// Get a list of event rule objects.
pub fn extras_event_rules_list(state: &ThanixClient, query: ExtrasEventRulesListQuery) -> Result<ExtrasEventRulesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/event-rules/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasEventRulesListResponse::Http200(r#response.json::<PaginatedEventRuleList>()?)) },
		_ => { Ok(ExtrasEventRulesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesBulkUpdateResponse {
	Http200(Vec<EventRule>),
	#[default]
	None
}
/// Put a list of event rule objects.
pub fn extras_event_rules_bulk_update(state: &ThanixClient, body: Vec<EventRuleRequest>) -> Result<ExtrasEventRulesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/event-rules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasEventRulesBulkUpdateResponse::Http200(r#response.json::<Vec<EventRule>>()?)) },
		_ => { Ok(ExtrasEventRulesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesCreateResponse {
	Http201(EventRule),
	#[default]
	None
}
/// Post a list of event rule objects.
pub fn extras_event_rules_create(state: &ThanixClient, body: WritableEventRuleRequest) -> Result<ExtrasEventRulesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/event-rules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasEventRulesCreateResponse::Http201(r#response.json::<EventRule>()?)) },
		_ => { Ok(ExtrasEventRulesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of event rule objects.
pub fn extras_event_rules_bulk_destroy(state: &ThanixClient, body: Vec<EventRuleRequest>) -> Result<ExtrasEventRulesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/event-rules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasEventRulesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesBulkPartialUpdateResponse {
	Http200(Vec<EventRule>),
	#[default]
	None
}
/// Patch a list of event rule objects.
pub fn extras_event_rules_bulk_partial_update(state: &ThanixClient, body: Vec<EventRuleRequest>) -> Result<ExtrasEventRulesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/event-rules/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasEventRulesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<EventRule>>()?)) },
		_ => { Ok(ExtrasEventRulesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesRetrieveResponse {
	Http200(EventRule),
	#[default]
	None
}
/// Get a event rule object.
pub fn extras_event_rules_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasEventRulesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/event-rules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasEventRulesRetrieveResponse::Http200(r#response.json::<EventRule>()?)) },
		_ => { Ok(ExtrasEventRulesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesUpdateResponse {
	Http200(EventRule),
	#[default]
	None
}
/// Put a event rule object.
pub fn extras_event_rules_update(state: &ThanixClient, body: WritableEventRuleRequest, id: i64) -> Result<ExtrasEventRulesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/event-rules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasEventRulesUpdateResponse::Http200(r#response.json::<EventRule>()?)) },
		_ => { Ok(ExtrasEventRulesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a event rule object.
pub fn extras_event_rules_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasEventRulesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/event-rules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasEventRulesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasEventRulesPartialUpdateResponse {
	Http200(EventRule),
	#[default]
	None
}
/// Patch a event rule object.
pub fn extras_event_rules_partial_update(state: &ThanixClient, body: PatchedWritableEventRuleRequest, id: i64) -> Result<ExtrasEventRulesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/event-rules/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasEventRulesPartialUpdateResponse::Http200(r#response.json::<EventRule>()?)) },
		_ => { Ok(ExtrasEventRulesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasExportTemplatesListQuery {
	content_type_id: Option<Vec<i64>>,
	content_type_id__empty: Option<Vec<i64>>,
	content_type_id__gt: Option<Vec<i64>>,
	content_type_id__gte: Option<Vec<i64>>,
	content_type_id__lt: Option<Vec<i64>>,
	content_type_id__lte: Option<Vec<i64>>,
	content_type_id__n: Option<Vec<i64>>,
	content_types: Option<String>,
	content_types__ic: Option<String>,
	content_types__ie: Option<String>,
	content_types__iew: Option<String>,
	content_types__isw: Option<String>,
	content_types__n: Option<String>,
	content_types__nic: Option<String>,
	content_types__nie: Option<String>,
	content_types__niew: Option<String>,
	content_types__nisw: Option<String>,
	/// Data file (ID)
	data_file_id: Option<Vec<i64>>,
	/// Data file (ID)
	data_file_id__n: Option<Vec<i64>>,
	/// Data source (ID)
	data_source_id: Option<Vec<i64>>,
	/// Data source (ID)
	data_source_id__n: Option<Vec<i64>>,
	data_synced: Option<Vec<String>>,
	data_synced__empty: Option<bool>,
	data_synced__gt: Option<Vec<String>>,
	data_synced__gte: Option<Vec<String>>,
	data_synced__lt: Option<Vec<String>>,
	data_synced__lte: Option<Vec<String>>,
	data_synced__n: Option<Vec<String>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesListResponse {
	Http200(PaginatedExportTemplateList),
	#[default]
	None
}
/// Get a list of export template objects.
pub fn extras_export_templates_list(state: &ThanixClient, query: ExtrasExportTemplatesListQuery) -> Result<ExtrasExportTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/export-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesListResponse::Http200(r#response.json::<PaginatedExportTemplateList>()?)) },
		_ => { Ok(ExtrasExportTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesBulkUpdateResponse {
	Http200(Vec<ExportTemplate>),
	#[default]
	None
}
/// Put a list of export template objects.
pub fn extras_export_templates_bulk_update(state: &ThanixClient, body: Vec<ExportTemplateRequest>) -> Result<ExtrasExportTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/export-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<ExportTemplate>>()?)) },
		_ => { Ok(ExtrasExportTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesCreateResponse {
	Http201(ExportTemplate),
	#[default]
	None
}
/// Post a list of export template objects.
pub fn extras_export_templates_create(state: &ThanixClient, body: WritableExportTemplateRequest) -> Result<ExtrasExportTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/export-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasExportTemplatesCreateResponse::Http201(r#response.json::<ExportTemplate>()?)) },
		_ => { Ok(ExtrasExportTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of export template objects.
pub fn extras_export_templates_bulk_destroy(state: &ThanixClient, body: Vec<ExportTemplateRequest>) -> Result<ExtrasExportTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/export-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasExportTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesBulkPartialUpdateResponse {
	Http200(Vec<ExportTemplate>),
	#[default]
	None
}
/// Patch a list of export template objects.
pub fn extras_export_templates_bulk_partial_update(state: &ThanixClient, body: Vec<ExportTemplateRequest>) -> Result<ExtrasExportTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/export-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ExportTemplate>>()?)) },
		_ => { Ok(ExtrasExportTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesRetrieveResponse {
	Http200(ExportTemplate),
	#[default]
	None
}
/// Get a export template object.
pub fn extras_export_templates_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasExportTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/export-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesRetrieveResponse::Http200(r#response.json::<ExportTemplate>()?)) },
		_ => { Ok(ExtrasExportTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesUpdateResponse {
	Http200(ExportTemplate),
	#[default]
	None
}
/// Put a export template object.
pub fn extras_export_templates_update(state: &ThanixClient, body: WritableExportTemplateRequest, id: i64) -> Result<ExtrasExportTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/export-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesUpdateResponse::Http200(r#response.json::<ExportTemplate>()?)) },
		_ => { Ok(ExtrasExportTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a export template object.
pub fn extras_export_templates_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasExportTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/export-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasExportTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesPartialUpdateResponse {
	Http200(ExportTemplate),
	#[default]
	None
}
/// Patch a export template object.
pub fn extras_export_templates_partial_update(state: &ThanixClient, body: PatchedWritableExportTemplateRequest, id: i64) -> Result<ExtrasExportTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/export-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesPartialUpdateResponse::Http200(r#response.json::<ExportTemplate>()?)) },
		_ => { Ok(ExtrasExportTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasExportTemplatesSyncCreateResponse {
	Http200(ExportTemplate),
	#[default]
	None
}
/// Provide a /sync API endpoint to synchronize an object's data from its associated DataFile (if any).
pub fn extras_export_templates_sync_create(state: &ThanixClient, body: WritableExportTemplateRequest, id: i64) -> Result<ExtrasExportTemplatesSyncCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/export-templates/{id}/sync/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasExportTemplatesSyncCreateResponse::Http200(r#response.json::<ExportTemplate>()?)) },
		_ => { Ok(ExtrasExportTemplatesSyncCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasImageAttachmentsListQuery {
	content_type: Option<String>,
	content_type__n: Option<String>,
	content_type_id: Option<i64>,
	content_type_id__n: Option<i64>,
	created: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	object_id: Option<Vec<i64>>,
	object_id__empty: Option<bool>,
	object_id__gt: Option<Vec<i64>>,
	object_id__gte: Option<Vec<i64>>,
	object_id__lt: Option<Vec<i64>>,
	object_id__lte: Option<Vec<i64>>,
	object_id__n: Option<Vec<i64>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsListResponse {
	Http200(PaginatedImageAttachmentList),
	#[default]
	None
}
/// Get a list of image attachment objects.
pub fn extras_image_attachments_list(state: &ThanixClient, query: ExtrasImageAttachmentsListQuery) -> Result<ExtrasImageAttachmentsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/image-attachments/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasImageAttachmentsListResponse::Http200(r#response.json::<PaginatedImageAttachmentList>()?)) },
		_ => { Ok(ExtrasImageAttachmentsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsBulkUpdateResponse {
	Http200(Vec<ImageAttachment>),
	#[default]
	None
}
/// Put a list of image attachment objects.
pub fn extras_image_attachments_bulk_update(state: &ThanixClient, body: Vec<ImageAttachmentRequest>) -> Result<ExtrasImageAttachmentsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/image-attachments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasImageAttachmentsBulkUpdateResponse::Http200(r#response.json::<Vec<ImageAttachment>>()?)) },
		_ => { Ok(ExtrasImageAttachmentsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsCreateResponse {
	Http201(ImageAttachment),
	#[default]
	None
}
/// Post a list of image attachment objects.
pub fn extras_image_attachments_create(state: &ThanixClient, body: ImageAttachmentRequest) -> Result<ExtrasImageAttachmentsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/image-attachments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasImageAttachmentsCreateResponse::Http201(r#response.json::<ImageAttachment>()?)) },
		_ => { Ok(ExtrasImageAttachmentsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of image attachment objects.
pub fn extras_image_attachments_bulk_destroy(state: &ThanixClient, body: Vec<ImageAttachmentRequest>) -> Result<ExtrasImageAttachmentsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/image-attachments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasImageAttachmentsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsBulkPartialUpdateResponse {
	Http200(Vec<ImageAttachment>),
	#[default]
	None
}
/// Patch a list of image attachment objects.
pub fn extras_image_attachments_bulk_partial_update(state: &ThanixClient, body: Vec<ImageAttachmentRequest>) -> Result<ExtrasImageAttachmentsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/image-attachments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasImageAttachmentsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ImageAttachment>>()?)) },
		_ => { Ok(ExtrasImageAttachmentsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsRetrieveResponse {
	Http200(ImageAttachment),
	#[default]
	None
}
/// Get a image attachment object.
pub fn extras_image_attachments_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasImageAttachmentsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/image-attachments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasImageAttachmentsRetrieveResponse::Http200(r#response.json::<ImageAttachment>()?)) },
		_ => { Ok(ExtrasImageAttachmentsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsUpdateResponse {
	Http200(ImageAttachment),
	#[default]
	None
}
/// Put a image attachment object.
pub fn extras_image_attachments_update(state: &ThanixClient, body: ImageAttachmentRequest, id: i64) -> Result<ExtrasImageAttachmentsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/image-attachments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasImageAttachmentsUpdateResponse::Http200(r#response.json::<ImageAttachment>()?)) },
		_ => { Ok(ExtrasImageAttachmentsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a image attachment object.
pub fn extras_image_attachments_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasImageAttachmentsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/image-attachments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasImageAttachmentsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasImageAttachmentsPartialUpdateResponse {
	Http200(ImageAttachment),
	#[default]
	None
}
/// Patch a image attachment object.
pub fn extras_image_attachments_partial_update(state: &ThanixClient, body: PatchedImageAttachmentRequest, id: i64) -> Result<ExtrasImageAttachmentsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/image-attachments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasImageAttachmentsPartialUpdateResponse::Http200(r#response.json::<ImageAttachment>()?)) },
		_ => { Ok(ExtrasImageAttachmentsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasJournalEntriesListQuery {
	assigned_object_id: Option<Vec<i64>>,
	assigned_object_id__empty: Option<bool>,
	assigned_object_id__gt: Option<Vec<i64>>,
	assigned_object_id__gte: Option<Vec<i64>>,
	assigned_object_id__lt: Option<Vec<i64>>,
	assigned_object_id__lte: Option<Vec<i64>>,
	assigned_object_id__n: Option<Vec<i64>>,
	assigned_object_type: Option<String>,
	assigned_object_type__n: Option<String>,
	assigned_object_type_id: Option<Vec<i64>>,
	assigned_object_type_id__n: Option<Vec<i64>>,
	created_after: Option<String>,
	created_before: Option<String>,
	/// User (name)
	created_by: Option<Vec<String>>,
	/// User (name)
	created_by__n: Option<Vec<String>>,
	/// User (ID)
	created_by_id: Option<Vec<i64>>,
	/// User (ID)
	created_by_id__n: Option<Vec<i64>>,
	created_by_request: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	kind: Option<Vec<String>>,
	kind__n: Option<Vec<String>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesListResponse {
	Http200(PaginatedJournalEntryList),
	#[default]
	None
}
/// Get a list of journal entry objects.
pub fn extras_journal_entries_list(state: &ThanixClient, query: ExtrasJournalEntriesListQuery) -> Result<ExtrasJournalEntriesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/journal-entries/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasJournalEntriesListResponse::Http200(r#response.json::<PaginatedJournalEntryList>()?)) },
		_ => { Ok(ExtrasJournalEntriesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesBulkUpdateResponse {
	Http200(Vec<JournalEntry>),
	#[default]
	None
}
/// Put a list of journal entry objects.
pub fn extras_journal_entries_bulk_update(state: &ThanixClient, body: Vec<JournalEntryRequest>) -> Result<ExtrasJournalEntriesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/journal-entries/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasJournalEntriesBulkUpdateResponse::Http200(r#response.json::<Vec<JournalEntry>>()?)) },
		_ => { Ok(ExtrasJournalEntriesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesCreateResponse {
	Http201(JournalEntry),
	#[default]
	None
}
/// Post a list of journal entry objects.
pub fn extras_journal_entries_create(state: &ThanixClient, body: WritableJournalEntryRequest) -> Result<ExtrasJournalEntriesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/journal-entries/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasJournalEntriesCreateResponse::Http201(r#response.json::<JournalEntry>()?)) },
		_ => { Ok(ExtrasJournalEntriesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of journal entry objects.
pub fn extras_journal_entries_bulk_destroy(state: &ThanixClient, body: Vec<JournalEntryRequest>) -> Result<ExtrasJournalEntriesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/journal-entries/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasJournalEntriesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesBulkPartialUpdateResponse {
	Http200(Vec<JournalEntry>),
	#[default]
	None
}
/// Patch a list of journal entry objects.
pub fn extras_journal_entries_bulk_partial_update(state: &ThanixClient, body: Vec<JournalEntryRequest>) -> Result<ExtrasJournalEntriesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/journal-entries/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasJournalEntriesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<JournalEntry>>()?)) },
		_ => { Ok(ExtrasJournalEntriesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesRetrieveResponse {
	Http200(JournalEntry),
	#[default]
	None
}
/// Get a journal entry object.
pub fn extras_journal_entries_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasJournalEntriesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/journal-entries/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasJournalEntriesRetrieveResponse::Http200(r#response.json::<JournalEntry>()?)) },
		_ => { Ok(ExtrasJournalEntriesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesUpdateResponse {
	Http200(JournalEntry),
	#[default]
	None
}
/// Put a journal entry object.
pub fn extras_journal_entries_update(state: &ThanixClient, body: WritableJournalEntryRequest, id: i64) -> Result<ExtrasJournalEntriesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/journal-entries/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasJournalEntriesUpdateResponse::Http200(r#response.json::<JournalEntry>()?)) },
		_ => { Ok(ExtrasJournalEntriesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a journal entry object.
pub fn extras_journal_entries_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasJournalEntriesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/journal-entries/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasJournalEntriesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasJournalEntriesPartialUpdateResponse {
	Http200(JournalEntry),
	#[default]
	None
}
/// Patch a journal entry object.
pub fn extras_journal_entries_partial_update(state: &ThanixClient, body: PatchedWritableJournalEntryRequest, id: i64) -> Result<ExtrasJournalEntriesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/journal-entries/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasJournalEntriesPartialUpdateResponse::Http200(r#response.json::<JournalEntry>()?)) },
		_ => { Ok(ExtrasJournalEntriesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasObjectChangesListQuery {
	action: Option<String>,
	action__n: Option<String>,
	changed_object_id: Option<Vec<i64>>,
	changed_object_id__empty: Option<bool>,
	changed_object_id__gt: Option<Vec<i64>>,
	changed_object_id__gte: Option<Vec<i64>>,
	changed_object_id__lt: Option<Vec<i64>>,
	changed_object_id__lte: Option<Vec<i64>>,
	changed_object_id__n: Option<Vec<i64>>,
	changed_object_type: Option<String>,
	changed_object_type__n: Option<String>,
	changed_object_type_id: Option<Vec<i64>>,
	changed_object_type_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	object_repr: Option<Vec<String>>,
	object_repr__empty: Option<bool>,
	object_repr__ic: Option<Vec<String>>,
	object_repr__ie: Option<Vec<String>>,
	object_repr__iew: Option<Vec<String>>,
	object_repr__isw: Option<Vec<String>>,
	object_repr__n: Option<Vec<String>>,
	object_repr__nic: Option<Vec<String>>,
	object_repr__nie: Option<Vec<String>>,
	object_repr__niew: Option<Vec<String>>,
	object_repr__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	request_id: Option<String>,
	time_after: Option<String>,
	time_before: Option<String>,
	/// User name
	user: Option<Vec<String>>,
	/// User name
	user__n: Option<Vec<String>>,
	/// User (ID)
	user_id: Option<Vec<i64>>,
	/// User (ID)
	user_id__n: Option<Vec<i64>>,
	user_name: Option<Vec<String>>,
	user_name__empty: Option<bool>,
	user_name__ic: Option<Vec<String>>,
	user_name__ie: Option<Vec<String>>,
	user_name__iew: Option<Vec<String>>,
	user_name__isw: Option<Vec<String>>,
	user_name__n: Option<Vec<String>>,
	user_name__nic: Option<Vec<String>>,
	user_name__nie: Option<Vec<String>>,
	user_name__niew: Option<Vec<String>>,
	user_name__nisw: Option<Vec<String>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasObjectChangesListResponse {
	Http200(PaginatedObjectChangeList),
	#[default]
	None
}
/// Retrieve a list of recent changes.
pub fn extras_object_changes_list(state: &ThanixClient, query: ExtrasObjectChangesListQuery) -> Result<ExtrasObjectChangesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/object-changes/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasObjectChangesListResponse::Http200(r#response.json::<PaginatedObjectChangeList>()?)) },
		_ => { Ok(ExtrasObjectChangesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasObjectChangesRetrieveResponse {
	Http200(ObjectChange),
	#[default]
	None
}
/// Retrieve a list of recent changes.
pub fn extras_object_changes_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasObjectChangesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/object-changes/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasObjectChangesRetrieveResponse::Http200(r#response.json::<ObjectChange>()?)) },
		_ => { Ok(ExtrasObjectChangesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasSavedFiltersListQuery {
	content_type_id: Option<Vec<i64>>,
	content_type_id__empty: Option<Vec<i64>>,
	content_type_id__gt: Option<Vec<i64>>,
	content_type_id__gte: Option<Vec<i64>>,
	content_type_id__lt: Option<Vec<i64>>,
	content_type_id__lte: Option<Vec<i64>>,
	content_type_id__n: Option<Vec<i64>>,
	content_types: Option<String>,
	content_types__ic: Option<String>,
	content_types__ie: Option<String>,
	content_types__iew: Option<String>,
	content_types__isw: Option<String>,
	content_types__n: Option<String>,
	content_types__nic: Option<String>,
	content_types__nie: Option<String>,
	content_types__niew: Option<String>,
	content_types__nisw: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	enabled: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	shared: Option<bool>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	usable: Option<bool>,
	/// User (name)
	user: Option<Vec<String>>,
	/// User (name)
	user__n: Option<Vec<String>>,
	/// User (ID)
	user_id: Option<Vec<i64>>,
	/// User (ID)
	user_id__n: Option<Vec<i64>>,
	weight: Option<Vec<i64>>,
	weight__empty: Option<bool>,
	weight__gt: Option<Vec<i64>>,
	weight__gte: Option<Vec<i64>>,
	weight__lt: Option<Vec<i64>>,
	weight__lte: Option<Vec<i64>>,
	weight__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersListResponse {
	Http200(PaginatedSavedFilterList),
	#[default]
	None
}
/// Get a list of saved filter objects.
pub fn extras_saved_filters_list(state: &ThanixClient, query: ExtrasSavedFiltersListQuery) -> Result<ExtrasSavedFiltersListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/saved-filters/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasSavedFiltersListResponse::Http200(r#response.json::<PaginatedSavedFilterList>()?)) },
		_ => { Ok(ExtrasSavedFiltersListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersBulkUpdateResponse {
	Http200(Vec<SavedFilter>),
	#[default]
	None
}
/// Put a list of saved filter objects.
pub fn extras_saved_filters_bulk_update(state: &ThanixClient, body: Vec<SavedFilterRequest>) -> Result<ExtrasSavedFiltersBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/saved-filters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasSavedFiltersBulkUpdateResponse::Http200(r#response.json::<Vec<SavedFilter>>()?)) },
		_ => { Ok(ExtrasSavedFiltersBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersCreateResponse {
	Http201(SavedFilter),
	#[default]
	None
}
/// Post a list of saved filter objects.
pub fn extras_saved_filters_create(state: &ThanixClient, body: SavedFilterRequest) -> Result<ExtrasSavedFiltersCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/saved-filters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasSavedFiltersCreateResponse::Http201(r#response.json::<SavedFilter>()?)) },
		_ => { Ok(ExtrasSavedFiltersCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of saved filter objects.
pub fn extras_saved_filters_bulk_destroy(state: &ThanixClient, body: Vec<SavedFilterRequest>) -> Result<ExtrasSavedFiltersBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/saved-filters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasSavedFiltersBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersBulkPartialUpdateResponse {
	Http200(Vec<SavedFilter>),
	#[default]
	None
}
/// Patch a list of saved filter objects.
pub fn extras_saved_filters_bulk_partial_update(state: &ThanixClient, body: Vec<SavedFilterRequest>) -> Result<ExtrasSavedFiltersBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/saved-filters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasSavedFiltersBulkPartialUpdateResponse::Http200(r#response.json::<Vec<SavedFilter>>()?)) },
		_ => { Ok(ExtrasSavedFiltersBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersRetrieveResponse {
	Http200(SavedFilter),
	#[default]
	None
}
/// Get a saved filter object.
pub fn extras_saved_filters_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasSavedFiltersRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/saved-filters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasSavedFiltersRetrieveResponse::Http200(r#response.json::<SavedFilter>()?)) },
		_ => { Ok(ExtrasSavedFiltersRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersUpdateResponse {
	Http200(SavedFilter),
	#[default]
	None
}
/// Put a saved filter object.
pub fn extras_saved_filters_update(state: &ThanixClient, body: SavedFilterRequest, id: i64) -> Result<ExtrasSavedFiltersUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/saved-filters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasSavedFiltersUpdateResponse::Http200(r#response.json::<SavedFilter>()?)) },
		_ => { Ok(ExtrasSavedFiltersUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a saved filter object.
pub fn extras_saved_filters_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasSavedFiltersDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/saved-filters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasSavedFiltersDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasSavedFiltersPartialUpdateResponse {
	Http200(SavedFilter),
	#[default]
	None
}
/// Patch a saved filter object.
pub fn extras_saved_filters_partial_update(state: &ThanixClient, body: PatchedSavedFilterRequest, id: i64) -> Result<ExtrasSavedFiltersPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/saved-filters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasSavedFiltersPartialUpdateResponse::Http200(r#response.json::<SavedFilter>()?)) },
		_ => { Ok(ExtrasSavedFiltersPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasTagsListQuery {
	color: Option<Vec<String>>,
	color__empty: Option<bool>,
	color__ic: Option<Vec<String>>,
	color__ie: Option<Vec<String>>,
	color__iew: Option<Vec<String>>,
	color__isw: Option<Vec<String>>,
	color__n: Option<Vec<String>>,
	color__nic: Option<Vec<String>>,
	color__nie: Option<Vec<String>>,
	color__niew: Option<Vec<String>>,
	color__nisw: Option<Vec<String>>,
	content_type: Option<Vec<String>>,
	content_type_id: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	for_object_type_id: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	object_types: Option<Vec<i64>>,
	object_types__n: Option<Vec<i64>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsListResponse {
	Http200(PaginatedTagList),
	#[default]
	None
}
/// Get a list of tag objects.
pub fn extras_tags_list(state: &ThanixClient, query: ExtrasTagsListQuery) -> Result<ExtrasTagsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/tags/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasTagsListResponse::Http200(r#response.json::<PaginatedTagList>()?)) },
		_ => { Ok(ExtrasTagsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsBulkUpdateResponse {
	Http200(Vec<Tag>),
	#[default]
	None
}
/// Put a list of tag objects.
pub fn extras_tags_bulk_update(state: &ThanixClient, body: Vec<TagRequest>) -> Result<ExtrasTagsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/tags/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasTagsBulkUpdateResponse::Http200(r#response.json::<Vec<Tag>>()?)) },
		_ => { Ok(ExtrasTagsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsCreateResponse {
	Http201(Tag),
	#[default]
	None
}
/// Post a list of tag objects.
pub fn extras_tags_create(state: &ThanixClient, body: TagRequest) -> Result<ExtrasTagsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/tags/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasTagsCreateResponse::Http201(r#response.json::<Tag>()?)) },
		_ => { Ok(ExtrasTagsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of tag objects.
pub fn extras_tags_bulk_destroy(state: &ThanixClient, body: Vec<TagRequest>) -> Result<ExtrasTagsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/tags/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasTagsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsBulkPartialUpdateResponse {
	Http200(Vec<Tag>),
	#[default]
	None
}
/// Patch a list of tag objects.
pub fn extras_tags_bulk_partial_update(state: &ThanixClient, body: Vec<TagRequest>) -> Result<ExtrasTagsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/tags/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasTagsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Tag>>()?)) },
		_ => { Ok(ExtrasTagsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsRetrieveResponse {
	Http200(Tag),
	#[default]
	None
}
/// Get a tag object.
pub fn extras_tags_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasTagsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/tags/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasTagsRetrieveResponse::Http200(r#response.json::<Tag>()?)) },
		_ => { Ok(ExtrasTagsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsUpdateResponse {
	Http200(Tag),
	#[default]
	None
}
/// Put a tag object.
pub fn extras_tags_update(state: &ThanixClient, body: TagRequest, id: i64) -> Result<ExtrasTagsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/tags/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasTagsUpdateResponse::Http200(r#response.json::<Tag>()?)) },
		_ => { Ok(ExtrasTagsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a tag object.
pub fn extras_tags_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasTagsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/tags/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasTagsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasTagsPartialUpdateResponse {
	Http200(Tag),
	#[default]
	None
}
/// Patch a tag object.
pub fn extras_tags_partial_update(state: &ThanixClient, body: PatchedTagRequest, id: i64) -> Result<ExtrasTagsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/tags/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasTagsPartialUpdateResponse::Http200(r#response.json::<Tag>()?)) },
		_ => { Ok(ExtrasTagsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct ExtrasWebhooksListQuery {
	ca_file_path: Option<Vec<String>>,
	ca_file_path__empty: Option<bool>,
	ca_file_path__ic: Option<Vec<String>>,
	ca_file_path__ie: Option<Vec<String>>,
	ca_file_path__iew: Option<Vec<String>>,
	ca_file_path__isw: Option<Vec<String>>,
	ca_file_path__n: Option<Vec<String>>,
	ca_file_path__nic: Option<Vec<String>>,
	ca_file_path__nie: Option<Vec<String>>,
	ca_file_path__niew: Option<Vec<String>>,
	ca_file_path__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	http_content_type: Option<Vec<String>>,
	http_content_type__empty: Option<bool>,
	http_content_type__ic: Option<Vec<String>>,
	http_content_type__ie: Option<Vec<String>>,
	http_content_type__iew: Option<Vec<String>>,
	http_content_type__isw: Option<Vec<String>>,
	http_content_type__n: Option<Vec<String>>,
	http_content_type__nic: Option<Vec<String>>,
	http_content_type__nie: Option<Vec<String>>,
	http_content_type__niew: Option<Vec<String>>,
	http_content_type__nisw: Option<Vec<String>>,
	http_method: Option<Vec<String>>,
	http_method__n: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	payload_url: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	secret: Option<Vec<String>>,
	secret__empty: Option<bool>,
	secret__ic: Option<Vec<String>>,
	secret__ie: Option<Vec<String>>,
	secret__iew: Option<Vec<String>>,
	secret__isw: Option<Vec<String>>,
	secret__n: Option<Vec<String>>,
	secret__nic: Option<Vec<String>>,
	secret__nie: Option<Vec<String>>,
	secret__niew: Option<Vec<String>>,
	secret__nisw: Option<Vec<String>>,
	ssl_verification: Option<bool>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksListResponse {
	Http200(PaginatedWebhookList),
	#[default]
	None
}
/// Get a list of webhook objects.
pub fn extras_webhooks_list(state: &ThanixClient, query: ExtrasWebhooksListQuery) -> Result<ExtrasWebhooksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/webhooks/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasWebhooksListResponse::Http200(r#response.json::<PaginatedWebhookList>()?)) },
		_ => { Ok(ExtrasWebhooksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksBulkUpdateResponse {
	Http200(Vec<Webhook>),
	#[default]
	None
}
/// Put a list of webhook objects.
pub fn extras_webhooks_bulk_update(state: &ThanixClient, body: Vec<WebhookRequest>) -> Result<ExtrasWebhooksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/webhooks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasWebhooksBulkUpdateResponse::Http200(r#response.json::<Vec<Webhook>>()?)) },
		_ => { Ok(ExtrasWebhooksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksCreateResponse {
	Http201(Webhook),
	#[default]
	None
}
/// Post a list of webhook objects.
pub fn extras_webhooks_create(state: &ThanixClient, body: WebhookRequest) -> Result<ExtrasWebhooksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/extras/webhooks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(ExtrasWebhooksCreateResponse::Http201(r#response.json::<Webhook>()?)) },
		_ => { Ok(ExtrasWebhooksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of webhook objects.
pub fn extras_webhooks_bulk_destroy(state: &ThanixClient, body: Vec<WebhookRequest>) -> Result<ExtrasWebhooksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/webhooks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasWebhooksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksBulkPartialUpdateResponse {
	Http200(Vec<Webhook>),
	#[default]
	None
}
/// Patch a list of webhook objects.
pub fn extras_webhooks_bulk_partial_update(state: &ThanixClient, body: Vec<WebhookRequest>) -> Result<ExtrasWebhooksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/webhooks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasWebhooksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Webhook>>()?)) },
		_ => { Ok(ExtrasWebhooksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksRetrieveResponse {
	Http200(Webhook),
	#[default]
	None
}
/// Get a webhook object.
pub fn extras_webhooks_retrieve(state: &ThanixClient, id: i64) -> Result<ExtrasWebhooksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/extras/webhooks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasWebhooksRetrieveResponse::Http200(r#response.json::<Webhook>()?)) },
		_ => { Ok(ExtrasWebhooksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksUpdateResponse {
	Http200(Webhook),
	#[default]
	None
}
/// Put a webhook object.
pub fn extras_webhooks_update(state: &ThanixClient, body: WebhookRequest, id: i64) -> Result<ExtrasWebhooksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/extras/webhooks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasWebhooksUpdateResponse::Http200(r#response.json::<Webhook>()?)) },
		_ => { Ok(ExtrasWebhooksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a webhook object.
pub fn extras_webhooks_destroy(state: &ThanixClient, id: i64) -> Result<ExtrasWebhooksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/extras/webhooks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(ExtrasWebhooksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum ExtrasWebhooksPartialUpdateResponse {
	Http200(Webhook),
	#[default]
	None
}
/// Patch a webhook object.
pub fn extras_webhooks_partial_update(state: &ThanixClient, body: PatchedWebhookRequest, id: i64) -> Result<ExtrasWebhooksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/extras/webhooks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(ExtrasWebhooksPartialUpdateResponse::Http200(r#response.json::<Webhook>()?)) },
		_ => { Ok(ExtrasWebhooksPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamAggregatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	date_added: Option<Vec<String>>,
	date_added__empty: Option<bool>,
	date_added__gt: Option<Vec<String>>,
	date_added__gte: Option<Vec<String>>,
	date_added__lt: Option<Vec<String>>,
	date_added__lte: Option<Vec<String>>,
	date_added__n: Option<Vec<String>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	family: Option<f64>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Prefix
	prefix: Option<String>,
	/// Search
	q: Option<String>,
	/// RIR (slug)
	rir: Option<Vec<String>>,
	/// RIR (slug)
	rir__n: Option<Vec<String>>,
	/// RIR (ID)
	rir_id: Option<Vec<i64>>,
	/// RIR (ID)
	rir_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesListResponse {
	Http200(PaginatedAggregateList),
	#[default]
	None
}
/// Get a list of aggregate objects.
pub fn ipam_aggregates_list(state: &ThanixClient, query: IpamAggregatesListQuery) -> Result<IpamAggregatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/aggregates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAggregatesListResponse::Http200(r#response.json::<PaginatedAggregateList>()?)) },
		_ => { Ok(IpamAggregatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesBulkUpdateResponse {
	Http200(Vec<Aggregate>),
	#[default]
	None
}
/// Put a list of aggregate objects.
pub fn ipam_aggregates_bulk_update(state: &ThanixClient, body: Vec<AggregateRequest>) -> Result<IpamAggregatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/aggregates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAggregatesBulkUpdateResponse::Http200(r#response.json::<Vec<Aggregate>>()?)) },
		_ => { Ok(IpamAggregatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesCreateResponse {
	Http201(Aggregate),
	#[default]
	None
}
/// Post a list of aggregate objects.
pub fn ipam_aggregates_create(state: &ThanixClient, body: WritableAggregateRequest) -> Result<IpamAggregatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/aggregates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamAggregatesCreateResponse::Http201(r#response.json::<Aggregate>()?)) },
		_ => { Ok(IpamAggregatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of aggregate objects.
pub fn ipam_aggregates_bulk_destroy(state: &ThanixClient, body: Vec<AggregateRequest>) -> Result<IpamAggregatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/aggregates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamAggregatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesBulkPartialUpdateResponse {
	Http200(Vec<Aggregate>),
	#[default]
	None
}
/// Patch a list of aggregate objects.
pub fn ipam_aggregates_bulk_partial_update(state: &ThanixClient, body: Vec<AggregateRequest>) -> Result<IpamAggregatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/aggregates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAggregatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Aggregate>>()?)) },
		_ => { Ok(IpamAggregatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesRetrieveResponse {
	Http200(Aggregate),
	#[default]
	None
}
/// Get a aggregate object.
pub fn ipam_aggregates_retrieve(state: &ThanixClient, id: i64) -> Result<IpamAggregatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/aggregates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAggregatesRetrieveResponse::Http200(r#response.json::<Aggregate>()?)) },
		_ => { Ok(IpamAggregatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesUpdateResponse {
	Http200(Aggregate),
	#[default]
	None
}
/// Put a aggregate object.
pub fn ipam_aggregates_update(state: &ThanixClient, body: WritableAggregateRequest, id: i64) -> Result<IpamAggregatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/aggregates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAggregatesUpdateResponse::Http200(r#response.json::<Aggregate>()?)) },
		_ => { Ok(IpamAggregatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a aggregate object.
pub fn ipam_aggregates_destroy(state: &ThanixClient, id: i64) -> Result<IpamAggregatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/aggregates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamAggregatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAggregatesPartialUpdateResponse {
	Http200(Aggregate),
	#[default]
	None
}
/// Patch a aggregate object.
pub fn ipam_aggregates_partial_update(state: &ThanixClient, body: PatchedWritableAggregateRequest, id: i64) -> Result<IpamAggregatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/aggregates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAggregatesPartialUpdateResponse::Http200(r#response.json::<Aggregate>()?)) },
		_ => { Ok(IpamAggregatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamAsnRangesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	end: Option<Vec<i64>>,
	end__empty: Option<bool>,
	end__gt: Option<Vec<i64>>,
	end__gte: Option<Vec<i64>>,
	end__lt: Option<Vec<i64>>,
	end__lte: Option<Vec<i64>>,
	end__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// RIR (slug)
	rir: Option<Vec<String>>,
	/// RIR (slug)
	rir__n: Option<Vec<String>>,
	/// RIR (ID)
	rir_id: Option<Vec<i64>>,
	/// RIR (ID)
	rir_id__n: Option<Vec<i64>>,
	start: Option<Vec<i64>>,
	start__empty: Option<bool>,
	start__gt: Option<Vec<i64>>,
	start__gte: Option<Vec<i64>>,
	start__lt: Option<Vec<i64>>,
	start__lte: Option<Vec<i64>>,
	start__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesListResponse {
	Http200(PaginatedASNRangeList),
	#[default]
	None
}
/// Get a list of ASN range objects.
pub fn ipam_asn_ranges_list(state: &ThanixClient, query: IpamAsnRangesListQuery) -> Result<IpamAsnRangesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/asn-ranges/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesListResponse::Http200(r#response.json::<PaginatedASNRangeList>()?)) },
		_ => { Ok(IpamAsnRangesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesBulkUpdateResponse {
	Http200(Vec<ASNRange>),
	#[default]
	None
}
/// Put a list of ASN range objects.
pub fn ipam_asn_ranges_bulk_update(state: &ThanixClient, body: Vec<ASNRangeRequest>) -> Result<IpamAsnRangesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/asn-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesBulkUpdateResponse::Http200(r#response.json::<Vec<ASNRange>>()?)) },
		_ => { Ok(IpamAsnRangesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesCreateResponse {
	Http201(ASNRange),
	#[default]
	None
}
/// Post a list of ASN range objects.
pub fn ipam_asn_ranges_create(state: &ThanixClient, body: WritableASNRangeRequest) -> Result<IpamAsnRangesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/asn-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamAsnRangesCreateResponse::Http201(r#response.json::<ASNRange>()?)) },
		_ => { Ok(IpamAsnRangesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of ASN range objects.
pub fn ipam_asn_ranges_bulk_destroy(state: &ThanixClient, body: Vec<ASNRangeRequest>) -> Result<IpamAsnRangesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/asn-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamAsnRangesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesBulkPartialUpdateResponse {
	Http200(Vec<ASNRange>),
	#[default]
	None
}
/// Patch a list of ASN range objects.
pub fn ipam_asn_ranges_bulk_partial_update(state: &ThanixClient, body: Vec<ASNRangeRequest>) -> Result<IpamAsnRangesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/asn-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ASNRange>>()?)) },
		_ => { Ok(IpamAsnRangesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesRetrieveResponse {
	Http200(ASNRange),
	#[default]
	None
}
/// Get a ASN range object.
pub fn ipam_asn_ranges_retrieve(state: &ThanixClient, id: i64) -> Result<IpamAsnRangesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/asn-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesRetrieveResponse::Http200(r#response.json::<ASNRange>()?)) },
		_ => { Ok(IpamAsnRangesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesUpdateResponse {
	Http200(ASNRange),
	#[default]
	None
}
/// Put a ASN range object.
pub fn ipam_asn_ranges_update(state: &ThanixClient, body: WritableASNRangeRequest, id: i64) -> Result<IpamAsnRangesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/asn-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesUpdateResponse::Http200(r#response.json::<ASNRange>()?)) },
		_ => { Ok(IpamAsnRangesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a ASN range object.
pub fn ipam_asn_ranges_destroy(state: &ThanixClient, id: i64) -> Result<IpamAsnRangesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/asn-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamAsnRangesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesPartialUpdateResponse {
	Http200(ASNRange),
	#[default]
	None
}
/// Patch a ASN range object.
pub fn ipam_asn_ranges_partial_update(state: &ThanixClient, body: PatchedWritableASNRangeRequest, id: i64) -> Result<IpamAsnRangesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/asn-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesPartialUpdateResponse::Http200(r#response.json::<ASNRange>()?)) },
		_ => { Ok(IpamAsnRangesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesAvailableAsnsListResponse {
	Http200(Vec<AvailableASN>),
	#[default]
	None
}
/// Get a ASN object.
pub fn ipam_asn_ranges_available_asns_list(state: &ThanixClient, id: i64) -> Result<IpamAsnRangesAvailableAsnsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/asn-ranges/{id}/available-asns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnRangesAvailableAsnsListResponse::Http200(r#response.json::<Vec<AvailableASN>>()?)) },
		_ => { Ok(IpamAsnRangesAvailableAsnsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnRangesAvailableAsnsCreateResponse {
	Http201(Vec<ASN>),
	#[default]
	None
}
/// Post a ASN object.
pub fn ipam_asn_ranges_available_asns_create(state: &ThanixClient, body: Vec<ASNRequest>, id: i64) -> Result<IpamAsnRangesAvailableAsnsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/asn-ranges/{id}/available-asns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamAsnRangesAvailableAsnsCreateResponse::Http201(r#response.json::<Vec<ASN>>()?)) },
		_ => { Ok(IpamAsnRangesAvailableAsnsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamAsnsListQuery {
	asn: Option<Vec<i64>>,
	asn__empty: Option<bool>,
	asn__gt: Option<Vec<i64>>,
	asn__gte: Option<Vec<i64>>,
	asn__lt: Option<Vec<i64>>,
	asn__lte: Option<Vec<i64>>,
	asn__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// RIR (slug)
	rir: Option<Vec<String>>,
	/// RIR (slug)
	rir__n: Option<Vec<String>>,
	/// RIR (ID)
	rir_id: Option<Vec<i64>>,
	/// RIR (ID)
	rir_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsListResponse {
	Http200(PaginatedASNList),
	#[default]
	None
}
/// Get a list of ASN objects.
pub fn ipam_asns_list(state: &ThanixClient, query: IpamAsnsListQuery) -> Result<IpamAsnsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/asns/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnsListResponse::Http200(r#response.json::<PaginatedASNList>()?)) },
		_ => { Ok(IpamAsnsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsBulkUpdateResponse {
	Http200(Vec<ASN>),
	#[default]
	None
}
/// Put a list of ASN objects.
pub fn ipam_asns_bulk_update(state: &ThanixClient, body: Vec<ASNRequest>) -> Result<IpamAsnsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/asns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnsBulkUpdateResponse::Http200(r#response.json::<Vec<ASN>>()?)) },
		_ => { Ok(IpamAsnsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsCreateResponse {
	Http201(ASN),
	#[default]
	None
}
/// Post a list of ASN objects.
pub fn ipam_asns_create(state: &ThanixClient, body: WritableASNRequest) -> Result<IpamAsnsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/asns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamAsnsCreateResponse::Http201(r#response.json::<ASN>()?)) },
		_ => { Ok(IpamAsnsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of ASN objects.
pub fn ipam_asns_bulk_destroy(state: &ThanixClient, body: Vec<ASNRequest>) -> Result<IpamAsnsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/asns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamAsnsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsBulkPartialUpdateResponse {
	Http200(Vec<ASN>),
	#[default]
	None
}
/// Patch a list of ASN objects.
pub fn ipam_asns_bulk_partial_update(state: &ThanixClient, body: Vec<ASNRequest>) -> Result<IpamAsnsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/asns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ASN>>()?)) },
		_ => { Ok(IpamAsnsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsRetrieveResponse {
	Http200(ASN),
	#[default]
	None
}
/// Get a ASN object.
pub fn ipam_asns_retrieve(state: &ThanixClient, id: i64) -> Result<IpamAsnsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/asns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnsRetrieveResponse::Http200(r#response.json::<ASN>()?)) },
		_ => { Ok(IpamAsnsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsUpdateResponse {
	Http200(ASN),
	#[default]
	None
}
/// Put a ASN object.
pub fn ipam_asns_update(state: &ThanixClient, body: WritableASNRequest, id: i64) -> Result<IpamAsnsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/asns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnsUpdateResponse::Http200(r#response.json::<ASN>()?)) },
		_ => { Ok(IpamAsnsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a ASN object.
pub fn ipam_asns_destroy(state: &ThanixClient, id: i64) -> Result<IpamAsnsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/asns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamAsnsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamAsnsPartialUpdateResponse {
	Http200(ASN),
	#[default]
	None
}
/// Patch a ASN object.
pub fn ipam_asns_partial_update(state: &ThanixClient, body: PatchedWritableASNRequest, id: i64) -> Result<IpamAsnsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/asns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamAsnsPartialUpdateResponse::Http200(r#response.json::<ASN>()?)) },
		_ => { Ok(IpamAsnsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamFhrpGroupAssignmentsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	device: Option<Vec<String>>,
	device_id: Option<Vec<i64>>,
	/// Group (ID)
	group_id: Option<Vec<i64>>,
	/// Group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	interface_id: Option<Vec<i64>>,
	interface_id__empty: Option<bool>,
	interface_id__gt: Option<Vec<i64>>,
	interface_id__gte: Option<Vec<i64>>,
	interface_id__lt: Option<Vec<i64>>,
	interface_id__lte: Option<Vec<i64>>,
	interface_id__n: Option<Vec<i64>>,
	interface_type: Option<String>,
	interface_type__n: Option<String>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	priority: Option<Vec<i64>>,
	priority__empty: Option<bool>,
	priority__gt: Option<Vec<i64>>,
	priority__gte: Option<Vec<i64>>,
	priority__lt: Option<Vec<i64>>,
	priority__lte: Option<Vec<i64>>,
	priority__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	virtual_machine: Option<Vec<String>>,
	virtual_machine_id: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsListResponse {
	Http200(PaginatedFHRPGroupAssignmentList),
	#[default]
	None
}
/// Get a list of FHRP group assignment objects.
pub fn ipam_fhrp_group_assignments_list(state: &ThanixClient, query: IpamFhrpGroupAssignmentsListQuery) -> Result<IpamFhrpGroupAssignmentsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/fhrp-group-assignments/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupAssignmentsListResponse::Http200(r#response.json::<PaginatedFHRPGroupAssignmentList>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsBulkUpdateResponse {
	Http200(Vec<FHRPGroupAssignment>),
	#[default]
	None
}
/// Put a list of FHRP group assignment objects.
pub fn ipam_fhrp_group_assignments_bulk_update(state: &ThanixClient, body: Vec<FHRPGroupAssignmentRequest>) -> Result<IpamFhrpGroupAssignmentsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/fhrp-group-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupAssignmentsBulkUpdateResponse::Http200(r#response.json::<Vec<FHRPGroupAssignment>>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsCreateResponse {
	Http201(FHRPGroupAssignment),
	#[default]
	None
}
/// Post a list of FHRP group assignment objects.
pub fn ipam_fhrp_group_assignments_create(state: &ThanixClient, body: WritableFHRPGroupAssignmentRequest) -> Result<IpamFhrpGroupAssignmentsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/fhrp-group-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamFhrpGroupAssignmentsCreateResponse::Http201(r#response.json::<FHRPGroupAssignment>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of FHRP group assignment objects.
pub fn ipam_fhrp_group_assignments_bulk_destroy(state: &ThanixClient, body: Vec<FHRPGroupAssignmentRequest>) -> Result<IpamFhrpGroupAssignmentsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/fhrp-group-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamFhrpGroupAssignmentsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsBulkPartialUpdateResponse {
	Http200(Vec<FHRPGroupAssignment>),
	#[default]
	None
}
/// Patch a list of FHRP group assignment objects.
pub fn ipam_fhrp_group_assignments_bulk_partial_update(state: &ThanixClient, body: Vec<FHRPGroupAssignmentRequest>) -> Result<IpamFhrpGroupAssignmentsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/fhrp-group-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupAssignmentsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<FHRPGroupAssignment>>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsRetrieveResponse {
	Http200(FHRPGroupAssignment),
	#[default]
	None
}
/// Get a FHRP group assignment object.
pub fn ipam_fhrp_group_assignments_retrieve(state: &ThanixClient, id: i64) -> Result<IpamFhrpGroupAssignmentsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/fhrp-group-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupAssignmentsRetrieveResponse::Http200(r#response.json::<FHRPGroupAssignment>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsUpdateResponse {
	Http200(FHRPGroupAssignment),
	#[default]
	None
}
/// Put a FHRP group assignment object.
pub fn ipam_fhrp_group_assignments_update(state: &ThanixClient, body: WritableFHRPGroupAssignmentRequest, id: i64) -> Result<IpamFhrpGroupAssignmentsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/fhrp-group-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupAssignmentsUpdateResponse::Http200(r#response.json::<FHRPGroupAssignment>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a FHRP group assignment object.
pub fn ipam_fhrp_group_assignments_destroy(state: &ThanixClient, id: i64) -> Result<IpamFhrpGroupAssignmentsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/fhrp-group-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamFhrpGroupAssignmentsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupAssignmentsPartialUpdateResponse {
	Http200(FHRPGroupAssignment),
	#[default]
	None
}
/// Patch a FHRP group assignment object.
pub fn ipam_fhrp_group_assignments_partial_update(state: &ThanixClient, body: PatchedWritableFHRPGroupAssignmentRequest, id: i64) -> Result<IpamFhrpGroupAssignmentsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/fhrp-group-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupAssignmentsPartialUpdateResponse::Http200(r#response.json::<FHRPGroupAssignment>()?)) },
		_ => { Ok(IpamFhrpGroupAssignmentsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamFhrpGroupsListQuery {
	auth_key: Option<Vec<String>>,
	auth_key__empty: Option<bool>,
	auth_key__ic: Option<Vec<String>>,
	auth_key__ie: Option<Vec<String>>,
	auth_key__iew: Option<Vec<String>>,
	auth_key__isw: Option<Vec<String>>,
	auth_key__n: Option<Vec<String>>,
	auth_key__nic: Option<Vec<String>>,
	auth_key__nie: Option<Vec<String>>,
	auth_key__niew: Option<Vec<String>>,
	auth_key__nisw: Option<Vec<String>>,
	auth_type: Option<Vec<String>>,
	auth_type__n: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	group_id: Option<Vec<i64>>,
	group_id__empty: Option<bool>,
	group_id__gt: Option<Vec<i64>>,
	group_id__gte: Option<Vec<i64>>,
	group_id__lt: Option<Vec<i64>>,
	group_id__lte: Option<Vec<i64>>,
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	protocol: Option<Vec<String>>,
	protocol__n: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	related_ip: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsListResponse {
	Http200(PaginatedFHRPGroupList),
	#[default]
	None
}
/// Get a list of FHRP group objects.
pub fn ipam_fhrp_groups_list(state: &ThanixClient, query: IpamFhrpGroupsListQuery) -> Result<IpamFhrpGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/fhrp-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupsListResponse::Http200(r#response.json::<PaginatedFHRPGroupList>()?)) },
		_ => { Ok(IpamFhrpGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsBulkUpdateResponse {
	Http200(Vec<FHRPGroup>),
	#[default]
	None
}
/// Put a list of FHRP group objects.
pub fn ipam_fhrp_groups_bulk_update(state: &ThanixClient, body: Vec<FHRPGroupRequest>) -> Result<IpamFhrpGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/fhrp-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<FHRPGroup>>()?)) },
		_ => { Ok(IpamFhrpGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsCreateResponse {
	Http201(FHRPGroup),
	#[default]
	None
}
/// Post a list of FHRP group objects.
pub fn ipam_fhrp_groups_create(state: &ThanixClient, body: FHRPGroupRequest) -> Result<IpamFhrpGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/fhrp-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamFhrpGroupsCreateResponse::Http201(r#response.json::<FHRPGroup>()?)) },
		_ => { Ok(IpamFhrpGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of FHRP group objects.
pub fn ipam_fhrp_groups_bulk_destroy(state: &ThanixClient, body: Vec<FHRPGroupRequest>) -> Result<IpamFhrpGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/fhrp-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamFhrpGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsBulkPartialUpdateResponse {
	Http200(Vec<FHRPGroup>),
	#[default]
	None
}
/// Patch a list of FHRP group objects.
pub fn ipam_fhrp_groups_bulk_partial_update(state: &ThanixClient, body: Vec<FHRPGroupRequest>) -> Result<IpamFhrpGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/fhrp-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<FHRPGroup>>()?)) },
		_ => { Ok(IpamFhrpGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsRetrieveResponse {
	Http200(FHRPGroup),
	#[default]
	None
}
/// Get a FHRP group object.
pub fn ipam_fhrp_groups_retrieve(state: &ThanixClient, id: i64) -> Result<IpamFhrpGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/fhrp-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupsRetrieveResponse::Http200(r#response.json::<FHRPGroup>()?)) },
		_ => { Ok(IpamFhrpGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsUpdateResponse {
	Http200(FHRPGroup),
	#[default]
	None
}
/// Put a FHRP group object.
pub fn ipam_fhrp_groups_update(state: &ThanixClient, body: FHRPGroupRequest, id: i64) -> Result<IpamFhrpGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/fhrp-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupsUpdateResponse::Http200(r#response.json::<FHRPGroup>()?)) },
		_ => { Ok(IpamFhrpGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a FHRP group object.
pub fn ipam_fhrp_groups_destroy(state: &ThanixClient, id: i64) -> Result<IpamFhrpGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/fhrp-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamFhrpGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamFhrpGroupsPartialUpdateResponse {
	Http200(FHRPGroup),
	#[default]
	None
}
/// Patch a FHRP group object.
pub fn ipam_fhrp_groups_partial_update(state: &ThanixClient, body: PatchedFHRPGroupRequest, id: i64) -> Result<IpamFhrpGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/fhrp-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamFhrpGroupsPartialUpdateResponse::Http200(r#response.json::<FHRPGroup>()?)) },
		_ => { Ok(IpamFhrpGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamIpAddressesListQuery {
	address: Option<Vec<String>>,
	/// Is assigned
	assigned: Option<bool>,
	/// Is assigned to an interface
	assigned_to_interface: Option<bool>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	device: Option<Vec<String>>,
	device_id: Option<Vec<i64>>,
	dns_name: Option<Vec<String>>,
	dns_name__empty: Option<bool>,
	dns_name__ic: Option<Vec<String>>,
	dns_name__ie: Option<Vec<String>>,
	dns_name__iew: Option<Vec<String>>,
	dns_name__isw: Option<Vec<String>>,
	dns_name__n: Option<Vec<String>>,
	dns_name__nic: Option<Vec<String>>,
	dns_name__nie: Option<Vec<String>>,
	dns_name__niew: Option<Vec<String>>,
	dns_name__nisw: Option<Vec<String>>,
	family: Option<f64>,
	/// FHRP group (ID)
	fhrpgroup_id: Option<Vec<i64>>,
	/// FHRP group (ID)
	fhrpgroup_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Interface (name)
	interface: Option<Vec<String>>,
	/// Interface (name)
	interface__n: Option<Vec<String>>,
	/// Interface (ID)
	interface_id: Option<Vec<i64>>,
	/// Interface (ID)
	interface_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mask_length: Option<Vec<i64>>,
	mask_length__gte: Option<f64>,
	mask_length__lte: Option<f64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	parent: Option<Vec<String>>,
	present_in_vrf: Option<String>,
	present_in_vrf_id: Option<String>,
	/// Search
	q: Option<String>,
	/// The functional role of this IP
	role: Option<Vec<String>>,
	/// The functional role of this IP
	role__n: Option<Vec<String>>,
	/// The operational status of this IP
	status: Option<Vec<String>>,
	/// The operational status of this IP
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	virtual_machine: Option<Vec<String>>,
	virtual_machine_id: Option<Vec<i64>>,
	/// VM interface (name)
	vminterface: Option<Vec<String>>,
	/// VM interface (name)
	vminterface__n: Option<Vec<String>>,
	/// VM interface (ID)
	vminterface_id: Option<Vec<i64>>,
	/// VM interface (ID)
	vminterface_id__n: Option<Vec<i64>>,
	/// VRF (RD)
	vrf: Option<Vec<Option<String>>>,
	/// VRF (RD)
	vrf__n: Option<Vec<Option<String>>>,
	/// VRF
	vrf_id: Option<Vec<i64>>,
	/// VRF
	vrf_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesListResponse {
	Http200(PaginatedIPAddressList),
	#[default]
	None
}
/// Get a list of IP address objects.
pub fn ipam_ip_addresses_list(state: &ThanixClient, query: IpamIpAddressesListQuery) -> Result<IpamIpAddressesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/ip-addresses/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpAddressesListResponse::Http200(r#response.json::<PaginatedIPAddressList>()?)) },
		_ => { Ok(IpamIpAddressesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesBulkUpdateResponse {
	Http200(Vec<IPAddress>),
	#[default]
	None
}
/// Put a list of IP address objects.
pub fn ipam_ip_addresses_bulk_update(state: &ThanixClient, body: Vec<IPAddressRequest>) -> Result<IpamIpAddressesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/ip-addresses/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpAddressesBulkUpdateResponse::Http200(r#response.json::<Vec<IPAddress>>()?)) },
		_ => { Ok(IpamIpAddressesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesCreateResponse {
	Http201(IPAddress),
	#[default]
	None
}
/// Post a list of IP address objects.
pub fn ipam_ip_addresses_create(state: &ThanixClient, body: WritableIPAddressRequest) -> Result<IpamIpAddressesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/ip-addresses/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamIpAddressesCreateResponse::Http201(r#response.json::<IPAddress>()?)) },
		_ => { Ok(IpamIpAddressesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IP address objects.
pub fn ipam_ip_addresses_bulk_destroy(state: &ThanixClient, body: Vec<IPAddressRequest>) -> Result<IpamIpAddressesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/ip-addresses/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamIpAddressesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesBulkPartialUpdateResponse {
	Http200(Vec<IPAddress>),
	#[default]
	None
}
/// Patch a list of IP address objects.
pub fn ipam_ip_addresses_bulk_partial_update(state: &ThanixClient, body: Vec<IPAddressRequest>) -> Result<IpamIpAddressesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/ip-addresses/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpAddressesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IPAddress>>()?)) },
		_ => { Ok(IpamIpAddressesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesRetrieveResponse {
	Http200(IPAddress),
	#[default]
	None
}
/// Get a IP address object.
pub fn ipam_ip_addresses_retrieve(state: &ThanixClient, id: i64) -> Result<IpamIpAddressesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/ip-addresses/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpAddressesRetrieveResponse::Http200(r#response.json::<IPAddress>()?)) },
		_ => { Ok(IpamIpAddressesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesUpdateResponse {
	Http200(IPAddress),
	#[default]
	None
}
/// Put a IP address object.
pub fn ipam_ip_addresses_update(state: &ThanixClient, body: WritableIPAddressRequest, id: i64) -> Result<IpamIpAddressesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/ip-addresses/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpAddressesUpdateResponse::Http200(r#response.json::<IPAddress>()?)) },
		_ => { Ok(IpamIpAddressesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IP address object.
pub fn ipam_ip_addresses_destroy(state: &ThanixClient, id: i64) -> Result<IpamIpAddressesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/ip-addresses/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamIpAddressesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpAddressesPartialUpdateResponse {
	Http200(IPAddress),
	#[default]
	None
}
/// Patch a IP address object.
pub fn ipam_ip_addresses_partial_update(state: &ThanixClient, body: PatchedWritableIPAddressRequest, id: i64) -> Result<IpamIpAddressesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/ip-addresses/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpAddressesPartialUpdateResponse::Http200(r#response.json::<IPAddress>()?)) },
		_ => { Ok(IpamIpAddressesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamIpRangesListQuery {
	/// Ranges which contain this prefix or IP
	contains: Option<String>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	end_address: Option<Vec<String>>,
	family: Option<f64>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mark_utilized: Option<bool>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	parent: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	start_address: Option<Vec<String>>,
	/// Operational status of this range
	status: Option<Vec<String>>,
	/// Operational status of this range
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	/// VRF (RD)
	vrf: Option<Vec<Option<String>>>,
	/// VRF (RD)
	vrf__n: Option<Vec<Option<String>>>,
	/// VRF
	vrf_id: Option<Vec<i64>>,
	/// VRF
	vrf_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesListResponse {
	Http200(PaginatedIPRangeList),
	#[default]
	None
}
/// Get a list of IP range objects.
pub fn ipam_ip_ranges_list(state: &ThanixClient, query: IpamIpRangesListQuery) -> Result<IpamIpRangesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/ip-ranges/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesListResponse::Http200(r#response.json::<PaginatedIPRangeList>()?)) },
		_ => { Ok(IpamIpRangesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesBulkUpdateResponse {
	Http200(Vec<IPRange>),
	#[default]
	None
}
/// Put a list of IP range objects.
pub fn ipam_ip_ranges_bulk_update(state: &ThanixClient, body: Vec<IPRangeRequest>) -> Result<IpamIpRangesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/ip-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesBulkUpdateResponse::Http200(r#response.json::<Vec<IPRange>>()?)) },
		_ => { Ok(IpamIpRangesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesCreateResponse {
	Http201(IPRange),
	#[default]
	None
}
/// Post a list of IP range objects.
pub fn ipam_ip_ranges_create(state: &ThanixClient, body: WritableIPRangeRequest) -> Result<IpamIpRangesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/ip-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamIpRangesCreateResponse::Http201(r#response.json::<IPRange>()?)) },
		_ => { Ok(IpamIpRangesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IP range objects.
pub fn ipam_ip_ranges_bulk_destroy(state: &ThanixClient, body: Vec<IPRangeRequest>) -> Result<IpamIpRangesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/ip-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamIpRangesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesBulkPartialUpdateResponse {
	Http200(Vec<IPRange>),
	#[default]
	None
}
/// Patch a list of IP range objects.
pub fn ipam_ip_ranges_bulk_partial_update(state: &ThanixClient, body: Vec<IPRangeRequest>) -> Result<IpamIpRangesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/ip-ranges/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IPRange>>()?)) },
		_ => { Ok(IpamIpRangesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesRetrieveResponse {
	Http200(IPRange),
	#[default]
	None
}
/// Get a IP range object.
pub fn ipam_ip_ranges_retrieve(state: &ThanixClient, id: i64) -> Result<IpamIpRangesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/ip-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesRetrieveResponse::Http200(r#response.json::<IPRange>()?)) },
		_ => { Ok(IpamIpRangesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesUpdateResponse {
	Http200(IPRange),
	#[default]
	None
}
/// Put a IP range object.
pub fn ipam_ip_ranges_update(state: &ThanixClient, body: WritableIPRangeRequest, id: i64) -> Result<IpamIpRangesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/ip-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesUpdateResponse::Http200(r#response.json::<IPRange>()?)) },
		_ => { Ok(IpamIpRangesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IP range object.
pub fn ipam_ip_ranges_destroy(state: &ThanixClient, id: i64) -> Result<IpamIpRangesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/ip-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamIpRangesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesPartialUpdateResponse {
	Http200(IPRange),
	#[default]
	None
}
/// Patch a IP range object.
pub fn ipam_ip_ranges_partial_update(state: &ThanixClient, body: PatchedWritableIPRangeRequest, id: i64) -> Result<IpamIpRangesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/ip-ranges/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesPartialUpdateResponse::Http200(r#response.json::<IPRange>()?)) },
		_ => { Ok(IpamIpRangesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesAvailableIpsListResponse {
	Http200(Vec<AvailableIP>),
	#[default]
	None
}
/// Get a IP address object.
pub fn ipam_ip_ranges_available_ips_list(state: &ThanixClient, id: i64) -> Result<IpamIpRangesAvailableIpsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/ip-ranges/{id}/available-ips/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamIpRangesAvailableIpsListResponse::Http200(r#response.json::<Vec<AvailableIP>>()?)) },
		_ => { Ok(IpamIpRangesAvailableIpsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamIpRangesAvailableIpsCreateResponse {
	Http201(Vec<IPAddress>),
	#[default]
	None
}
/// Post a IP address object.
pub fn ipam_ip_ranges_available_ips_create(state: &ThanixClient, body: Vec<IPAddressRequest>, id: i64) -> Result<IpamIpRangesAvailableIpsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/ip-ranges/{id}/available-ips/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamIpRangesAvailableIpsCreateResponse::Http201(r#response.json::<Vec<IPAddress>>()?)) },
		_ => { Ok(IpamIpRangesAvailableIpsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamPrefixesListQuery {
	children: Option<Vec<i64>>,
	children__empty: Option<Vec<i64>>,
	children__gt: Option<Vec<i64>>,
	children__gte: Option<Vec<i64>>,
	children__lt: Option<Vec<i64>>,
	children__lte: Option<Vec<i64>>,
	children__n: Option<Vec<i64>>,
	/// Prefixes which contain this prefix or IP
	contains: Option<String>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	depth: Option<Vec<i64>>,
	depth__empty: Option<Vec<i64>>,
	depth__gt: Option<Vec<i64>>,
	depth__gte: Option<Vec<i64>>,
	depth__lt: Option<Vec<i64>>,
	depth__lte: Option<Vec<i64>>,
	depth__n: Option<Vec<i64>>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	family: Option<f64>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	is_pool: Option<bool>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mark_utilized: Option<bool>,
	mask_length: Option<Vec<i64>>,
	mask_length__gte: Option<f64>,
	mask_length__lte: Option<f64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	prefix: Option<Vec<String>>,
	present_in_vrf: Option<String>,
	present_in_vrf_id: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	/// Operational status of this prefix
	status: Option<Vec<String>>,
	/// Operational status of this prefix
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	/// VLAN (ID)
	vlan_id: Option<Vec<i64>>,
	/// VLAN (ID)
	vlan_id__n: Option<Vec<i64>>,
	/// VLAN number (1-4094)
	vlan_vid: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__empty: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__gt: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__gte: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__lt: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__lte: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__n: Option<i64>,
	/// VRF (RD)
	vrf: Option<Vec<Option<String>>>,
	/// VRF (RD)
	vrf__n: Option<Vec<Option<String>>>,
	/// VRF
	vrf_id: Option<Vec<i64>>,
	/// VRF
	vrf_id__n: Option<Vec<i64>>,
	/// Within prefix
	within: Option<String>,
	/// Within and including prefix
	within_include: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesListResponse {
	Http200(PaginatedPrefixList),
	#[default]
	None
}
/// Get a list of prefix objects.
pub fn ipam_prefixes_list(state: &ThanixClient, query: IpamPrefixesListQuery) -> Result<IpamPrefixesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/prefixes/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesListResponse::Http200(r#response.json::<PaginatedPrefixList>()?)) },
		_ => { Ok(IpamPrefixesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesBulkUpdateResponse {
	Http200(Vec<Prefix>),
	#[default]
	None
}
/// Put a list of prefix objects.
pub fn ipam_prefixes_bulk_update(state: &ThanixClient, body: Vec<PrefixRequest>) -> Result<IpamPrefixesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/prefixes/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesBulkUpdateResponse::Http200(r#response.json::<Vec<Prefix>>()?)) },
		_ => { Ok(IpamPrefixesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesCreateResponse {
	Http201(Prefix),
	#[default]
	None
}
/// Post a list of prefix objects.
pub fn ipam_prefixes_create(state: &ThanixClient, body: WritablePrefixRequest) -> Result<IpamPrefixesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/prefixes/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamPrefixesCreateResponse::Http201(r#response.json::<Prefix>()?)) },
		_ => { Ok(IpamPrefixesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of prefix objects.
pub fn ipam_prefixes_bulk_destroy(state: &ThanixClient, body: Vec<PrefixRequest>) -> Result<IpamPrefixesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/prefixes/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamPrefixesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesBulkPartialUpdateResponse {
	Http200(Vec<Prefix>),
	#[default]
	None
}
/// Patch a list of prefix objects.
pub fn ipam_prefixes_bulk_partial_update(state: &ThanixClient, body: Vec<PrefixRequest>) -> Result<IpamPrefixesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/prefixes/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Prefix>>()?)) },
		_ => { Ok(IpamPrefixesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesRetrieveResponse {
	Http200(Prefix),
	#[default]
	None
}
/// Get a prefix object.
pub fn ipam_prefixes_retrieve(state: &ThanixClient, id: i64) -> Result<IpamPrefixesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/prefixes/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesRetrieveResponse::Http200(r#response.json::<Prefix>()?)) },
		_ => { Ok(IpamPrefixesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesUpdateResponse {
	Http200(Prefix),
	#[default]
	None
}
/// Put a prefix object.
pub fn ipam_prefixes_update(state: &ThanixClient, body: WritablePrefixRequest, id: i64) -> Result<IpamPrefixesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/prefixes/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesUpdateResponse::Http200(r#response.json::<Prefix>()?)) },
		_ => { Ok(IpamPrefixesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a prefix object.
pub fn ipam_prefixes_destroy(state: &ThanixClient, id: i64) -> Result<IpamPrefixesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/prefixes/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamPrefixesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesPartialUpdateResponse {
	Http200(Prefix),
	#[default]
	None
}
/// Patch a prefix object.
pub fn ipam_prefixes_partial_update(state: &ThanixClient, body: PatchedWritablePrefixRequest, id: i64) -> Result<IpamPrefixesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/prefixes/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesPartialUpdateResponse::Http200(r#response.json::<Prefix>()?)) },
		_ => { Ok(IpamPrefixesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesAvailableIpsListResponse {
	Http200(Vec<AvailableIP>),
	#[default]
	None
}
/// Get a IP address object.
pub fn ipam_prefixes_available_ips_list(state: &ThanixClient, id: i64) -> Result<IpamPrefixesAvailableIpsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/prefixes/{id}/available-ips/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesAvailableIpsListResponse::Http200(r#response.json::<Vec<AvailableIP>>()?)) },
		_ => { Ok(IpamPrefixesAvailableIpsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesAvailableIpsCreateResponse {
	Http201(Vec<IPAddress>),
	#[default]
	None
}
/// Post a IP address object.
pub fn ipam_prefixes_available_ips_create(state: &ThanixClient, body: Vec<IPAddressRequest>, id: i64) -> Result<IpamPrefixesAvailableIpsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/prefixes/{id}/available-ips/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamPrefixesAvailableIpsCreateResponse::Http201(r#response.json::<Vec<IPAddress>>()?)) },
		_ => { Ok(IpamPrefixesAvailableIpsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesAvailablePrefixesListResponse {
	Http200(Vec<AvailablePrefix>),
	#[default]
	None
}
/// Get a prefix object.
pub fn ipam_prefixes_available_prefixes_list(state: &ThanixClient, id: i64) -> Result<IpamPrefixesAvailablePrefixesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/prefixes/{id}/available-prefixes/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamPrefixesAvailablePrefixesListResponse::Http200(r#response.json::<Vec<AvailablePrefix>>()?)) },
		_ => { Ok(IpamPrefixesAvailablePrefixesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamPrefixesAvailablePrefixesCreateResponse {
	Http201(Vec<Prefix>),
	#[default]
	None
}
/// Post a prefix object.
pub fn ipam_prefixes_available_prefixes_create(state: &ThanixClient, body: Vec<PrefixRequest>, id: i64) -> Result<IpamPrefixesAvailablePrefixesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/prefixes/{id}/available-prefixes/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamPrefixesAvailablePrefixesCreateResponse::Http201(r#response.json::<Vec<Prefix>>()?)) },
		_ => { Ok(IpamPrefixesAvailablePrefixesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamRirsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	is_private: Option<bool>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsListResponse {
	Http200(PaginatedRIRList),
	#[default]
	None
}
/// Get a list of RIR objects.
pub fn ipam_rirs_list(state: &ThanixClient, query: IpamRirsListQuery) -> Result<IpamRirsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/rirs/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRirsListResponse::Http200(r#response.json::<PaginatedRIRList>()?)) },
		_ => { Ok(IpamRirsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsBulkUpdateResponse {
	Http200(Vec<RIR>),
	#[default]
	None
}
/// Put a list of RIR objects.
pub fn ipam_rirs_bulk_update(state: &ThanixClient, body: Vec<RIRRequest>) -> Result<IpamRirsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/rirs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRirsBulkUpdateResponse::Http200(r#response.json::<Vec<RIR>>()?)) },
		_ => { Ok(IpamRirsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsCreateResponse {
	Http201(RIR),
	#[default]
	None
}
/// Post a list of RIR objects.
pub fn ipam_rirs_create(state: &ThanixClient, body: RIRRequest) -> Result<IpamRirsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/rirs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamRirsCreateResponse::Http201(r#response.json::<RIR>()?)) },
		_ => { Ok(IpamRirsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of RIR objects.
pub fn ipam_rirs_bulk_destroy(state: &ThanixClient, body: Vec<RIRRequest>) -> Result<IpamRirsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/rirs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamRirsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsBulkPartialUpdateResponse {
	Http200(Vec<RIR>),
	#[default]
	None
}
/// Patch a list of RIR objects.
pub fn ipam_rirs_bulk_partial_update(state: &ThanixClient, body: Vec<RIRRequest>) -> Result<IpamRirsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/rirs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRirsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<RIR>>()?)) },
		_ => { Ok(IpamRirsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsRetrieveResponse {
	Http200(RIR),
	#[default]
	None
}
/// Get a RIR object.
pub fn ipam_rirs_retrieve(state: &ThanixClient, id: i64) -> Result<IpamRirsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/rirs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRirsRetrieveResponse::Http200(r#response.json::<RIR>()?)) },
		_ => { Ok(IpamRirsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsUpdateResponse {
	Http200(RIR),
	#[default]
	None
}
/// Put a RIR object.
pub fn ipam_rirs_update(state: &ThanixClient, body: RIRRequest, id: i64) -> Result<IpamRirsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/rirs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRirsUpdateResponse::Http200(r#response.json::<RIR>()?)) },
		_ => { Ok(IpamRirsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a RIR object.
pub fn ipam_rirs_destroy(state: &ThanixClient, id: i64) -> Result<IpamRirsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/rirs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamRirsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRirsPartialUpdateResponse {
	Http200(RIR),
	#[default]
	None
}
/// Patch a RIR object.
pub fn ipam_rirs_partial_update(state: &ThanixClient, body: PatchedRIRRequest, id: i64) -> Result<IpamRirsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/rirs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRirsPartialUpdateResponse::Http200(r#response.json::<RIR>()?)) },
		_ => { Ok(IpamRirsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamRolesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesListResponse {
	Http200(PaginatedRoleList),
	#[default]
	None
}
/// Get a list of role objects.
pub fn ipam_roles_list(state: &ThanixClient, query: IpamRolesListQuery) -> Result<IpamRolesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/roles/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRolesListResponse::Http200(r#response.json::<PaginatedRoleList>()?)) },
		_ => { Ok(IpamRolesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesBulkUpdateResponse {
	Http200(Vec<Role>),
	#[default]
	None
}
/// Put a list of role objects.
pub fn ipam_roles_bulk_update(state: &ThanixClient, body: Vec<RoleRequest>) -> Result<IpamRolesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRolesBulkUpdateResponse::Http200(r#response.json::<Vec<Role>>()?)) },
		_ => { Ok(IpamRolesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesCreateResponse {
	Http201(Role),
	#[default]
	None
}
/// Post a list of role objects.
pub fn ipam_roles_create(state: &ThanixClient, body: RoleRequest) -> Result<IpamRolesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamRolesCreateResponse::Http201(r#response.json::<Role>()?)) },
		_ => { Ok(IpamRolesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of role objects.
pub fn ipam_roles_bulk_destroy(state: &ThanixClient, body: Vec<RoleRequest>) -> Result<IpamRolesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamRolesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesBulkPartialUpdateResponse {
	Http200(Vec<Role>),
	#[default]
	None
}
/// Patch a list of role objects.
pub fn ipam_roles_bulk_partial_update(state: &ThanixClient, body: Vec<RoleRequest>) -> Result<IpamRolesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRolesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Role>>()?)) },
		_ => { Ok(IpamRolesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesRetrieveResponse {
	Http200(Role),
	#[default]
	None
}
/// Get a role object.
pub fn ipam_roles_retrieve(state: &ThanixClient, id: i64) -> Result<IpamRolesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRolesRetrieveResponse::Http200(r#response.json::<Role>()?)) },
		_ => { Ok(IpamRolesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesUpdateResponse {
	Http200(Role),
	#[default]
	None
}
/// Put a role object.
pub fn ipam_roles_update(state: &ThanixClient, body: RoleRequest, id: i64) -> Result<IpamRolesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRolesUpdateResponse::Http200(r#response.json::<Role>()?)) },
		_ => { Ok(IpamRolesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a role object.
pub fn ipam_roles_destroy(state: &ThanixClient, id: i64) -> Result<IpamRolesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamRolesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRolesPartialUpdateResponse {
	Http200(Role),
	#[default]
	None
}
/// Patch a role object.
pub fn ipam_roles_partial_update(state: &ThanixClient, body: PatchedRoleRequest, id: i64) -> Result<IpamRolesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRolesPartialUpdateResponse::Http200(r#response.json::<Role>()?)) },
		_ => { Ok(IpamRolesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamRouteTargetsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Export VRF (RD)
	exporting_vrf: Option<Vec<Option<String>>>,
	/// Export VRF (RD)
	exporting_vrf__n: Option<Vec<Option<String>>>,
	/// Exporting VRF
	exporting_vrf_id: Option<Vec<i64>>,
	/// Exporting VRF
	exporting_vrf_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Import VRF (RD)
	importing_vrf: Option<Vec<Option<String>>>,
	/// Import VRF (RD)
	importing_vrf__n: Option<Vec<Option<String>>>,
	/// Importing VRF
	importing_vrf_id: Option<Vec<i64>>,
	/// Importing VRF
	importing_vrf_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsListResponse {
	Http200(PaginatedRouteTargetList),
	#[default]
	None
}
/// Get a list of route target objects.
pub fn ipam_route_targets_list(state: &ThanixClient, query: IpamRouteTargetsListQuery) -> Result<IpamRouteTargetsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/route-targets/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRouteTargetsListResponse::Http200(r#response.json::<PaginatedRouteTargetList>()?)) },
		_ => { Ok(IpamRouteTargetsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsBulkUpdateResponse {
	Http200(Vec<RouteTarget>),
	#[default]
	None
}
/// Put a list of route target objects.
pub fn ipam_route_targets_bulk_update(state: &ThanixClient, body: Vec<RouteTargetRequest>) -> Result<IpamRouteTargetsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/route-targets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRouteTargetsBulkUpdateResponse::Http200(r#response.json::<Vec<RouteTarget>>()?)) },
		_ => { Ok(IpamRouteTargetsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsCreateResponse {
	Http201(RouteTarget),
	#[default]
	None
}
/// Post a list of route target objects.
pub fn ipam_route_targets_create(state: &ThanixClient, body: WritableRouteTargetRequest) -> Result<IpamRouteTargetsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/route-targets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamRouteTargetsCreateResponse::Http201(r#response.json::<RouteTarget>()?)) },
		_ => { Ok(IpamRouteTargetsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of route target objects.
pub fn ipam_route_targets_bulk_destroy(state: &ThanixClient, body: Vec<RouteTargetRequest>) -> Result<IpamRouteTargetsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/route-targets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamRouteTargetsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsBulkPartialUpdateResponse {
	Http200(Vec<RouteTarget>),
	#[default]
	None
}
/// Patch a list of route target objects.
pub fn ipam_route_targets_bulk_partial_update(state: &ThanixClient, body: Vec<RouteTargetRequest>) -> Result<IpamRouteTargetsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/route-targets/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRouteTargetsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<RouteTarget>>()?)) },
		_ => { Ok(IpamRouteTargetsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsRetrieveResponse {
	Http200(RouteTarget),
	#[default]
	None
}
/// Get a route target object.
pub fn ipam_route_targets_retrieve(state: &ThanixClient, id: i64) -> Result<IpamRouteTargetsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/route-targets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRouteTargetsRetrieveResponse::Http200(r#response.json::<RouteTarget>()?)) },
		_ => { Ok(IpamRouteTargetsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsUpdateResponse {
	Http200(RouteTarget),
	#[default]
	None
}
/// Put a route target object.
pub fn ipam_route_targets_update(state: &ThanixClient, body: WritableRouteTargetRequest, id: i64) -> Result<IpamRouteTargetsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/route-targets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRouteTargetsUpdateResponse::Http200(r#response.json::<RouteTarget>()?)) },
		_ => { Ok(IpamRouteTargetsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a route target object.
pub fn ipam_route_targets_destroy(state: &ThanixClient, id: i64) -> Result<IpamRouteTargetsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/route-targets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamRouteTargetsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamRouteTargetsPartialUpdateResponse {
	Http200(RouteTarget),
	#[default]
	None
}
/// Patch a route target object.
pub fn ipam_route_targets_partial_update(state: &ThanixClient, body: PatchedWritableRouteTargetRequest, id: i64) -> Result<IpamRouteTargetsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/route-targets/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamRouteTargetsPartialUpdateResponse::Http200(r#response.json::<RouteTarget>()?)) },
		_ => { Ok(IpamRouteTargetsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamServiceTemplatesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	port: Option<f64>,
	protocol: Option<String>,
	protocol__n: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesListResponse {
	Http200(PaginatedServiceTemplateList),
	#[default]
	None
}
/// Get a list of service template objects.
pub fn ipam_service_templates_list(state: &ThanixClient, query: IpamServiceTemplatesListQuery) -> Result<IpamServiceTemplatesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/service-templates/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServiceTemplatesListResponse::Http200(r#response.json::<PaginatedServiceTemplateList>()?)) },
		_ => { Ok(IpamServiceTemplatesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesBulkUpdateResponse {
	Http200(Vec<ServiceTemplate>),
	#[default]
	None
}
/// Put a list of service template objects.
pub fn ipam_service_templates_bulk_update(state: &ThanixClient, body: Vec<ServiceTemplateRequest>) -> Result<IpamServiceTemplatesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/service-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServiceTemplatesBulkUpdateResponse::Http200(r#response.json::<Vec<ServiceTemplate>>()?)) },
		_ => { Ok(IpamServiceTemplatesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesCreateResponse {
	Http201(ServiceTemplate),
	#[default]
	None
}
/// Post a list of service template objects.
pub fn ipam_service_templates_create(state: &ThanixClient, body: WritableServiceTemplateRequest) -> Result<IpamServiceTemplatesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/service-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamServiceTemplatesCreateResponse::Http201(r#response.json::<ServiceTemplate>()?)) },
		_ => { Ok(IpamServiceTemplatesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of service template objects.
pub fn ipam_service_templates_bulk_destroy(state: &ThanixClient, body: Vec<ServiceTemplateRequest>) -> Result<IpamServiceTemplatesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/service-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamServiceTemplatesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesBulkPartialUpdateResponse {
	Http200(Vec<ServiceTemplate>),
	#[default]
	None
}
/// Patch a list of service template objects.
pub fn ipam_service_templates_bulk_partial_update(state: &ThanixClient, body: Vec<ServiceTemplateRequest>) -> Result<IpamServiceTemplatesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/service-templates/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServiceTemplatesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ServiceTemplate>>()?)) },
		_ => { Ok(IpamServiceTemplatesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesRetrieveResponse {
	Http200(ServiceTemplate),
	#[default]
	None
}
/// Get a service template object.
pub fn ipam_service_templates_retrieve(state: &ThanixClient, id: i64) -> Result<IpamServiceTemplatesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/service-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServiceTemplatesRetrieveResponse::Http200(r#response.json::<ServiceTemplate>()?)) },
		_ => { Ok(IpamServiceTemplatesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesUpdateResponse {
	Http200(ServiceTemplate),
	#[default]
	None
}
/// Put a service template object.
pub fn ipam_service_templates_update(state: &ThanixClient, body: WritableServiceTemplateRequest, id: i64) -> Result<IpamServiceTemplatesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/service-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServiceTemplatesUpdateResponse::Http200(r#response.json::<ServiceTemplate>()?)) },
		_ => { Ok(IpamServiceTemplatesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a service template object.
pub fn ipam_service_templates_destroy(state: &ThanixClient, id: i64) -> Result<IpamServiceTemplatesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/service-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamServiceTemplatesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServiceTemplatesPartialUpdateResponse {
	Http200(ServiceTemplate),
	#[default]
	None
}
/// Patch a service template object.
pub fn ipam_service_templates_partial_update(state: &ThanixClient, body: PatchedWritableServiceTemplateRequest, id: i64) -> Result<IpamServiceTemplatesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/service-templates/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServiceTemplatesPartialUpdateResponse::Http200(r#response.json::<ServiceTemplate>()?)) },
		_ => { Ok(IpamServiceTemplatesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamServicesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// IP address
	ipaddress: Option<Vec<String>>,
	/// IP address
	ipaddress__n: Option<Vec<String>>,
	/// IP address (ID)
	ipaddress_id: Option<Vec<i64>>,
	/// IP address (ID)
	ipaddress_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	port: Option<f64>,
	protocol: Option<String>,
	protocol__n: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual machine (name)
	virtual_machine: Option<Vec<String>>,
	/// Virtual machine (name)
	virtual_machine__n: Option<Vec<String>>,
	/// Virtual machine (ID)
	virtual_machine_id: Option<Vec<i64>>,
	/// Virtual machine (ID)
	virtual_machine_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesListResponse {
	Http200(PaginatedServiceList),
	#[default]
	None
}
/// Get a list of service objects.
pub fn ipam_services_list(state: &ThanixClient, query: IpamServicesListQuery) -> Result<IpamServicesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/services/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServicesListResponse::Http200(r#response.json::<PaginatedServiceList>()?)) },
		_ => { Ok(IpamServicesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesBulkUpdateResponse {
	Http200(Vec<Service>),
	#[default]
	None
}
/// Put a list of service objects.
pub fn ipam_services_bulk_update(state: &ThanixClient, body: Vec<ServiceRequest>) -> Result<IpamServicesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/services/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServicesBulkUpdateResponse::Http200(r#response.json::<Vec<Service>>()?)) },
		_ => { Ok(IpamServicesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesCreateResponse {
	Http201(Service),
	#[default]
	None
}
/// Post a list of service objects.
pub fn ipam_services_create(state: &ThanixClient, body: WritableServiceRequest) -> Result<IpamServicesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/services/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamServicesCreateResponse::Http201(r#response.json::<Service>()?)) },
		_ => { Ok(IpamServicesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of service objects.
pub fn ipam_services_bulk_destroy(state: &ThanixClient, body: Vec<ServiceRequest>) -> Result<IpamServicesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/services/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamServicesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesBulkPartialUpdateResponse {
	Http200(Vec<Service>),
	#[default]
	None
}
/// Patch a list of service objects.
pub fn ipam_services_bulk_partial_update(state: &ThanixClient, body: Vec<ServiceRequest>) -> Result<IpamServicesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/services/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServicesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Service>>()?)) },
		_ => { Ok(IpamServicesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesRetrieveResponse {
	Http200(Service),
	#[default]
	None
}
/// Get a service object.
pub fn ipam_services_retrieve(state: &ThanixClient, id: i64) -> Result<IpamServicesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/services/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServicesRetrieveResponse::Http200(r#response.json::<Service>()?)) },
		_ => { Ok(IpamServicesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesUpdateResponse {
	Http200(Service),
	#[default]
	None
}
/// Put a service object.
pub fn ipam_services_update(state: &ThanixClient, body: WritableServiceRequest, id: i64) -> Result<IpamServicesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/services/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServicesUpdateResponse::Http200(r#response.json::<Service>()?)) },
		_ => { Ok(IpamServicesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a service object.
pub fn ipam_services_destroy(state: &ThanixClient, id: i64) -> Result<IpamServicesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/services/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamServicesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamServicesPartialUpdateResponse {
	Http200(Service),
	#[default]
	None
}
/// Patch a service object.
pub fn ipam_services_partial_update(state: &ThanixClient, body: PatchedWritableServiceRequest, id: i64) -> Result<IpamServicesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/services/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamServicesPartialUpdateResponse::Http200(r#response.json::<Service>()?)) },
		_ => { Ok(IpamServicesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamVlanGroupsListQuery {
	cluster: Option<i64>,
	clustergroup: Option<f64>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	location: Option<i64>,
	max_vid: Option<Vec<i64>>,
	max_vid__empty: Option<bool>,
	max_vid__gt: Option<Vec<i64>>,
	max_vid__gte: Option<Vec<i64>>,
	max_vid__lt: Option<Vec<i64>>,
	max_vid__lte: Option<Vec<i64>>,
	max_vid__n: Option<Vec<i64>>,
	min_vid: Option<Vec<i64>>,
	min_vid__empty: Option<bool>,
	min_vid__gt: Option<Vec<i64>>,
	min_vid__gte: Option<Vec<i64>>,
	min_vid__lt: Option<Vec<i64>>,
	min_vid__lte: Option<Vec<i64>>,
	min_vid__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	rack: Option<i64>,
	region: Option<i64>,
	scope_id: Option<Vec<i64>>,
	scope_id__empty: Option<bool>,
	scope_id__gt: Option<Vec<i64>>,
	scope_id__gte: Option<Vec<i64>>,
	scope_id__lt: Option<Vec<i64>>,
	scope_id__lte: Option<Vec<i64>>,
	scope_id__n: Option<Vec<i64>>,
	scope_type: Option<String>,
	scope_type__n: Option<String>,
	site: Option<i64>,
	sitegroup: Option<f64>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsListResponse {
	Http200(PaginatedVLANGroupList),
	#[default]
	None
}
/// Get a list of VLAN group objects.
pub fn ipam_vlan_groups_list(state: &ThanixClient, query: IpamVlanGroupsListQuery) -> Result<IpamVlanGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vlan-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsListResponse::Http200(r#response.json::<PaginatedVLANGroupList>()?)) },
		_ => { Ok(IpamVlanGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsBulkUpdateResponse {
	Http200(Vec<VLANGroup>),
	#[default]
	None
}
/// Put a list of VLAN group objects.
pub fn ipam_vlan_groups_bulk_update(state: &ThanixClient, body: Vec<VLANGroupRequest>) -> Result<IpamVlanGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/vlan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<VLANGroup>>()?)) },
		_ => { Ok(IpamVlanGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsCreateResponse {
	Http201(VLANGroup),
	#[default]
	None
}
/// Post a list of VLAN group objects.
pub fn ipam_vlan_groups_create(state: &ThanixClient, body: VLANGroupRequest) -> Result<IpamVlanGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/vlan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamVlanGroupsCreateResponse::Http201(r#response.json::<VLANGroup>()?)) },
		_ => { Ok(IpamVlanGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of VLAN group objects.
pub fn ipam_vlan_groups_bulk_destroy(state: &ThanixClient, body: Vec<VLANGroupRequest>) -> Result<IpamVlanGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/vlan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamVlanGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsBulkPartialUpdateResponse {
	Http200(Vec<VLANGroup>),
	#[default]
	None
}
/// Patch a list of VLAN group objects.
pub fn ipam_vlan_groups_bulk_partial_update(state: &ThanixClient, body: Vec<VLANGroupRequest>) -> Result<IpamVlanGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/vlan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VLANGroup>>()?)) },
		_ => { Ok(IpamVlanGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsRetrieveResponse {
	Http200(VLANGroup),
	#[default]
	None
}
/// Get a VLAN group object.
pub fn ipam_vlan_groups_retrieve(state: &ThanixClient, id: i64) -> Result<IpamVlanGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vlan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsRetrieveResponse::Http200(r#response.json::<VLANGroup>()?)) },
		_ => { Ok(IpamVlanGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsUpdateResponse {
	Http200(VLANGroup),
	#[default]
	None
}
/// Put a VLAN group object.
pub fn ipam_vlan_groups_update(state: &ThanixClient, body: VLANGroupRequest, id: i64) -> Result<IpamVlanGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/vlan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsUpdateResponse::Http200(r#response.json::<VLANGroup>()?)) },
		_ => { Ok(IpamVlanGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a VLAN group object.
pub fn ipam_vlan_groups_destroy(state: &ThanixClient, id: i64) -> Result<IpamVlanGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/vlan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamVlanGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsPartialUpdateResponse {
	Http200(VLANGroup),
	#[default]
	None
}
/// Patch a VLAN group object.
pub fn ipam_vlan_groups_partial_update(state: &ThanixClient, body: PatchedVLANGroupRequest, id: i64) -> Result<IpamVlanGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/vlan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsPartialUpdateResponse::Http200(r#response.json::<VLANGroup>()?)) },
		_ => { Ok(IpamVlanGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsAvailableVlansListResponse {
	Http200(Vec<AvailableVLAN>),
	#[default]
	None
}
/// Get a VLAN object.
pub fn ipam_vlan_groups_available_vlans_list(state: &ThanixClient, id: i64) -> Result<IpamVlanGroupsAvailableVlansListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vlan-groups/{id}/available-vlans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlanGroupsAvailableVlansListResponse::Http200(r#response.json::<Vec<AvailableVLAN>>()?)) },
		_ => { Ok(IpamVlanGroupsAvailableVlansListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlanGroupsAvailableVlansCreateResponse {
	Http201(Vec<VLAN>),
	#[default]
	None
}
/// Post a VLAN object.
pub fn ipam_vlan_groups_available_vlans_create(state: &ThanixClient, body: Vec<VLANRequest>, id: i64) -> Result<IpamVlanGroupsAvailableVlansCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/vlan-groups/{id}/available-vlans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamVlanGroupsAvailableVlansCreateResponse::Http201(r#response.json::<Vec<VLAN>>()?)) },
		_ => { Ok(IpamVlanGroupsAvailableVlansCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamVlansListQuery {
	available_at_site: Option<String>,
	available_on_device: Option<String>,
	available_on_virtualmachine: Option<String>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Group
	group: Option<Vec<String>>,
	/// Group
	group__n: Option<Vec<String>>,
	/// Group (ID)
	group_id: Option<Vec<i64>>,
	/// Group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// L2VPN
	l2vpn: Option<Vec<i64>>,
	/// L2VPN
	l2vpn__n: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	/// Operational status of this VLAN
	status: Option<Vec<String>>,
	/// Operational status of this VLAN
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	vid: Option<Vec<i64>>,
	vid__empty: Option<bool>,
	vid__gt: Option<Vec<i64>>,
	vid__gte: Option<Vec<i64>>,
	vid__lt: Option<Vec<i64>>,
	vid__lte: Option<Vec<i64>>,
	vid__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansListResponse {
	Http200(PaginatedVLANList),
	#[default]
	None
}
/// Get a list of VLAN objects.
pub fn ipam_vlans_list(state: &ThanixClient, query: IpamVlansListQuery) -> Result<IpamVlansListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vlans/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlansListResponse::Http200(r#response.json::<PaginatedVLANList>()?)) },
		_ => { Ok(IpamVlansListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansBulkUpdateResponse {
	Http200(Vec<VLAN>),
	#[default]
	None
}
/// Put a list of VLAN objects.
pub fn ipam_vlans_bulk_update(state: &ThanixClient, body: Vec<VLANRequest>) -> Result<IpamVlansBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/vlans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlansBulkUpdateResponse::Http200(r#response.json::<Vec<VLAN>>()?)) },
		_ => { Ok(IpamVlansBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansCreateResponse {
	Http201(VLAN),
	#[default]
	None
}
/// Post a list of VLAN objects.
pub fn ipam_vlans_create(state: &ThanixClient, body: WritableVLANRequest) -> Result<IpamVlansCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/vlans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamVlansCreateResponse::Http201(r#response.json::<VLAN>()?)) },
		_ => { Ok(IpamVlansCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of VLAN objects.
pub fn ipam_vlans_bulk_destroy(state: &ThanixClient, body: Vec<VLANRequest>) -> Result<IpamVlansBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/vlans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamVlansBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansBulkPartialUpdateResponse {
	Http200(Vec<VLAN>),
	#[default]
	None
}
/// Patch a list of VLAN objects.
pub fn ipam_vlans_bulk_partial_update(state: &ThanixClient, body: Vec<VLANRequest>) -> Result<IpamVlansBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/vlans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlansBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VLAN>>()?)) },
		_ => { Ok(IpamVlansBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansRetrieveResponse {
	Http200(VLAN),
	#[default]
	None
}
/// Get a VLAN object.
pub fn ipam_vlans_retrieve(state: &ThanixClient, id: i64) -> Result<IpamVlansRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vlans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlansRetrieveResponse::Http200(r#response.json::<VLAN>()?)) },
		_ => { Ok(IpamVlansRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansUpdateResponse {
	Http200(VLAN),
	#[default]
	None
}
/// Put a VLAN object.
pub fn ipam_vlans_update(state: &ThanixClient, body: WritableVLANRequest, id: i64) -> Result<IpamVlansUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/vlans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlansUpdateResponse::Http200(r#response.json::<VLAN>()?)) },
		_ => { Ok(IpamVlansUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a VLAN object.
pub fn ipam_vlans_destroy(state: &ThanixClient, id: i64) -> Result<IpamVlansDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/vlans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamVlansDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVlansPartialUpdateResponse {
	Http200(VLAN),
	#[default]
	None
}
/// Patch a VLAN object.
pub fn ipam_vlans_partial_update(state: &ThanixClient, body: PatchedWritableVLANRequest, id: i64) -> Result<IpamVlansPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/vlans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVlansPartialUpdateResponse::Http200(r#response.json::<VLAN>()?)) },
		_ => { Ok(IpamVlansPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct IpamVrfsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	enforce_unique: Option<bool>,
	/// Export target (name)
	export_target: Option<Vec<String>>,
	/// Export target (name)
	export_target__n: Option<Vec<String>>,
	/// Export target
	export_target_id: Option<Vec<i64>>,
	/// Export target
	export_target_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Import target (name)
	import_target: Option<Vec<String>>,
	/// Import target (name)
	import_target__n: Option<Vec<String>>,
	/// Import target
	import_target_id: Option<Vec<i64>>,
	/// Import target
	import_target_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	rd: Option<Vec<String>>,
	rd__empty: Option<bool>,
	rd__ic: Option<Vec<String>>,
	rd__ie: Option<Vec<String>>,
	rd__iew: Option<Vec<String>>,
	rd__isw: Option<Vec<String>>,
	rd__n: Option<Vec<String>>,
	rd__nic: Option<Vec<String>>,
	rd__nie: Option<Vec<String>>,
	rd__niew: Option<Vec<String>>,
	rd__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsListResponse {
	Http200(PaginatedVRFList),
	#[default]
	None
}
/// Get a list of VRF objects.
pub fn ipam_vrfs_list(state: &ThanixClient, query: IpamVrfsListQuery) -> Result<IpamVrfsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vrfs/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVrfsListResponse::Http200(r#response.json::<PaginatedVRFList>()?)) },
		_ => { Ok(IpamVrfsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsBulkUpdateResponse {
	Http200(Vec<VRF>),
	#[default]
	None
}
/// Put a list of VRF objects.
pub fn ipam_vrfs_bulk_update(state: &ThanixClient, body: Vec<VRFRequest>) -> Result<IpamVrfsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/vrfs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVrfsBulkUpdateResponse::Http200(r#response.json::<Vec<VRF>>()?)) },
		_ => { Ok(IpamVrfsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsCreateResponse {
	Http201(VRF),
	#[default]
	None
}
/// Post a list of VRF objects.
pub fn ipam_vrfs_create(state: &ThanixClient, body: WritableVRFRequest) -> Result<IpamVrfsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/ipam/vrfs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(IpamVrfsCreateResponse::Http201(r#response.json::<VRF>()?)) },
		_ => { Ok(IpamVrfsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of VRF objects.
pub fn ipam_vrfs_bulk_destroy(state: &ThanixClient, body: Vec<VRFRequest>) -> Result<IpamVrfsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/vrfs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamVrfsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsBulkPartialUpdateResponse {
	Http200(Vec<VRF>),
	#[default]
	None
}
/// Patch a list of VRF objects.
pub fn ipam_vrfs_bulk_partial_update(state: &ThanixClient, body: Vec<VRFRequest>) -> Result<IpamVrfsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/vrfs/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVrfsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VRF>>()?)) },
		_ => { Ok(IpamVrfsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsRetrieveResponse {
	Http200(VRF),
	#[default]
	None
}
/// Get a VRF object.
pub fn ipam_vrfs_retrieve(state: &ThanixClient, id: i64) -> Result<IpamVrfsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/ipam/vrfs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVrfsRetrieveResponse::Http200(r#response.json::<VRF>()?)) },
		_ => { Ok(IpamVrfsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsUpdateResponse {
	Http200(VRF),
	#[default]
	None
}
/// Put a VRF object.
pub fn ipam_vrfs_update(state: &ThanixClient, body: WritableVRFRequest, id: i64) -> Result<IpamVrfsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/ipam/vrfs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVrfsUpdateResponse::Http200(r#response.json::<VRF>()?)) },
		_ => { Ok(IpamVrfsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a VRF object.
pub fn ipam_vrfs_destroy(state: &ThanixClient, id: i64) -> Result<IpamVrfsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/ipam/vrfs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(IpamVrfsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum IpamVrfsPartialUpdateResponse {
	Http200(VRF),
	#[default]
	None
}
/// Patch a VRF object.
pub fn ipam_vrfs_partial_update(state: &ThanixClient, body: PatchedWritableVRFRequest, id: i64) -> Result<IpamVrfsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/ipam/vrfs/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(IpamVrfsPartialUpdateResponse::Http200(r#response.json::<VRF>()?)) },
		_ => { Ok(IpamVrfsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct SchemaRetrieveQuery {
	format: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum SchemaRetrieveResponse {
	Http200(String),
	#[default]
	None
}
/// OpenApi3 schema for this API. Format can be selected via content negotiation.
/// 
/// - YAML: application/vnd.oai.openapi
/// - JSON: application/vnd.oai.openapi+json
pub fn schema_retrieve(state: &ThanixClient, query: SchemaRetrieveQuery) -> Result<SchemaRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/schema/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(SchemaRetrieveResponse::Http200(r#response.json::<String>()?)) },
		_ => { Ok(SchemaRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum StatusRetrieveResponse {
	Http200(String),
	#[default]
	None
}
/// A lightweight read-only endpoint for conveying NetBox's current operational status.
pub fn status_retrieve(state: &ThanixClient) -> Result<StatusRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/status/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(StatusRetrieveResponse::Http200(r#response.json::<String>()?)) },
		_ => { Ok(StatusRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TenancyContactAssignmentsListQuery {
	/// Contact (ID)
	contact_id: Option<Vec<i64>>,
	/// Contact (ID)
	contact_id__n: Option<Vec<i64>>,
	content_type: Option<String>,
	content_type__n: Option<String>,
	content_type_id: Option<i64>,
	content_type_id__n: Option<i64>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	/// Contact group (slug)
	group: Option<Vec<i64>>,
	/// Contact group (slug)
	group__n: Option<Vec<i64>>,
	/// Contact group (ID)
	group_id: Option<Vec<i64>>,
	/// Contact group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	object_id: Option<Vec<i64>>,
	object_id__empty: Option<bool>,
	object_id__gt: Option<Vec<i64>>,
	object_id__gte: Option<Vec<i64>>,
	object_id__lt: Option<Vec<i64>>,
	object_id__lte: Option<Vec<i64>>,
	object_id__n: Option<Vec<i64>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	priority: Option<String>,
	priority__n: Option<String>,
	/// Search
	q: Option<String>,
	/// Contact role (slug)
	role: Option<Vec<String>>,
	/// Contact role (slug)
	role__n: Option<Vec<String>>,
	/// Contact role (ID)
	role_id: Option<Vec<i64>>,
	/// Contact role (ID)
	role_id__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsListResponse {
	Http200(PaginatedContactAssignmentList),
	#[default]
	None
}
/// Get a list of contact assignment objects.
pub fn tenancy_contact_assignments_list(state: &ThanixClient, query: TenancyContactAssignmentsListQuery) -> Result<TenancyContactAssignmentsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contact-assignments/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactAssignmentsListResponse::Http200(r#response.json::<PaginatedContactAssignmentList>()?)) },
		_ => { Ok(TenancyContactAssignmentsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsBulkUpdateResponse {
	Http200(Vec<ContactAssignment>),
	#[default]
	None
}
/// Put a list of contact assignment objects.
pub fn tenancy_contact_assignments_bulk_update(state: &ThanixClient, body: Vec<ContactAssignmentRequest>) -> Result<TenancyContactAssignmentsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contact-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactAssignmentsBulkUpdateResponse::Http200(r#response.json::<Vec<ContactAssignment>>()?)) },
		_ => { Ok(TenancyContactAssignmentsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsCreateResponse {
	Http201(ContactAssignment),
	#[default]
	None
}
/// Post a list of contact assignment objects.
pub fn tenancy_contact_assignments_create(state: &ThanixClient, body: WritableContactAssignmentRequest) -> Result<TenancyContactAssignmentsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/tenancy/contact-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(TenancyContactAssignmentsCreateResponse::Http201(r#response.json::<ContactAssignment>()?)) },
		_ => { Ok(TenancyContactAssignmentsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of contact assignment objects.
pub fn tenancy_contact_assignments_bulk_destroy(state: &ThanixClient, body: Vec<ContactAssignmentRequest>) -> Result<TenancyContactAssignmentsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contact-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactAssignmentsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsBulkPartialUpdateResponse {
	Http200(Vec<ContactAssignment>),
	#[default]
	None
}
/// Patch a list of contact assignment objects.
pub fn tenancy_contact_assignments_bulk_partial_update(state: &ThanixClient, body: Vec<ContactAssignmentRequest>) -> Result<TenancyContactAssignmentsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contact-assignments/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactAssignmentsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ContactAssignment>>()?)) },
		_ => { Ok(TenancyContactAssignmentsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsRetrieveResponse {
	Http200(ContactAssignment),
	#[default]
	None
}
/// Get a contact assignment object.
pub fn tenancy_contact_assignments_retrieve(state: &ThanixClient, id: i64) -> Result<TenancyContactAssignmentsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contact-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactAssignmentsRetrieveResponse::Http200(r#response.json::<ContactAssignment>()?)) },
		_ => { Ok(TenancyContactAssignmentsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsUpdateResponse {
	Http200(ContactAssignment),
	#[default]
	None
}
/// Put a contact assignment object.
pub fn tenancy_contact_assignments_update(state: &ThanixClient, body: WritableContactAssignmentRequest, id: i64) -> Result<TenancyContactAssignmentsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contact-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactAssignmentsUpdateResponse::Http200(r#response.json::<ContactAssignment>()?)) },
		_ => { Ok(TenancyContactAssignmentsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a contact assignment object.
pub fn tenancy_contact_assignments_destroy(state: &ThanixClient, id: i64) -> Result<TenancyContactAssignmentsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contact-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactAssignmentsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactAssignmentsPartialUpdateResponse {
	Http200(ContactAssignment),
	#[default]
	None
}
/// Patch a contact assignment object.
pub fn tenancy_contact_assignments_partial_update(state: &ThanixClient, body: PatchedWritableContactAssignmentRequest, id: i64) -> Result<TenancyContactAssignmentsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contact-assignments/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactAssignmentsPartialUpdateResponse::Http200(r#response.json::<ContactAssignment>()?)) },
		_ => { Ok(TenancyContactAssignmentsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TenancyContactGroupsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Contact group (slug)
	parent: Option<Vec<String>>,
	/// Contact group (slug)
	parent__n: Option<Vec<String>>,
	/// Contact group (ID)
	parent_id: Option<Vec<i64>>,
	/// Contact group (ID)
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsListResponse {
	Http200(PaginatedContactGroupList),
	#[default]
	None
}
/// Get a list of contact group objects.
pub fn tenancy_contact_groups_list(state: &ThanixClient, query: TenancyContactGroupsListQuery) -> Result<TenancyContactGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contact-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactGroupsListResponse::Http200(r#response.json::<PaginatedContactGroupList>()?)) },
		_ => { Ok(TenancyContactGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsBulkUpdateResponse {
	Http200(Vec<ContactGroup>),
	#[default]
	None
}
/// Put a list of contact group objects.
pub fn tenancy_contact_groups_bulk_update(state: &ThanixClient, body: Vec<ContactGroupRequest>) -> Result<TenancyContactGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contact-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<ContactGroup>>()?)) },
		_ => { Ok(TenancyContactGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsCreateResponse {
	Http201(ContactGroup),
	#[default]
	None
}
/// Post a list of contact group objects.
pub fn tenancy_contact_groups_create(state: &ThanixClient, body: WritableContactGroupRequest) -> Result<TenancyContactGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/tenancy/contact-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(TenancyContactGroupsCreateResponse::Http201(r#response.json::<ContactGroup>()?)) },
		_ => { Ok(TenancyContactGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of contact group objects.
pub fn tenancy_contact_groups_bulk_destroy(state: &ThanixClient, body: Vec<ContactGroupRequest>) -> Result<TenancyContactGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contact-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsBulkPartialUpdateResponse {
	Http200(Vec<ContactGroup>),
	#[default]
	None
}
/// Patch a list of contact group objects.
pub fn tenancy_contact_groups_bulk_partial_update(state: &ThanixClient, body: Vec<ContactGroupRequest>) -> Result<TenancyContactGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contact-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ContactGroup>>()?)) },
		_ => { Ok(TenancyContactGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsRetrieveResponse {
	Http200(ContactGroup),
	#[default]
	None
}
/// Get a contact group object.
pub fn tenancy_contact_groups_retrieve(state: &ThanixClient, id: i64) -> Result<TenancyContactGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contact-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactGroupsRetrieveResponse::Http200(r#response.json::<ContactGroup>()?)) },
		_ => { Ok(TenancyContactGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsUpdateResponse {
	Http200(ContactGroup),
	#[default]
	None
}
/// Put a contact group object.
pub fn tenancy_contact_groups_update(state: &ThanixClient, body: WritableContactGroupRequest, id: i64) -> Result<TenancyContactGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contact-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactGroupsUpdateResponse::Http200(r#response.json::<ContactGroup>()?)) },
		_ => { Ok(TenancyContactGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a contact group object.
pub fn tenancy_contact_groups_destroy(state: &ThanixClient, id: i64) -> Result<TenancyContactGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contact-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactGroupsPartialUpdateResponse {
	Http200(ContactGroup),
	#[default]
	None
}
/// Patch a contact group object.
pub fn tenancy_contact_groups_partial_update(state: &ThanixClient, body: PatchedWritableContactGroupRequest, id: i64) -> Result<TenancyContactGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contact-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactGroupsPartialUpdateResponse::Http200(r#response.json::<ContactGroup>()?)) },
		_ => { Ok(TenancyContactGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TenancyContactRolesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesListResponse {
	Http200(PaginatedContactRoleList),
	#[default]
	None
}
/// Get a list of contact role objects.
pub fn tenancy_contact_roles_list(state: &ThanixClient, query: TenancyContactRolesListQuery) -> Result<TenancyContactRolesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contact-roles/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactRolesListResponse::Http200(r#response.json::<PaginatedContactRoleList>()?)) },
		_ => { Ok(TenancyContactRolesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesBulkUpdateResponse {
	Http200(Vec<ContactRole>),
	#[default]
	None
}
/// Put a list of contact role objects.
pub fn tenancy_contact_roles_bulk_update(state: &ThanixClient, body: Vec<ContactRoleRequest>) -> Result<TenancyContactRolesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contact-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactRolesBulkUpdateResponse::Http200(r#response.json::<Vec<ContactRole>>()?)) },
		_ => { Ok(TenancyContactRolesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesCreateResponse {
	Http201(ContactRole),
	#[default]
	None
}
/// Post a list of contact role objects.
pub fn tenancy_contact_roles_create(state: &ThanixClient, body: ContactRoleRequest) -> Result<TenancyContactRolesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/tenancy/contact-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(TenancyContactRolesCreateResponse::Http201(r#response.json::<ContactRole>()?)) },
		_ => { Ok(TenancyContactRolesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of contact role objects.
pub fn tenancy_contact_roles_bulk_destroy(state: &ThanixClient, body: Vec<ContactRoleRequest>) -> Result<TenancyContactRolesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contact-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactRolesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesBulkPartialUpdateResponse {
	Http200(Vec<ContactRole>),
	#[default]
	None
}
/// Patch a list of contact role objects.
pub fn tenancy_contact_roles_bulk_partial_update(state: &ThanixClient, body: Vec<ContactRoleRequest>) -> Result<TenancyContactRolesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contact-roles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactRolesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ContactRole>>()?)) },
		_ => { Ok(TenancyContactRolesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesRetrieveResponse {
	Http200(ContactRole),
	#[default]
	None
}
/// Get a contact role object.
pub fn tenancy_contact_roles_retrieve(state: &ThanixClient, id: i64) -> Result<TenancyContactRolesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contact-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactRolesRetrieveResponse::Http200(r#response.json::<ContactRole>()?)) },
		_ => { Ok(TenancyContactRolesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesUpdateResponse {
	Http200(ContactRole),
	#[default]
	None
}
/// Put a contact role object.
pub fn tenancy_contact_roles_update(state: &ThanixClient, body: ContactRoleRequest, id: i64) -> Result<TenancyContactRolesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contact-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactRolesUpdateResponse::Http200(r#response.json::<ContactRole>()?)) },
		_ => { Ok(TenancyContactRolesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a contact role object.
pub fn tenancy_contact_roles_destroy(state: &ThanixClient, id: i64) -> Result<TenancyContactRolesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contact-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactRolesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactRolesPartialUpdateResponse {
	Http200(ContactRole),
	#[default]
	None
}
/// Patch a contact role object.
pub fn tenancy_contact_roles_partial_update(state: &ThanixClient, body: PatchedContactRoleRequest, id: i64) -> Result<TenancyContactRolesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contact-roles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactRolesPartialUpdateResponse::Http200(r#response.json::<ContactRole>()?)) },
		_ => { Ok(TenancyContactRolesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TenancyContactsListQuery {
	address: Option<Vec<String>>,
	address__empty: Option<bool>,
	address__ic: Option<Vec<String>>,
	address__ie: Option<Vec<String>>,
	address__iew: Option<Vec<String>>,
	address__isw: Option<Vec<String>>,
	address__n: Option<Vec<String>>,
	address__nic: Option<Vec<String>>,
	address__nie: Option<Vec<String>>,
	address__niew: Option<Vec<String>>,
	address__nisw: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	email: Option<Vec<String>>,
	email__empty: Option<bool>,
	email__ic: Option<Vec<String>>,
	email__ie: Option<Vec<String>>,
	email__iew: Option<Vec<String>>,
	email__isw: Option<Vec<String>>,
	email__n: Option<Vec<String>>,
	email__nic: Option<Vec<String>>,
	email__nie: Option<Vec<String>>,
	email__niew: Option<Vec<String>>,
	email__nisw: Option<Vec<String>>,
	/// Contact group (slug)
	group: Option<Vec<i64>>,
	/// Contact group (slug)
	group__n: Option<Vec<i64>>,
	/// Contact group (ID)
	group_id: Option<Vec<i64>>,
	/// Contact group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	link: Option<Vec<String>>,
	link__empty: Option<bool>,
	link__ic: Option<Vec<String>>,
	link__ie: Option<Vec<String>>,
	link__iew: Option<Vec<String>>,
	link__isw: Option<Vec<String>>,
	link__n: Option<Vec<String>>,
	link__nic: Option<Vec<String>>,
	link__nie: Option<Vec<String>>,
	link__niew: Option<Vec<String>>,
	link__nisw: Option<Vec<String>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	phone: Option<Vec<String>>,
	phone__empty: Option<bool>,
	phone__ic: Option<Vec<String>>,
	phone__ie: Option<Vec<String>>,
	phone__iew: Option<Vec<String>>,
	phone__isw: Option<Vec<String>>,
	phone__n: Option<Vec<String>>,
	phone__nic: Option<Vec<String>>,
	phone__nie: Option<Vec<String>>,
	phone__niew: Option<Vec<String>>,
	phone__nisw: Option<Vec<String>>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	title: Option<Vec<String>>,
	title__empty: Option<bool>,
	title__ic: Option<Vec<String>>,
	title__ie: Option<Vec<String>>,
	title__iew: Option<Vec<String>>,
	title__isw: Option<Vec<String>>,
	title__n: Option<Vec<String>>,
	title__nic: Option<Vec<String>>,
	title__nie: Option<Vec<String>>,
	title__niew: Option<Vec<String>>,
	title__nisw: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsListResponse {
	Http200(PaginatedContactList),
	#[default]
	None
}
/// Get a list of contact objects.
pub fn tenancy_contacts_list(state: &ThanixClient, query: TenancyContactsListQuery) -> Result<TenancyContactsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contacts/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactsListResponse::Http200(r#response.json::<PaginatedContactList>()?)) },
		_ => { Ok(TenancyContactsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsBulkUpdateResponse {
	Http200(Vec<Contact>),
	#[default]
	None
}
/// Put a list of contact objects.
pub fn tenancy_contacts_bulk_update(state: &ThanixClient, body: Vec<ContactRequest>) -> Result<TenancyContactsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contacts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactsBulkUpdateResponse::Http200(r#response.json::<Vec<Contact>>()?)) },
		_ => { Ok(TenancyContactsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsCreateResponse {
	Http201(Contact),
	#[default]
	None
}
/// Post a list of contact objects.
pub fn tenancy_contacts_create(state: &ThanixClient, body: WritableContactRequest) -> Result<TenancyContactsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/tenancy/contacts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(TenancyContactsCreateResponse::Http201(r#response.json::<Contact>()?)) },
		_ => { Ok(TenancyContactsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of contact objects.
pub fn tenancy_contacts_bulk_destroy(state: &ThanixClient, body: Vec<ContactRequest>) -> Result<TenancyContactsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contacts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsBulkPartialUpdateResponse {
	Http200(Vec<Contact>),
	#[default]
	None
}
/// Patch a list of contact objects.
pub fn tenancy_contacts_bulk_partial_update(state: &ThanixClient, body: Vec<ContactRequest>) -> Result<TenancyContactsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contacts/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Contact>>()?)) },
		_ => { Ok(TenancyContactsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsRetrieveResponse {
	Http200(Contact),
	#[default]
	None
}
/// Get a contact object.
pub fn tenancy_contacts_retrieve(state: &ThanixClient, id: i64) -> Result<TenancyContactsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/contacts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactsRetrieveResponse::Http200(r#response.json::<Contact>()?)) },
		_ => { Ok(TenancyContactsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsUpdateResponse {
	Http200(Contact),
	#[default]
	None
}
/// Put a contact object.
pub fn tenancy_contacts_update(state: &ThanixClient, body: WritableContactRequest, id: i64) -> Result<TenancyContactsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/contacts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactsUpdateResponse::Http200(r#response.json::<Contact>()?)) },
		_ => { Ok(TenancyContactsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a contact object.
pub fn tenancy_contacts_destroy(state: &ThanixClient, id: i64) -> Result<TenancyContactsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/contacts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyContactsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyContactsPartialUpdateResponse {
	Http200(Contact),
	#[default]
	None
}
/// Patch a contact object.
pub fn tenancy_contacts_partial_update(state: &ThanixClient, body: PatchedWritableContactRequest, id: i64) -> Result<TenancyContactsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/contacts/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyContactsPartialUpdateResponse::Http200(r#response.json::<Contact>()?)) },
		_ => { Ok(TenancyContactsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TenancyTenantGroupsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Tenant group (slug)
	parent: Option<Vec<String>>,
	/// Tenant group (slug)
	parent__n: Option<Vec<String>>,
	/// Tenant group (ID)
	parent_id: Option<Vec<i64>>,
	/// Tenant group (ID)
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsListResponse {
	Http200(PaginatedTenantGroupList),
	#[default]
	None
}
/// Get a list of tenant group objects.
pub fn tenancy_tenant_groups_list(state: &ThanixClient, query: TenancyTenantGroupsListQuery) -> Result<TenancyTenantGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/tenant-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantGroupsListResponse::Http200(r#response.json::<PaginatedTenantGroupList>()?)) },
		_ => { Ok(TenancyTenantGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsBulkUpdateResponse {
	Http200(Vec<TenantGroup>),
	#[default]
	None
}
/// Put a list of tenant group objects.
pub fn tenancy_tenant_groups_bulk_update(state: &ThanixClient, body: Vec<TenantGroupRequest>) -> Result<TenancyTenantGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/tenant-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<TenantGroup>>()?)) },
		_ => { Ok(TenancyTenantGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsCreateResponse {
	Http201(TenantGroup),
	#[default]
	None
}
/// Post a list of tenant group objects.
pub fn tenancy_tenant_groups_create(state: &ThanixClient, body: WritableTenantGroupRequest) -> Result<TenancyTenantGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/tenancy/tenant-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(TenancyTenantGroupsCreateResponse::Http201(r#response.json::<TenantGroup>()?)) },
		_ => { Ok(TenancyTenantGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of tenant group objects.
pub fn tenancy_tenant_groups_bulk_destroy(state: &ThanixClient, body: Vec<TenantGroupRequest>) -> Result<TenancyTenantGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/tenant-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyTenantGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsBulkPartialUpdateResponse {
	Http200(Vec<TenantGroup>),
	#[default]
	None
}
/// Patch a list of tenant group objects.
pub fn tenancy_tenant_groups_bulk_partial_update(state: &ThanixClient, body: Vec<TenantGroupRequest>) -> Result<TenancyTenantGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/tenant-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<TenantGroup>>()?)) },
		_ => { Ok(TenancyTenantGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsRetrieveResponse {
	Http200(TenantGroup),
	#[default]
	None
}
/// Get a tenant group object.
pub fn tenancy_tenant_groups_retrieve(state: &ThanixClient, id: i64) -> Result<TenancyTenantGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/tenant-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantGroupsRetrieveResponse::Http200(r#response.json::<TenantGroup>()?)) },
		_ => { Ok(TenancyTenantGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsUpdateResponse {
	Http200(TenantGroup),
	#[default]
	None
}
/// Put a tenant group object.
pub fn tenancy_tenant_groups_update(state: &ThanixClient, body: WritableTenantGroupRequest, id: i64) -> Result<TenancyTenantGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/tenant-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantGroupsUpdateResponse::Http200(r#response.json::<TenantGroup>()?)) },
		_ => { Ok(TenancyTenantGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a tenant group object.
pub fn tenancy_tenant_groups_destroy(state: &ThanixClient, id: i64) -> Result<TenancyTenantGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/tenant-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyTenantGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantGroupsPartialUpdateResponse {
	Http200(TenantGroup),
	#[default]
	None
}
/// Patch a tenant group object.
pub fn tenancy_tenant_groups_partial_update(state: &ThanixClient, body: PatchedWritableTenantGroupRequest, id: i64) -> Result<TenancyTenantGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/tenant-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantGroupsPartialUpdateResponse::Http200(r#response.json::<TenantGroup>()?)) },
		_ => { Ok(TenancyTenantGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct TenancyTenantsListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Tenant group (slug)
	group: Option<Vec<i64>>,
	/// Tenant group (slug)
	group__n: Option<Vec<i64>>,
	/// Tenant group (ID)
	group_id: Option<Vec<i64>>,
	/// Tenant group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsListResponse {
	Http200(PaginatedTenantList),
	#[default]
	None
}
/// Get a list of tenant objects.
pub fn tenancy_tenants_list(state: &ThanixClient, query: TenancyTenantsListQuery) -> Result<TenancyTenantsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/tenants/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantsListResponse::Http200(r#response.json::<PaginatedTenantList>()?)) },
		_ => { Ok(TenancyTenantsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsBulkUpdateResponse {
	Http200(Vec<Tenant>),
	#[default]
	None
}
/// Put a list of tenant objects.
pub fn tenancy_tenants_bulk_update(state: &ThanixClient, body: Vec<TenantRequest>) -> Result<TenancyTenantsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/tenants/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantsBulkUpdateResponse::Http200(r#response.json::<Vec<Tenant>>()?)) },
		_ => { Ok(TenancyTenantsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsCreateResponse {
	Http201(Tenant),
	#[default]
	None
}
/// Post a list of tenant objects.
pub fn tenancy_tenants_create(state: &ThanixClient, body: WritableTenantRequest) -> Result<TenancyTenantsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/tenancy/tenants/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(TenancyTenantsCreateResponse::Http201(r#response.json::<Tenant>()?)) },
		_ => { Ok(TenancyTenantsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of tenant objects.
pub fn tenancy_tenants_bulk_destroy(state: &ThanixClient, body: Vec<TenantRequest>) -> Result<TenancyTenantsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/tenants/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyTenantsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsBulkPartialUpdateResponse {
	Http200(Vec<Tenant>),
	#[default]
	None
}
/// Patch a list of tenant objects.
pub fn tenancy_tenants_bulk_partial_update(state: &ThanixClient, body: Vec<TenantRequest>) -> Result<TenancyTenantsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/tenants/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Tenant>>()?)) },
		_ => { Ok(TenancyTenantsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsRetrieveResponse {
	Http200(Tenant),
	#[default]
	None
}
/// Get a tenant object.
pub fn tenancy_tenants_retrieve(state: &ThanixClient, id: i64) -> Result<TenancyTenantsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/tenancy/tenants/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantsRetrieveResponse::Http200(r#response.json::<Tenant>()?)) },
		_ => { Ok(TenancyTenantsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsUpdateResponse {
	Http200(Tenant),
	#[default]
	None
}
/// Put a tenant object.
pub fn tenancy_tenants_update(state: &ThanixClient, body: WritableTenantRequest, id: i64) -> Result<TenancyTenantsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/tenancy/tenants/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantsUpdateResponse::Http200(r#response.json::<Tenant>()?)) },
		_ => { Ok(TenancyTenantsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a tenant object.
pub fn tenancy_tenants_destroy(state: &ThanixClient, id: i64) -> Result<TenancyTenantsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/tenancy/tenants/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(TenancyTenantsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum TenancyTenantsPartialUpdateResponse {
	Http200(Tenant),
	#[default]
	None
}
/// Patch a tenant object.
pub fn tenancy_tenants_partial_update(state: &ThanixClient, body: PatchedWritableTenantRequest, id: i64) -> Result<TenancyTenantsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/tenancy/tenants/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(TenancyTenantsPartialUpdateResponse::Http200(r#response.json::<Tenant>()?)) },
		_ => { Ok(TenancyTenantsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersConfigRetrieveResponse {
	Http200(String),
	#[default]
	None
}
/// An API endpoint via which a user can update his or her own UserConfig data (but no one else's).
pub fn users_config_retrieve(state: &ThanixClient) -> Result<UsersConfigRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/config/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersConfigRetrieveResponse::Http200(r#response.json::<String>()?)) },
		_ => { Ok(UsersConfigRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct UsersGroupsListQuery {
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsListResponse {
	Http200(PaginatedGroupList),
	#[default]
	None
}
/// Get a list of group objects.
pub fn users_groups_list(state: &ThanixClient, query: UsersGroupsListQuery) -> Result<UsersGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersGroupsListResponse::Http200(r#response.json::<PaginatedGroupList>()?)) },
		_ => { Ok(UsersGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsBulkUpdateResponse {
	Http200(Vec<Group>),
	#[default]
	None
}
/// Put a list of group objects.
pub fn users_groups_bulk_update(state: &ThanixClient, body: Vec<GroupRequest>) -> Result<UsersGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<Group>>()?)) },
		_ => { Ok(UsersGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsCreateResponse {
	Http201(Group),
	#[default]
	None
}
/// Post a list of group objects.
pub fn users_groups_create(state: &ThanixClient, body: GroupRequest) -> Result<UsersGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/users/groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(UsersGroupsCreateResponse::Http201(r#response.json::<Group>()?)) },
		_ => { Ok(UsersGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of group objects.
pub fn users_groups_bulk_destroy(state: &ThanixClient, body: Vec<GroupRequest>) -> Result<UsersGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsBulkPartialUpdateResponse {
	Http200(Vec<Group>),
	#[default]
	None
}
/// Patch a list of group objects.
pub fn users_groups_bulk_partial_update(state: &ThanixClient, body: Vec<GroupRequest>) -> Result<UsersGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Group>>()?)) },
		_ => { Ok(UsersGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsRetrieveResponse {
	Http200(Group),
	#[default]
	None
}
/// Get a group object.
pub fn users_groups_retrieve(state: &ThanixClient, id: i64) -> Result<UsersGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersGroupsRetrieveResponse::Http200(r#response.json::<Group>()?)) },
		_ => { Ok(UsersGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsUpdateResponse {
	Http200(Group),
	#[default]
	None
}
/// Put a group object.
pub fn users_groups_update(state: &ThanixClient, body: GroupRequest, id: i64) -> Result<UsersGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersGroupsUpdateResponse::Http200(r#response.json::<Group>()?)) },
		_ => { Ok(UsersGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a group object.
pub fn users_groups_destroy(state: &ThanixClient, id: i64) -> Result<UsersGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersGroupsPartialUpdateResponse {
	Http200(Group),
	#[default]
	None
}
/// Patch a group object.
pub fn users_groups_partial_update(state: &ThanixClient, body: PatchedGroupRequest, id: i64) -> Result<UsersGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersGroupsPartialUpdateResponse::Http200(r#response.json::<Group>()?)) },
		_ => { Ok(UsersGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct UsersPermissionsListQuery {
	can_add: Option<bool>,
	can_change: Option<bool>,
	can_delete: Option<bool>,
	can_view: Option<bool>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	enabled: Option<bool>,
	/// Group (name)
	group: Option<Vec<String>>,
	/// Group (name)
	group__n: Option<Vec<String>>,
	/// Group
	group_id: Option<Vec<i64>>,
	/// Group
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	object_types: Option<Vec<i64>>,
	object_types__n: Option<Vec<i64>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// User (name)
	user: Option<Vec<String>>,
	/// User (name)
	user__n: Option<Vec<String>>,
	/// User
	user_id: Option<Vec<i64>>,
	/// User
	user_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsListResponse {
	Http200(PaginatedObjectPermissionList),
	#[default]
	None
}
/// Get a list of permission objects.
pub fn users_permissions_list(state: &ThanixClient, query: UsersPermissionsListQuery) -> Result<UsersPermissionsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/permissions/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersPermissionsListResponse::Http200(r#response.json::<PaginatedObjectPermissionList>()?)) },
		_ => { Ok(UsersPermissionsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsBulkUpdateResponse {
	Http200(Vec<ObjectPermission>),
	#[default]
	None
}
/// Put a list of permission objects.
pub fn users_permissions_bulk_update(state: &ThanixClient, body: Vec<ObjectPermissionRequest>) -> Result<UsersPermissionsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/permissions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersPermissionsBulkUpdateResponse::Http200(r#response.json::<Vec<ObjectPermission>>()?)) },
		_ => { Ok(UsersPermissionsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsCreateResponse {
	Http201(ObjectPermission),
	#[default]
	None
}
/// Post a list of permission objects.
pub fn users_permissions_create(state: &ThanixClient, body: WritableObjectPermissionRequest) -> Result<UsersPermissionsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/users/permissions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(UsersPermissionsCreateResponse::Http201(r#response.json::<ObjectPermission>()?)) },
		_ => { Ok(UsersPermissionsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of permission objects.
pub fn users_permissions_bulk_destroy(state: &ThanixClient, body: Vec<ObjectPermissionRequest>) -> Result<UsersPermissionsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/permissions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersPermissionsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsBulkPartialUpdateResponse {
	Http200(Vec<ObjectPermission>),
	#[default]
	None
}
/// Patch a list of permission objects.
pub fn users_permissions_bulk_partial_update(state: &ThanixClient, body: Vec<ObjectPermissionRequest>) -> Result<UsersPermissionsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/permissions/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersPermissionsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ObjectPermission>>()?)) },
		_ => { Ok(UsersPermissionsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsRetrieveResponse {
	Http200(ObjectPermission),
	#[default]
	None
}
/// Get a permission object.
pub fn users_permissions_retrieve(state: &ThanixClient, id: i64) -> Result<UsersPermissionsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/permissions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersPermissionsRetrieveResponse::Http200(r#response.json::<ObjectPermission>()?)) },
		_ => { Ok(UsersPermissionsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsUpdateResponse {
	Http200(ObjectPermission),
	#[default]
	None
}
/// Put a permission object.
pub fn users_permissions_update(state: &ThanixClient, body: WritableObjectPermissionRequest, id: i64) -> Result<UsersPermissionsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/permissions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersPermissionsUpdateResponse::Http200(r#response.json::<ObjectPermission>()?)) },
		_ => { Ok(UsersPermissionsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a permission object.
pub fn users_permissions_destroy(state: &ThanixClient, id: i64) -> Result<UsersPermissionsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/permissions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersPermissionsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersPermissionsPartialUpdateResponse {
	Http200(ObjectPermission),
	#[default]
	None
}
/// Patch a permission object.
pub fn users_permissions_partial_update(state: &ThanixClient, body: PatchedWritableObjectPermissionRequest, id: i64) -> Result<UsersPermissionsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/permissions/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersPermissionsPartialUpdateResponse::Http200(r#response.json::<ObjectPermission>()?)) },
		_ => { Ok(UsersPermissionsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct UsersTokensListQuery {
	created: Option<String>,
	created__gte: Option<String>,
	created__lte: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	expires: Option<String>,
	expires__gte: Option<String>,
	expires__lte: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	key: Option<Vec<String>>,
	key__empty: Option<bool>,
	key__ic: Option<Vec<String>>,
	key__ie: Option<Vec<String>>,
	key__iew: Option<Vec<String>>,
	key__isw: Option<Vec<String>>,
	key__n: Option<Vec<String>>,
	key__nic: Option<Vec<String>>,
	key__nie: Option<Vec<String>>,
	key__niew: Option<Vec<String>>,
	key__nisw: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// User (name)
	user: Option<Vec<String>>,
	/// User (name)
	user__n: Option<Vec<String>>,
	/// User
	user_id: Option<Vec<i64>>,
	/// User
	user_id__n: Option<Vec<i64>>,
	write_enabled: Option<bool>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensListResponse {
	Http200(PaginatedTokenList),
	#[default]
	None
}
/// Get a list of token objects.
pub fn users_tokens_list(state: &ThanixClient, query: UsersTokensListQuery) -> Result<UsersTokensListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/tokens/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersTokensListResponse::Http200(r#response.json::<PaginatedTokenList>()?)) },
		_ => { Ok(UsersTokensListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensBulkUpdateResponse {
	Http200(Vec<Token>),
	#[default]
	None
}
/// Put a list of token objects.
pub fn users_tokens_bulk_update(state: &ThanixClient, body: Vec<TokenRequest>) -> Result<UsersTokensBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/tokens/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersTokensBulkUpdateResponse::Http200(r#response.json::<Vec<Token>>()?)) },
		_ => { Ok(UsersTokensBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensCreateResponse {
	Http201(Token),
	#[default]
	None
}
/// Post a list of token objects.
pub fn users_tokens_create(state: &ThanixClient, body: WritableTokenRequest) -> Result<UsersTokensCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/users/tokens/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(UsersTokensCreateResponse::Http201(r#response.json::<Token>()?)) },
		_ => { Ok(UsersTokensCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of token objects.
pub fn users_tokens_bulk_destroy(state: &ThanixClient, body: Vec<TokenRequest>) -> Result<UsersTokensBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/tokens/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersTokensBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensBulkPartialUpdateResponse {
	Http200(Vec<Token>),
	#[default]
	None
}
/// Patch a list of token objects.
pub fn users_tokens_bulk_partial_update(state: &ThanixClient, body: Vec<TokenRequest>) -> Result<UsersTokensBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/tokens/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersTokensBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Token>>()?)) },
		_ => { Ok(UsersTokensBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensRetrieveResponse {
	Http200(Token),
	#[default]
	None
}
/// Get a token object.
pub fn users_tokens_retrieve(state: &ThanixClient, id: i64) -> Result<UsersTokensRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/tokens/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersTokensRetrieveResponse::Http200(r#response.json::<Token>()?)) },
		_ => { Ok(UsersTokensRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensUpdateResponse {
	Http200(Token),
	#[default]
	None
}
/// Put a token object.
pub fn users_tokens_update(state: &ThanixClient, body: WritableTokenRequest, id: i64) -> Result<UsersTokensUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/tokens/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersTokensUpdateResponse::Http200(r#response.json::<Token>()?)) },
		_ => { Ok(UsersTokensUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a token object.
pub fn users_tokens_destroy(state: &ThanixClient, id: i64) -> Result<UsersTokensDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/tokens/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersTokensDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensPartialUpdateResponse {
	Http200(Token),
	#[default]
	None
}
/// Patch a token object.
pub fn users_tokens_partial_update(state: &ThanixClient, body: PatchedWritableTokenRequest, id: i64) -> Result<UsersTokensPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/tokens/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersTokensPartialUpdateResponse::Http200(r#response.json::<Token>()?)) },
		_ => { Ok(UsersTokensPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersTokensProvisionCreateResponse {
	Http201(TokenProvision),
	Http401(String),
	#[default]
	None
}
/// Non-authenticated REST API endpoint via which a user may create a Token.
pub fn users_tokens_provision_create(state: &ThanixClient, body: TokenProvisionRequest) -> Result<UsersTokensProvisionCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/users/tokens/provision/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(UsersTokensProvisionCreateResponse::Http201(r#response.json::<TokenProvision>()?)) },
		401 => { Ok(UsersTokensProvisionCreateResponse::Http401(r#response.json::<String>()?)) },
		_ => { Ok(UsersTokensProvisionCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct UsersUsersListQuery {
	email: Option<Vec<String>>,
	email__empty: Option<bool>,
	email__ic: Option<Vec<String>>,
	email__ie: Option<Vec<String>>,
	email__iew: Option<Vec<String>>,
	email__isw: Option<Vec<String>>,
	email__n: Option<Vec<String>>,
	email__nic: Option<Vec<String>>,
	email__nie: Option<Vec<String>>,
	email__niew: Option<Vec<String>>,
	email__nisw: Option<Vec<String>>,
	first_name: Option<Vec<String>>,
	first_name__empty: Option<bool>,
	first_name__ic: Option<Vec<String>>,
	first_name__ie: Option<Vec<String>>,
	first_name__iew: Option<Vec<String>>,
	first_name__isw: Option<Vec<String>>,
	first_name__n: Option<Vec<String>>,
	first_name__nic: Option<Vec<String>>,
	first_name__nie: Option<Vec<String>>,
	first_name__niew: Option<Vec<String>>,
	first_name__nisw: Option<Vec<String>>,
	/// Group (name)
	group: Option<Vec<String>>,
	/// Group (name)
	group__n: Option<Vec<String>>,
	/// Group
	group_id: Option<Vec<i64>>,
	/// Group
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	is_active: Option<bool>,
	is_staff: Option<bool>,
	is_superuser: Option<bool>,
	last_name: Option<Vec<String>>,
	last_name__empty: Option<bool>,
	last_name__ic: Option<Vec<String>>,
	last_name__ie: Option<Vec<String>>,
	last_name__iew: Option<Vec<String>>,
	last_name__isw: Option<Vec<String>>,
	last_name__n: Option<Vec<String>>,
	last_name__nic: Option<Vec<String>>,
	last_name__nie: Option<Vec<String>>,
	last_name__niew: Option<Vec<String>>,
	last_name__nisw: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	username: Option<Vec<String>>,
	username__empty: Option<bool>,
	username__ic: Option<Vec<String>>,
	username__ie: Option<Vec<String>>,
	username__iew: Option<Vec<String>>,
	username__isw: Option<Vec<String>>,
	username__n: Option<Vec<String>>,
	username__nic: Option<Vec<String>>,
	username__nie: Option<Vec<String>>,
	username__niew: Option<Vec<String>>,
	username__nisw: Option<Vec<String>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersListResponse {
	Http200(PaginatedUserList),
	#[default]
	None
}
/// Get a list of user objects.
pub fn users_users_list(state: &ThanixClient, query: UsersUsersListQuery) -> Result<UsersUsersListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/users/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersUsersListResponse::Http200(r#response.json::<PaginatedUserList>()?)) },
		_ => { Ok(UsersUsersListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersBulkUpdateResponse {
	Http200(Vec<User>),
	#[default]
	None
}
/// Put a list of user objects.
pub fn users_users_bulk_update(state: &ThanixClient, body: Vec<UserRequest>) -> Result<UsersUsersBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/users/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersUsersBulkUpdateResponse::Http200(r#response.json::<Vec<User>>()?)) },
		_ => { Ok(UsersUsersBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersCreateResponse {
	Http201(User),
	#[default]
	None
}
/// Post a list of user objects.
pub fn users_users_create(state: &ThanixClient, body: WritableUserRequest) -> Result<UsersUsersCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/users/users/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(UsersUsersCreateResponse::Http201(r#response.json::<User>()?)) },
		_ => { Ok(UsersUsersCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of user objects.
pub fn users_users_bulk_destroy(state: &ThanixClient, body: Vec<UserRequest>) -> Result<UsersUsersBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/users/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersUsersBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersBulkPartialUpdateResponse {
	Http200(Vec<User>),
	#[default]
	None
}
/// Patch a list of user objects.
pub fn users_users_bulk_partial_update(state: &ThanixClient, body: Vec<UserRequest>) -> Result<UsersUsersBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/users/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersUsersBulkPartialUpdateResponse::Http200(r#response.json::<Vec<User>>()?)) },
		_ => { Ok(UsersUsersBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersRetrieveResponse {
	Http200(User),
	#[default]
	None
}
/// Get a user object.
pub fn users_users_retrieve(state: &ThanixClient, id: i64) -> Result<UsersUsersRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/users/users/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersUsersRetrieveResponse::Http200(r#response.json::<User>()?)) },
		_ => { Ok(UsersUsersRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersUpdateResponse {
	Http200(User),
	#[default]
	None
}
/// Put a user object.
pub fn users_users_update(state: &ThanixClient, body: WritableUserRequest, id: i64) -> Result<UsersUsersUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/users/users/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersUsersUpdateResponse::Http200(r#response.json::<User>()?)) },
		_ => { Ok(UsersUsersUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a user object.
pub fn users_users_destroy(state: &ThanixClient, id: i64) -> Result<UsersUsersDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/users/users/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(UsersUsersDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum UsersUsersPartialUpdateResponse {
	Http200(User),
	#[default]
	None
}
/// Patch a user object.
pub fn users_users_partial_update(state: &ThanixClient, body: PatchedWritableUserRequest, id: i64) -> Result<UsersUsersPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/users/users/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(UsersUsersPartialUpdateResponse::Http200(r#response.json::<User>()?)) },
		_ => { Ok(UsersUsersPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationClusterGroupsListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsListResponse {
	Http200(PaginatedClusterGroupList),
	#[default]
	None
}
/// Get a list of cluster group objects.
pub fn virtualization_cluster_groups_list(state: &ThanixClient, query: VirtualizationClusterGroupsListQuery) -> Result<VirtualizationClusterGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/cluster-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterGroupsListResponse::Http200(r#response.json::<PaginatedClusterGroupList>()?)) },
		_ => { Ok(VirtualizationClusterGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsBulkUpdateResponse {
	Http200(Vec<ClusterGroup>),
	#[default]
	None
}
/// Put a list of cluster group objects.
pub fn virtualization_cluster_groups_bulk_update(state: &ThanixClient, body: Vec<ClusterGroupRequest>) -> Result<VirtualizationClusterGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/cluster-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<ClusterGroup>>()?)) },
		_ => { Ok(VirtualizationClusterGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsCreateResponse {
	Http201(ClusterGroup),
	#[default]
	None
}
/// Post a list of cluster group objects.
pub fn virtualization_cluster_groups_create(state: &ThanixClient, body: ClusterGroupRequest) -> Result<VirtualizationClusterGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/cluster-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VirtualizationClusterGroupsCreateResponse::Http201(r#response.json::<ClusterGroup>()?)) },
		_ => { Ok(VirtualizationClusterGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of cluster group objects.
pub fn virtualization_cluster_groups_bulk_destroy(state: &ThanixClient, body: Vec<ClusterGroupRequest>) -> Result<VirtualizationClusterGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/cluster-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationClusterGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsBulkPartialUpdateResponse {
	Http200(Vec<ClusterGroup>),
	#[default]
	None
}
/// Patch a list of cluster group objects.
pub fn virtualization_cluster_groups_bulk_partial_update(state: &ThanixClient, body: Vec<ClusterGroupRequest>) -> Result<VirtualizationClusterGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/cluster-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ClusterGroup>>()?)) },
		_ => { Ok(VirtualizationClusterGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsRetrieveResponse {
	Http200(ClusterGroup),
	#[default]
	None
}
/// Get a cluster group object.
pub fn virtualization_cluster_groups_retrieve(state: &ThanixClient, id: i64) -> Result<VirtualizationClusterGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/cluster-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterGroupsRetrieveResponse::Http200(r#response.json::<ClusterGroup>()?)) },
		_ => { Ok(VirtualizationClusterGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsUpdateResponse {
	Http200(ClusterGroup),
	#[default]
	None
}
/// Put a cluster group object.
pub fn virtualization_cluster_groups_update(state: &ThanixClient, body: ClusterGroupRequest, id: i64) -> Result<VirtualizationClusterGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/cluster-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterGroupsUpdateResponse::Http200(r#response.json::<ClusterGroup>()?)) },
		_ => { Ok(VirtualizationClusterGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a cluster group object.
pub fn virtualization_cluster_groups_destroy(state: &ThanixClient, id: i64) -> Result<VirtualizationClusterGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/cluster-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationClusterGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterGroupsPartialUpdateResponse {
	Http200(ClusterGroup),
	#[default]
	None
}
/// Patch a cluster group object.
pub fn virtualization_cluster_groups_partial_update(state: &ThanixClient, body: PatchedClusterGroupRequest, id: i64) -> Result<VirtualizationClusterGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/cluster-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterGroupsPartialUpdateResponse::Http200(r#response.json::<ClusterGroup>()?)) },
		_ => { Ok(VirtualizationClusterGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationClusterTypesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesListResponse {
	Http200(PaginatedClusterTypeList),
	#[default]
	None
}
/// Get a list of cluster type objects.
pub fn virtualization_cluster_types_list(state: &ThanixClient, query: VirtualizationClusterTypesListQuery) -> Result<VirtualizationClusterTypesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/cluster-types/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterTypesListResponse::Http200(r#response.json::<PaginatedClusterTypeList>()?)) },
		_ => { Ok(VirtualizationClusterTypesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesBulkUpdateResponse {
	Http200(Vec<ClusterType>),
	#[default]
	None
}
/// Put a list of cluster type objects.
pub fn virtualization_cluster_types_bulk_update(state: &ThanixClient, body: Vec<ClusterTypeRequest>) -> Result<VirtualizationClusterTypesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/cluster-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterTypesBulkUpdateResponse::Http200(r#response.json::<Vec<ClusterType>>()?)) },
		_ => { Ok(VirtualizationClusterTypesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesCreateResponse {
	Http201(ClusterType),
	#[default]
	None
}
/// Post a list of cluster type objects.
pub fn virtualization_cluster_types_create(state: &ThanixClient, body: ClusterTypeRequest) -> Result<VirtualizationClusterTypesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/cluster-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VirtualizationClusterTypesCreateResponse::Http201(r#response.json::<ClusterType>()?)) },
		_ => { Ok(VirtualizationClusterTypesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of cluster type objects.
pub fn virtualization_cluster_types_bulk_destroy(state: &ThanixClient, body: Vec<ClusterTypeRequest>) -> Result<VirtualizationClusterTypesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/cluster-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationClusterTypesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesBulkPartialUpdateResponse {
	Http200(Vec<ClusterType>),
	#[default]
	None
}
/// Patch a list of cluster type objects.
pub fn virtualization_cluster_types_bulk_partial_update(state: &ThanixClient, body: Vec<ClusterTypeRequest>) -> Result<VirtualizationClusterTypesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/cluster-types/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterTypesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<ClusterType>>()?)) },
		_ => { Ok(VirtualizationClusterTypesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesRetrieveResponse {
	Http200(ClusterType),
	#[default]
	None
}
/// Get a cluster type object.
pub fn virtualization_cluster_types_retrieve(state: &ThanixClient, id: i64) -> Result<VirtualizationClusterTypesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/cluster-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterTypesRetrieveResponse::Http200(r#response.json::<ClusterType>()?)) },
		_ => { Ok(VirtualizationClusterTypesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesUpdateResponse {
	Http200(ClusterType),
	#[default]
	None
}
/// Put a cluster type object.
pub fn virtualization_cluster_types_update(state: &ThanixClient, body: ClusterTypeRequest, id: i64) -> Result<VirtualizationClusterTypesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/cluster-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterTypesUpdateResponse::Http200(r#response.json::<ClusterType>()?)) },
		_ => { Ok(VirtualizationClusterTypesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a cluster type object.
pub fn virtualization_cluster_types_destroy(state: &ThanixClient, id: i64) -> Result<VirtualizationClusterTypesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/cluster-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationClusterTypesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClusterTypesPartialUpdateResponse {
	Http200(ClusterType),
	#[default]
	None
}
/// Patch a cluster type object.
pub fn virtualization_cluster_types_partial_update(state: &ThanixClient, body: PatchedClusterTypeRequest, id: i64) -> Result<VirtualizationClusterTypesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/cluster-types/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClusterTypesPartialUpdateResponse::Http200(r#response.json::<ClusterType>()?)) },
		_ => { Ok(VirtualizationClusterTypesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationClustersListQuery {
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Parent group (slug)
	group: Option<Vec<String>>,
	/// Parent group (slug)
	group__n: Option<Vec<String>>,
	/// Parent group (ID)
	group_id: Option<Vec<i64>>,
	/// Parent group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	/// Cluster type (slug)
	r#type: Option<Vec<String>>,
	/// Cluster type (slug)
	type__n: Option<Vec<String>>,
	/// Cluster type (ID)
	type_id: Option<Vec<i64>>,
	/// Cluster type (ID)
	type_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersListResponse {
	Http200(PaginatedClusterList),
	#[default]
	None
}
/// Get a list of cluster objects.
pub fn virtualization_clusters_list(state: &ThanixClient, query: VirtualizationClustersListQuery) -> Result<VirtualizationClustersListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/clusters/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClustersListResponse::Http200(r#response.json::<PaginatedClusterList>()?)) },
		_ => { Ok(VirtualizationClustersListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersBulkUpdateResponse {
	Http200(Vec<Cluster>),
	#[default]
	None
}
/// Put a list of cluster objects.
pub fn virtualization_clusters_bulk_update(state: &ThanixClient, body: Vec<ClusterRequest>) -> Result<VirtualizationClustersBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/clusters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClustersBulkUpdateResponse::Http200(r#response.json::<Vec<Cluster>>()?)) },
		_ => { Ok(VirtualizationClustersBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersCreateResponse {
	Http201(Cluster),
	#[default]
	None
}
/// Post a list of cluster objects.
pub fn virtualization_clusters_create(state: &ThanixClient, body: WritableClusterRequest) -> Result<VirtualizationClustersCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/clusters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VirtualizationClustersCreateResponse::Http201(r#response.json::<Cluster>()?)) },
		_ => { Ok(VirtualizationClustersCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of cluster objects.
pub fn virtualization_clusters_bulk_destroy(state: &ThanixClient, body: Vec<ClusterRequest>) -> Result<VirtualizationClustersBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/clusters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationClustersBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersBulkPartialUpdateResponse {
	Http200(Vec<Cluster>),
	#[default]
	None
}
/// Patch a list of cluster objects.
pub fn virtualization_clusters_bulk_partial_update(state: &ThanixClient, body: Vec<ClusterRequest>) -> Result<VirtualizationClustersBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/clusters/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClustersBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Cluster>>()?)) },
		_ => { Ok(VirtualizationClustersBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersRetrieveResponse {
	Http200(Cluster),
	#[default]
	None
}
/// Get a cluster object.
pub fn virtualization_clusters_retrieve(state: &ThanixClient, id: i64) -> Result<VirtualizationClustersRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/clusters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClustersRetrieveResponse::Http200(r#response.json::<Cluster>()?)) },
		_ => { Ok(VirtualizationClustersRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersUpdateResponse {
	Http200(Cluster),
	#[default]
	None
}
/// Put a cluster object.
pub fn virtualization_clusters_update(state: &ThanixClient, body: WritableClusterRequest, id: i64) -> Result<VirtualizationClustersUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/clusters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClustersUpdateResponse::Http200(r#response.json::<Cluster>()?)) },
		_ => { Ok(VirtualizationClustersUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a cluster object.
pub fn virtualization_clusters_destroy(state: &ThanixClient, id: i64) -> Result<VirtualizationClustersDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/clusters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationClustersDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationClustersPartialUpdateResponse {
	Http200(Cluster),
	#[default]
	None
}
/// Patch a cluster object.
pub fn virtualization_clusters_partial_update(state: &ThanixClient, body: PatchedWritableClusterRequest, id: i64) -> Result<VirtualizationClustersPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/clusters/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationClustersPartialUpdateResponse::Http200(r#response.json::<Cluster>()?)) },
		_ => { Ok(VirtualizationClustersPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationInterfacesListQuery {
	/// Bridged interface (ID)
	bridge_id: Option<Vec<i64>>,
	/// Bridged interface (ID)
	bridge_id__n: Option<Vec<i64>>,
	/// Cluster
	cluster: Option<Vec<String>>,
	/// Cluster
	cluster__n: Option<Vec<String>>,
	/// Cluster (ID)
	cluster_id: Option<Vec<i64>>,
	/// Cluster (ID)
	cluster_id__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	enabled: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// L2VPN
	l2vpn: Option<Vec<i64>>,
	/// L2VPN
	l2vpn__n: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mac_address: Option<Vec<String>>,
	mac_address__ic: Option<Vec<String>>,
	mac_address__ie: Option<Vec<String>>,
	mac_address__iew: Option<Vec<String>>,
	mac_address__isw: Option<Vec<String>>,
	mac_address__n: Option<Vec<String>>,
	mac_address__nic: Option<Vec<String>>,
	mac_address__nie: Option<Vec<String>>,
	mac_address__niew: Option<Vec<String>>,
	mac_address__nisw: Option<Vec<String>>,
	modified_by_request: Option<String>,
	mtu: Option<Vec<i64>>,
	mtu__empty: Option<bool>,
	mtu__gt: Option<Vec<i64>>,
	mtu__gte: Option<Vec<i64>>,
	mtu__lt: Option<Vec<i64>>,
	mtu__lte: Option<Vec<i64>>,
	mtu__n: Option<Vec<i64>>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Parent interface (ID)
	parent_id: Option<Vec<i64>>,
	/// Parent interface (ID)
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual machine
	virtual_machine: Option<Vec<String>>,
	/// Virtual machine
	virtual_machine__n: Option<Vec<String>>,
	/// Virtual machine (ID)
	virtual_machine_id: Option<Vec<i64>>,
	/// Virtual machine (ID)
	virtual_machine_id__n: Option<Vec<i64>>,
	/// Assigned VID
	vlan: Option<String>,
	/// Assigned VLAN
	vlan_id: Option<String>,
	/// VRF (RD)
	vrf: Option<Vec<Option<String>>>,
	/// VRF (RD)
	vrf__n: Option<Vec<Option<String>>>,
	/// VRF
	vrf_id: Option<Vec<i64>>,
	/// VRF
	vrf_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesListResponse {
	Http200(PaginatedVMInterfaceList),
	#[default]
	None
}
/// Get a list of interface objects.
pub fn virtualization_interfaces_list(state: &ThanixClient, query: VirtualizationInterfacesListQuery) -> Result<VirtualizationInterfacesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/interfaces/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationInterfacesListResponse::Http200(r#response.json::<PaginatedVMInterfaceList>()?)) },
		_ => { Ok(VirtualizationInterfacesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesBulkUpdateResponse {
	Http200(Vec<VMInterface>),
	#[default]
	None
}
/// Put a list of interface objects.
pub fn virtualization_interfaces_bulk_update(state: &ThanixClient, body: Vec<VMInterfaceRequest>) -> Result<VirtualizationInterfacesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationInterfacesBulkUpdateResponse::Http200(r#response.json::<Vec<VMInterface>>()?)) },
		_ => { Ok(VirtualizationInterfacesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesCreateResponse {
	Http201(VMInterface),
	#[default]
	None
}
/// Post a list of interface objects.
pub fn virtualization_interfaces_create(state: &ThanixClient, body: WritableVMInterfaceRequest) -> Result<VirtualizationInterfacesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VirtualizationInterfacesCreateResponse::Http201(r#response.json::<VMInterface>()?)) },
		_ => { Ok(VirtualizationInterfacesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of interface objects.
pub fn virtualization_interfaces_bulk_destroy(state: &ThanixClient, body: Vec<VMInterfaceRequest>) -> Result<VirtualizationInterfacesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationInterfacesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesBulkPartialUpdateResponse {
	Http200(Vec<VMInterface>),
	#[default]
	None
}
/// Patch a list of interface objects.
pub fn virtualization_interfaces_bulk_partial_update(state: &ThanixClient, body: Vec<VMInterfaceRequest>) -> Result<VirtualizationInterfacesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/interfaces/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationInterfacesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VMInterface>>()?)) },
		_ => { Ok(VirtualizationInterfacesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesRetrieveResponse {
	Http200(VMInterface),
	#[default]
	None
}
/// Get a interface object.
pub fn virtualization_interfaces_retrieve(state: &ThanixClient, id: i64) -> Result<VirtualizationInterfacesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationInterfacesRetrieveResponse::Http200(r#response.json::<VMInterface>()?)) },
		_ => { Ok(VirtualizationInterfacesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesUpdateResponse {
	Http200(VMInterface),
	#[default]
	None
}
/// Put a interface object.
pub fn virtualization_interfaces_update(state: &ThanixClient, body: WritableVMInterfaceRequest, id: i64) -> Result<VirtualizationInterfacesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationInterfacesUpdateResponse::Http200(r#response.json::<VMInterface>()?)) },
		_ => { Ok(VirtualizationInterfacesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a interface object.
pub fn virtualization_interfaces_destroy(state: &ThanixClient, id: i64) -> Result<VirtualizationInterfacesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationInterfacesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationInterfacesPartialUpdateResponse {
	Http200(VMInterface),
	#[default]
	None
}
/// Patch a interface object.
pub fn virtualization_interfaces_partial_update(state: &ThanixClient, body: PatchedWritableVMInterfaceRequest, id: i64) -> Result<VirtualizationInterfacesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/interfaces/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationInterfacesPartialUpdateResponse::Http200(r#response.json::<VMInterface>()?)) },
		_ => { Ok(VirtualizationInterfacesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationVirtualDisksListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	size: Option<Vec<i64>>,
	size__empty: Option<bool>,
	size__gt: Option<Vec<i64>>,
	size__gte: Option<Vec<i64>>,
	size__lt: Option<Vec<i64>>,
	size__lte: Option<Vec<i64>>,
	size__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual machine
	virtual_machine: Option<Vec<String>>,
	/// Virtual machine
	virtual_machine__n: Option<Vec<String>>,
	/// Virtual machine (ID)
	virtual_machine_id: Option<Vec<i64>>,
	/// Virtual machine (ID)
	virtual_machine_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksListResponse {
	Http200(PaginatedVirtualDiskList),
	#[default]
	None
}
/// Get a list of virtual disk objects.
pub fn virtualization_virtual_disks_list(state: &ThanixClient, query: VirtualizationVirtualDisksListQuery) -> Result<VirtualizationVirtualDisksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/virtual-disks/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualDisksListResponse::Http200(r#response.json::<PaginatedVirtualDiskList>()?)) },
		_ => { Ok(VirtualizationVirtualDisksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksBulkUpdateResponse {
	Http200(Vec<VirtualDisk>),
	#[default]
	None
}
/// Put a list of virtual disk objects.
pub fn virtualization_virtual_disks_bulk_update(state: &ThanixClient, body: Vec<VirtualDiskRequest>) -> Result<VirtualizationVirtualDisksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/virtual-disks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualDisksBulkUpdateResponse::Http200(r#response.json::<Vec<VirtualDisk>>()?)) },
		_ => { Ok(VirtualizationVirtualDisksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksCreateResponse {
	Http201(VirtualDisk),
	#[default]
	None
}
/// Post a list of virtual disk objects.
pub fn virtualization_virtual_disks_create(state: &ThanixClient, body: WritableVirtualDiskRequest) -> Result<VirtualizationVirtualDisksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/virtual-disks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VirtualizationVirtualDisksCreateResponse::Http201(r#response.json::<VirtualDisk>()?)) },
		_ => { Ok(VirtualizationVirtualDisksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of virtual disk objects.
pub fn virtualization_virtual_disks_bulk_destroy(state: &ThanixClient, body: Vec<VirtualDiskRequest>) -> Result<VirtualizationVirtualDisksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/virtual-disks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationVirtualDisksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksBulkPartialUpdateResponse {
	Http200(Vec<VirtualDisk>),
	#[default]
	None
}
/// Patch a list of virtual disk objects.
pub fn virtualization_virtual_disks_bulk_partial_update(state: &ThanixClient, body: Vec<VirtualDiskRequest>) -> Result<VirtualizationVirtualDisksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/virtual-disks/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualDisksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VirtualDisk>>()?)) },
		_ => { Ok(VirtualizationVirtualDisksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksRetrieveResponse {
	Http200(VirtualDisk),
	#[default]
	None
}
/// Get a virtual disk object.
pub fn virtualization_virtual_disks_retrieve(state: &ThanixClient, id: i64) -> Result<VirtualizationVirtualDisksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/virtual-disks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualDisksRetrieveResponse::Http200(r#response.json::<VirtualDisk>()?)) },
		_ => { Ok(VirtualizationVirtualDisksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksUpdateResponse {
	Http200(VirtualDisk),
	#[default]
	None
}
/// Put a virtual disk object.
pub fn virtualization_virtual_disks_update(state: &ThanixClient, body: WritableVirtualDiskRequest, id: i64) -> Result<VirtualizationVirtualDisksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/virtual-disks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualDisksUpdateResponse::Http200(r#response.json::<VirtualDisk>()?)) },
		_ => { Ok(VirtualizationVirtualDisksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a virtual disk object.
pub fn virtualization_virtual_disks_destroy(state: &ThanixClient, id: i64) -> Result<VirtualizationVirtualDisksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/virtual-disks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationVirtualDisksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualDisksPartialUpdateResponse {
	Http200(VirtualDisk),
	#[default]
	None
}
/// Patch a virtual disk object.
pub fn virtualization_virtual_disks_partial_update(state: &ThanixClient, body: PatchedWritableVirtualDiskRequest, id: i64) -> Result<VirtualizationVirtualDisksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/virtual-disks/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualDisksPartialUpdateResponse::Http200(r#response.json::<VirtualDisk>()?)) },
		_ => { Ok(VirtualizationVirtualDisksPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationVirtualMachinesListQuery {
	/// Cluster
	cluster: Option<Vec<String>>,
	/// Cluster
	cluster__n: Option<Vec<String>>,
	/// Cluster group (slug)
	cluster_group: Option<Vec<String>>,
	/// Cluster group (slug)
	cluster_group__n: Option<Vec<String>>,
	/// Cluster group (ID)
	cluster_group_id: Option<Vec<i64>>,
	/// Cluster group (ID)
	cluster_group_id__n: Option<Vec<i64>>,
	/// Cluster (ID)
	cluster_id: Option<Vec<i64>>,
	/// Cluster (ID)
	cluster_id__n: Option<Vec<i64>>,
	/// Cluster type (slug)
	cluster_type: Option<Vec<String>>,
	/// Cluster type (slug)
	cluster_type__n: Option<Vec<String>>,
	/// Cluster type (ID)
	cluster_type_id: Option<Vec<i64>>,
	/// Cluster type (ID)
	cluster_type_id__n: Option<Vec<i64>>,
	/// Config template (ID)
	config_template_id: Option<Vec<i64>>,
	/// Config template (ID)
	config_template_id__n: Option<Vec<i64>>,
	/// Contact
	contact: Option<Vec<i64>>,
	/// Contact
	contact__n: Option<Vec<i64>>,
	/// Contact group
	contact_group: Option<Vec<i64>>,
	/// Contact group
	contact_group__n: Option<Vec<i64>>,
	/// Contact Role
	contact_role: Option<Vec<i64>>,
	/// Contact Role
	contact_role__n: Option<Vec<i64>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Device
	device: Option<Vec<Option<String>>>,
	/// Device
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	disk: Option<Vec<i64>>,
	disk__empty: Option<bool>,
	disk__gt: Option<Vec<i64>>,
	disk__gte: Option<Vec<i64>>,
	disk__lt: Option<Vec<i64>>,
	disk__lte: Option<Vec<i64>>,
	disk__n: Option<Vec<i64>>,
	/// Has a primary IP
	has_primary_ip: Option<bool>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	/// Has local config context data
	local_context_data: Option<bool>,
	mac_address: Option<Vec<String>>,
	mac_address__ic: Option<Vec<String>>,
	mac_address__ie: Option<Vec<String>>,
	mac_address__iew: Option<Vec<String>>,
	mac_address__isw: Option<Vec<String>>,
	mac_address__n: Option<Vec<String>>,
	mac_address__nic: Option<Vec<String>>,
	mac_address__nie: Option<Vec<String>>,
	mac_address__niew: Option<Vec<String>>,
	mac_address__nisw: Option<Vec<String>>,
	memory: Option<Vec<i64>>,
	memory__empty: Option<bool>,
	memory__gt: Option<Vec<i64>>,
	memory__gte: Option<Vec<i64>>,
	memory__lt: Option<Vec<i64>>,
	memory__lte: Option<Vec<i64>>,
	memory__n: Option<Vec<i64>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Platform (slug)
	platform: Option<Vec<String>>,
	/// Platform (slug)
	platform__n: Option<Vec<String>>,
	/// Platform (ID)
	platform_id: Option<Vec<i64>>,
	/// Platform (ID)
	platform_id__n: Option<Vec<i64>>,
	/// Primary IPv4 (ID)
	primary_ip4_id: Option<Vec<i64>>,
	/// Primary IPv4 (ID)
	primary_ip4_id__n: Option<Vec<i64>>,
	/// Primary IPv6 (ID)
	primary_ip6_id: Option<Vec<i64>>,
	/// Primary IPv6 (ID)
	primary_ip6_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	/// Region (slug)
	region: Option<Vec<i64>>,
	/// Region (slug)
	region__n: Option<Vec<i64>>,
	/// Region (ID)
	region_id: Option<Vec<i64>>,
	/// Region (ID)
	region_id__n: Option<Vec<i64>>,
	/// Role (slug)
	role: Option<Vec<String>>,
	/// Role (slug)
	role__n: Option<Vec<String>>,
	/// Role (ID)
	role_id: Option<Vec<i64>>,
	/// Role (ID)
	role_id__n: Option<Vec<i64>>,
	/// Site (slug)
	site: Option<Vec<String>>,
	/// Site (slug)
	site__n: Option<Vec<String>>,
	/// Site group (slug)
	site_group: Option<Vec<i64>>,
	/// Site group (slug)
	site_group__n: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id: Option<Vec<i64>>,
	/// Site group (ID)
	site_group_id__n: Option<Vec<i64>>,
	/// Site (ID)
	site_id: Option<Vec<i64>>,
	/// Site (ID)
	site_id__n: Option<Vec<i64>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	vcpus: Option<Vec<f64>>,
	vcpus__empty: Option<bool>,
	vcpus__gt: Option<Vec<f64>>,
	vcpus__gte: Option<Vec<f64>>,
	vcpus__lt: Option<Vec<f64>>,
	vcpus__lte: Option<Vec<f64>>,
	vcpus__n: Option<Vec<f64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesListResponse {
	Http200(PaginatedVirtualMachineWithConfigContextList),
	#[default]
	None
}
/// Get a list of virtual machine objects.
pub fn virtualization_virtual_machines_list(state: &ThanixClient, query: VirtualizationVirtualMachinesListQuery) -> Result<VirtualizationVirtualMachinesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/virtual-machines/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesListResponse::Http200(r#response.json::<PaginatedVirtualMachineWithConfigContextList>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesBulkUpdateResponse {
	Http200(Vec<VirtualMachineWithConfigContext>),
	#[default]
	None
}
/// Put a list of virtual machine objects.
pub fn virtualization_virtual_machines_bulk_update(state: &ThanixClient, body: Vec<VirtualMachineWithConfigContextRequest>) -> Result<VirtualizationVirtualMachinesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/virtual-machines/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesBulkUpdateResponse::Http200(r#response.json::<Vec<VirtualMachineWithConfigContext>>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesCreateResponse {
	Http201(VirtualMachineWithConfigContext),
	#[default]
	None
}
/// Post a list of virtual machine objects.
pub fn virtualization_virtual_machines_create(state: &ThanixClient, body: WritableVirtualMachineWithConfigContextRequest) -> Result<VirtualizationVirtualMachinesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/virtual-machines/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VirtualizationVirtualMachinesCreateResponse::Http201(r#response.json::<VirtualMachineWithConfigContext>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of virtual machine objects.
pub fn virtualization_virtual_machines_bulk_destroy(state: &ThanixClient, body: Vec<VirtualMachineWithConfigContextRequest>) -> Result<VirtualizationVirtualMachinesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/virtual-machines/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationVirtualMachinesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesBulkPartialUpdateResponse {
	Http200(Vec<VirtualMachineWithConfigContext>),
	#[default]
	None
}
/// Patch a list of virtual machine objects.
pub fn virtualization_virtual_machines_bulk_partial_update(state: &ThanixClient, body: Vec<VirtualMachineWithConfigContextRequest>) -> Result<VirtualizationVirtualMachinesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/virtual-machines/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<VirtualMachineWithConfigContext>>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesRetrieveResponse {
	Http200(VirtualMachineWithConfigContext),
	#[default]
	None
}
/// Get a virtual machine object.
pub fn virtualization_virtual_machines_retrieve(state: &ThanixClient, id: i64) -> Result<VirtualizationVirtualMachinesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/virtualization/virtual-machines/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesRetrieveResponse::Http200(r#response.json::<VirtualMachineWithConfigContext>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesUpdateResponse {
	Http200(VirtualMachineWithConfigContext),
	#[default]
	None
}
/// Put a virtual machine object.
pub fn virtualization_virtual_machines_update(state: &ThanixClient, body: WritableVirtualMachineWithConfigContextRequest, id: i64) -> Result<VirtualizationVirtualMachinesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/virtualization/virtual-machines/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesUpdateResponse::Http200(r#response.json::<VirtualMachineWithConfigContext>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a virtual machine object.
pub fn virtualization_virtual_machines_destroy(state: &ThanixClient, id: i64) -> Result<VirtualizationVirtualMachinesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/virtualization/virtual-machines/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VirtualizationVirtualMachinesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesPartialUpdateResponse {
	Http200(VirtualMachineWithConfigContext),
	#[default]
	None
}
/// Patch a virtual machine object.
pub fn virtualization_virtual_machines_partial_update(state: &ThanixClient, body: PatchedWritableVirtualMachineWithConfigContextRequest, id: i64) -> Result<VirtualizationVirtualMachinesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/virtualization/virtual-machines/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesPartialUpdateResponse::Http200(r#response.json::<VirtualMachineWithConfigContext>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VirtualizationVirtualMachinesRenderConfigCreateQuery {
	format: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VirtualizationVirtualMachinesRenderConfigCreateResponse {
	Http200(VirtualMachineWithConfigContext),
	#[default]
	None
}
/// Resolve and render the preferred ConfigTemplate for this Device.
pub fn virtualization_virtual_machines_render_config_create(state: &ThanixClient, query: VirtualizationVirtualMachinesRenderConfigCreateQuery, body: WritableVirtualMachineWithConfigContextRequest, id: i64) -> Result<VirtualizationVirtualMachinesRenderConfigCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/virtualization/virtual-machines/{id}/render-config/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VirtualizationVirtualMachinesRenderConfigCreateResponse::Http200(r#response.json::<VirtualMachineWithConfigContext>()?)) },
		_ => { Ok(VirtualizationVirtualMachinesRenderConfigCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnIkePoliciesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mode: Option<Vec<String>>,
	mode__n: Option<Vec<String>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	preshared_key: Option<String>,
	preshared_key__ic: Option<String>,
	preshared_key__ie: Option<String>,
	preshared_key__iew: Option<String>,
	preshared_key__isw: Option<String>,
	preshared_key__n: Option<String>,
	preshared_key__nic: Option<String>,
	preshared_key__nie: Option<String>,
	preshared_key__niew: Option<String>,
	preshared_key__nisw: Option<String>,
	proposal: Option<Vec<String>>,
	proposal__empty: Option<bool>,
	proposal__ic: Option<Vec<String>>,
	proposal__ie: Option<Vec<String>>,
	proposal__iew: Option<Vec<String>>,
	proposal__isw: Option<Vec<String>>,
	proposal__n: Option<Vec<String>>,
	proposal__nic: Option<Vec<String>>,
	proposal__nie: Option<Vec<String>>,
	proposal__niew: Option<Vec<String>>,
	proposal__nisw: Option<Vec<String>>,
	proposal_id: Option<Vec<i64>>,
	proposal_id__empty: Option<Vec<i64>>,
	proposal_id__gt: Option<Vec<i64>>,
	proposal_id__gte: Option<Vec<i64>>,
	proposal_id__lt: Option<Vec<i64>>,
	proposal_id__lte: Option<Vec<i64>>,
	proposal_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	version: Option<Vec<i64>>,
	version__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesListResponse {
	Http200(PaginatedIKEPolicyList),
	#[default]
	None
}
/// Get a list of IKE policy objects.
pub fn vpn_ike_policies_list(state: &ThanixClient, query: VpnIkePoliciesListQuery) -> Result<VpnIkePoliciesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ike-policies/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkePoliciesListResponse::Http200(r#response.json::<PaginatedIKEPolicyList>()?)) },
		_ => { Ok(VpnIkePoliciesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesBulkUpdateResponse {
	Http200(Vec<IKEPolicy>),
	#[default]
	None
}
/// Put a list of IKE policy objects.
pub fn vpn_ike_policies_bulk_update(state: &ThanixClient, body: Vec<IKEPolicyRequest>) -> Result<VpnIkePoliciesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ike-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkePoliciesBulkUpdateResponse::Http200(r#response.json::<Vec<IKEPolicy>>()?)) },
		_ => { Ok(VpnIkePoliciesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesCreateResponse {
	Http201(IKEPolicy),
	#[default]
	None
}
/// Post a list of IKE policy objects.
pub fn vpn_ike_policies_create(state: &ThanixClient, body: WritableIKEPolicyRequest) -> Result<VpnIkePoliciesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/ike-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnIkePoliciesCreateResponse::Http201(r#response.json::<IKEPolicy>()?)) },
		_ => { Ok(VpnIkePoliciesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IKE policy objects.
pub fn vpn_ike_policies_bulk_destroy(state: &ThanixClient, body: Vec<IKEPolicyRequest>) -> Result<VpnIkePoliciesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ike-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIkePoliciesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesBulkPartialUpdateResponse {
	Http200(Vec<IKEPolicy>),
	#[default]
	None
}
/// Patch a list of IKE policy objects.
pub fn vpn_ike_policies_bulk_partial_update(state: &ThanixClient, body: Vec<IKEPolicyRequest>) -> Result<VpnIkePoliciesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ike-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkePoliciesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IKEPolicy>>()?)) },
		_ => { Ok(VpnIkePoliciesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesRetrieveResponse {
	Http200(IKEPolicy),
	#[default]
	None
}
/// Get a IKE policy object.
pub fn vpn_ike_policies_retrieve(state: &ThanixClient, id: i64) -> Result<VpnIkePoliciesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ike-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkePoliciesRetrieveResponse::Http200(r#response.json::<IKEPolicy>()?)) },
		_ => { Ok(VpnIkePoliciesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesUpdateResponse {
	Http200(IKEPolicy),
	#[default]
	None
}
/// Put a IKE policy object.
pub fn vpn_ike_policies_update(state: &ThanixClient, body: WritableIKEPolicyRequest, id: i64) -> Result<VpnIkePoliciesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ike-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkePoliciesUpdateResponse::Http200(r#response.json::<IKEPolicy>()?)) },
		_ => { Ok(VpnIkePoliciesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IKE policy object.
pub fn vpn_ike_policies_destroy(state: &ThanixClient, id: i64) -> Result<VpnIkePoliciesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ike-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIkePoliciesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkePoliciesPartialUpdateResponse {
	Http200(IKEPolicy),
	#[default]
	None
}
/// Patch a IKE policy object.
pub fn vpn_ike_policies_partial_update(state: &ThanixClient, body: PatchedWritableIKEPolicyRequest, id: i64) -> Result<VpnIkePoliciesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ike-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkePoliciesPartialUpdateResponse::Http200(r#response.json::<IKEPolicy>()?)) },
		_ => { Ok(VpnIkePoliciesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnIkeProposalsListQuery {
	authentication_algorithm: Option<Vec<String>>,
	authentication_algorithm__n: Option<Vec<String>>,
	authentication_method: Option<Vec<String>>,
	authentication_method__n: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	encryption_algorithm: Option<Vec<String>>,
	encryption_algorithm__n: Option<Vec<String>>,
	/// Diffie-Hellman group ID
	group: Option<Vec<i64>>,
	/// Diffie-Hellman group ID
	group__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	sa_lifetime: Option<Vec<i64>>,
	sa_lifetime__empty: Option<bool>,
	sa_lifetime__gt: Option<Vec<i64>>,
	sa_lifetime__gte: Option<Vec<i64>>,
	sa_lifetime__lt: Option<Vec<i64>>,
	sa_lifetime__lte: Option<Vec<i64>>,
	sa_lifetime__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsListResponse {
	Http200(PaginatedIKEProposalList),
	#[default]
	None
}
/// Get a list of IKE proposal objects.
pub fn vpn_ike_proposals_list(state: &ThanixClient, query: VpnIkeProposalsListQuery) -> Result<VpnIkeProposalsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ike-proposals/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkeProposalsListResponse::Http200(r#response.json::<PaginatedIKEProposalList>()?)) },
		_ => { Ok(VpnIkeProposalsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsBulkUpdateResponse {
	Http200(Vec<IKEProposal>),
	#[default]
	None
}
/// Put a list of IKE proposal objects.
pub fn vpn_ike_proposals_bulk_update(state: &ThanixClient, body: Vec<IKEProposalRequest>) -> Result<VpnIkeProposalsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ike-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkeProposalsBulkUpdateResponse::Http200(r#response.json::<Vec<IKEProposal>>()?)) },
		_ => { Ok(VpnIkeProposalsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsCreateResponse {
	Http201(IKEProposal),
	#[default]
	None
}
/// Post a list of IKE proposal objects.
pub fn vpn_ike_proposals_create(state: &ThanixClient, body: WritableIKEProposalRequest) -> Result<VpnIkeProposalsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/ike-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnIkeProposalsCreateResponse::Http201(r#response.json::<IKEProposal>()?)) },
		_ => { Ok(VpnIkeProposalsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IKE proposal objects.
pub fn vpn_ike_proposals_bulk_destroy(state: &ThanixClient, body: Vec<IKEProposalRequest>) -> Result<VpnIkeProposalsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ike-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIkeProposalsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsBulkPartialUpdateResponse {
	Http200(Vec<IKEProposal>),
	#[default]
	None
}
/// Patch a list of IKE proposal objects.
pub fn vpn_ike_proposals_bulk_partial_update(state: &ThanixClient, body: Vec<IKEProposalRequest>) -> Result<VpnIkeProposalsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ike-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkeProposalsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IKEProposal>>()?)) },
		_ => { Ok(VpnIkeProposalsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsRetrieveResponse {
	Http200(IKEProposal),
	#[default]
	None
}
/// Get a IKE proposal object.
pub fn vpn_ike_proposals_retrieve(state: &ThanixClient, id: i64) -> Result<VpnIkeProposalsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ike-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkeProposalsRetrieveResponse::Http200(r#response.json::<IKEProposal>()?)) },
		_ => { Ok(VpnIkeProposalsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsUpdateResponse {
	Http200(IKEProposal),
	#[default]
	None
}
/// Put a IKE proposal object.
pub fn vpn_ike_proposals_update(state: &ThanixClient, body: WritableIKEProposalRequest, id: i64) -> Result<VpnIkeProposalsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ike-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkeProposalsUpdateResponse::Http200(r#response.json::<IKEProposal>()?)) },
		_ => { Ok(VpnIkeProposalsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IKE proposal object.
pub fn vpn_ike_proposals_destroy(state: &ThanixClient, id: i64) -> Result<VpnIkeProposalsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ike-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIkeProposalsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIkeProposalsPartialUpdateResponse {
	Http200(IKEProposal),
	#[default]
	None
}
/// Patch a IKE proposal object.
pub fn vpn_ike_proposals_partial_update(state: &ThanixClient, body: PatchedWritableIKEProposalRequest, id: i64) -> Result<VpnIkeProposalsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ike-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIkeProposalsPartialUpdateResponse::Http200(r#response.json::<IKEProposal>()?)) },
		_ => { Ok(VpnIkeProposalsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnIpsecPoliciesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Diffie-Hellman group for Perfect Forward Secrecy
	pfs_group: Option<Vec<i64>>,
	/// Diffie-Hellman group for Perfect Forward Secrecy
	pfs_group__n: Option<Vec<i64>>,
	proposal: Option<Vec<String>>,
	proposal__empty: Option<bool>,
	proposal__ic: Option<Vec<String>>,
	proposal__ie: Option<Vec<String>>,
	proposal__iew: Option<Vec<String>>,
	proposal__isw: Option<Vec<String>>,
	proposal__n: Option<Vec<String>>,
	proposal__nic: Option<Vec<String>>,
	proposal__nie: Option<Vec<String>>,
	proposal__niew: Option<Vec<String>>,
	proposal__nisw: Option<Vec<String>>,
	proposal_id: Option<Vec<i64>>,
	proposal_id__empty: Option<Vec<i64>>,
	proposal_id__gt: Option<Vec<i64>>,
	proposal_id__gte: Option<Vec<i64>>,
	proposal_id__lt: Option<Vec<i64>>,
	proposal_id__lte: Option<Vec<i64>>,
	proposal_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesListResponse {
	Http200(PaginatedIPSecPolicyList),
	#[default]
	None
}
/// Get a list of IPSec policy objects.
pub fn vpn_ipsec_policies_list(state: &ThanixClient, query: VpnIpsecPoliciesListQuery) -> Result<VpnIpsecPoliciesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ipsec-policies/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecPoliciesListResponse::Http200(r#response.json::<PaginatedIPSecPolicyList>()?)) },
		_ => { Ok(VpnIpsecPoliciesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesBulkUpdateResponse {
	Http200(Vec<IPSecPolicy>),
	#[default]
	None
}
/// Put a list of IPSec policy objects.
pub fn vpn_ipsec_policies_bulk_update(state: &ThanixClient, body: Vec<IPSecPolicyRequest>) -> Result<VpnIpsecPoliciesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ipsec-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecPoliciesBulkUpdateResponse::Http200(r#response.json::<Vec<IPSecPolicy>>()?)) },
		_ => { Ok(VpnIpsecPoliciesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesCreateResponse {
	Http201(IPSecPolicy),
	#[default]
	None
}
/// Post a list of IPSec policy objects.
pub fn vpn_ipsec_policies_create(state: &ThanixClient, body: WritableIPSecPolicyRequest) -> Result<VpnIpsecPoliciesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/ipsec-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnIpsecPoliciesCreateResponse::Http201(r#response.json::<IPSecPolicy>()?)) },
		_ => { Ok(VpnIpsecPoliciesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IPSec policy objects.
pub fn vpn_ipsec_policies_bulk_destroy(state: &ThanixClient, body: Vec<IPSecPolicyRequest>) -> Result<VpnIpsecPoliciesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ipsec-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIpsecPoliciesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesBulkPartialUpdateResponse {
	Http200(Vec<IPSecPolicy>),
	#[default]
	None
}
/// Patch a list of IPSec policy objects.
pub fn vpn_ipsec_policies_bulk_partial_update(state: &ThanixClient, body: Vec<IPSecPolicyRequest>) -> Result<VpnIpsecPoliciesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ipsec-policies/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecPoliciesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IPSecPolicy>>()?)) },
		_ => { Ok(VpnIpsecPoliciesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesRetrieveResponse {
	Http200(IPSecPolicy),
	#[default]
	None
}
/// Get a IPSec policy object.
pub fn vpn_ipsec_policies_retrieve(state: &ThanixClient, id: i64) -> Result<VpnIpsecPoliciesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ipsec-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecPoliciesRetrieveResponse::Http200(r#response.json::<IPSecPolicy>()?)) },
		_ => { Ok(VpnIpsecPoliciesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesUpdateResponse {
	Http200(IPSecPolicy),
	#[default]
	None
}
/// Put a IPSec policy object.
pub fn vpn_ipsec_policies_update(state: &ThanixClient, body: WritableIPSecPolicyRequest, id: i64) -> Result<VpnIpsecPoliciesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ipsec-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecPoliciesUpdateResponse::Http200(r#response.json::<IPSecPolicy>()?)) },
		_ => { Ok(VpnIpsecPoliciesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IPSec policy object.
pub fn vpn_ipsec_policies_destroy(state: &ThanixClient, id: i64) -> Result<VpnIpsecPoliciesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ipsec-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIpsecPoliciesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecPoliciesPartialUpdateResponse {
	Http200(IPSecPolicy),
	#[default]
	None
}
/// Patch a IPSec policy object.
pub fn vpn_ipsec_policies_partial_update(state: &ThanixClient, body: PatchedWritableIPSecPolicyRequest, id: i64) -> Result<VpnIpsecPoliciesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ipsec-policies/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecPoliciesPartialUpdateResponse::Http200(r#response.json::<IPSecPolicy>()?)) },
		_ => { Ok(VpnIpsecPoliciesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnIpsecProfilesListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// IKE policy (name)
	ike_policy: Option<Vec<String>>,
	/// IKE policy (name)
	ike_policy__n: Option<Vec<String>>,
	/// IKE policy (ID)
	ike_policy_id: Option<Vec<i64>>,
	/// IKE policy (ID)
	ike_policy_id__n: Option<Vec<i64>>,
	/// IPSec policy (name)
	ipsec_policy: Option<Vec<String>>,
	/// IPSec policy (name)
	ipsec_policy__n: Option<Vec<String>>,
	/// IPSec policy (ID)
	ipsec_policy_id: Option<Vec<i64>>,
	/// IPSec policy (ID)
	ipsec_policy_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	mode: Option<Vec<String>>,
	mode__n: Option<Vec<String>>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesListResponse {
	Http200(PaginatedIPSecProfileList),
	#[default]
	None
}
/// Get a list of IPSec profile objects.
pub fn vpn_ipsec_profiles_list(state: &ThanixClient, query: VpnIpsecProfilesListQuery) -> Result<VpnIpsecProfilesListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ipsec-profiles/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProfilesListResponse::Http200(r#response.json::<PaginatedIPSecProfileList>()?)) },
		_ => { Ok(VpnIpsecProfilesListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesBulkUpdateResponse {
	Http200(Vec<IPSecProfile>),
	#[default]
	None
}
/// Put a list of IPSec profile objects.
pub fn vpn_ipsec_profiles_bulk_update(state: &ThanixClient, body: Vec<IPSecProfileRequest>) -> Result<VpnIpsecProfilesBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ipsec-profiles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProfilesBulkUpdateResponse::Http200(r#response.json::<Vec<IPSecProfile>>()?)) },
		_ => { Ok(VpnIpsecProfilesBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesCreateResponse {
	Http201(IPSecProfile),
	#[default]
	None
}
/// Post a list of IPSec profile objects.
pub fn vpn_ipsec_profiles_create(state: &ThanixClient, body: WritableIPSecProfileRequest) -> Result<VpnIpsecProfilesCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/ipsec-profiles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnIpsecProfilesCreateResponse::Http201(r#response.json::<IPSecProfile>()?)) },
		_ => { Ok(VpnIpsecProfilesCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IPSec profile objects.
pub fn vpn_ipsec_profiles_bulk_destroy(state: &ThanixClient, body: Vec<IPSecProfileRequest>) -> Result<VpnIpsecProfilesBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ipsec-profiles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIpsecProfilesBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesBulkPartialUpdateResponse {
	Http200(Vec<IPSecProfile>),
	#[default]
	None
}
/// Patch a list of IPSec profile objects.
pub fn vpn_ipsec_profiles_bulk_partial_update(state: &ThanixClient, body: Vec<IPSecProfileRequest>) -> Result<VpnIpsecProfilesBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ipsec-profiles/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProfilesBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IPSecProfile>>()?)) },
		_ => { Ok(VpnIpsecProfilesBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesRetrieveResponse {
	Http200(IPSecProfile),
	#[default]
	None
}
/// Get a IPSec profile object.
pub fn vpn_ipsec_profiles_retrieve(state: &ThanixClient, id: i64) -> Result<VpnIpsecProfilesRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ipsec-profiles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProfilesRetrieveResponse::Http200(r#response.json::<IPSecProfile>()?)) },
		_ => { Ok(VpnIpsecProfilesRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesUpdateResponse {
	Http200(IPSecProfile),
	#[default]
	None
}
/// Put a IPSec profile object.
pub fn vpn_ipsec_profiles_update(state: &ThanixClient, body: WritableIPSecProfileRequest, id: i64) -> Result<VpnIpsecProfilesUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ipsec-profiles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProfilesUpdateResponse::Http200(r#response.json::<IPSecProfile>()?)) },
		_ => { Ok(VpnIpsecProfilesUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IPSec profile object.
pub fn vpn_ipsec_profiles_destroy(state: &ThanixClient, id: i64) -> Result<VpnIpsecProfilesDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ipsec-profiles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIpsecProfilesDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProfilesPartialUpdateResponse {
	Http200(IPSecProfile),
	#[default]
	None
}
/// Patch a IPSec profile object.
pub fn vpn_ipsec_profiles_partial_update(state: &ThanixClient, body: PatchedWritableIPSecProfileRequest, id: i64) -> Result<VpnIpsecProfilesPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ipsec-profiles/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProfilesPartialUpdateResponse::Http200(r#response.json::<IPSecProfile>()?)) },
		_ => { Ok(VpnIpsecProfilesPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnIpsecProposalsListQuery {
	authentication_algorithm: Option<Vec<String>>,
	authentication_algorithm__n: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	encryption_algorithm: Option<Vec<String>>,
	encryption_algorithm__n: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	sa_lifetime_data: Option<Vec<i64>>,
	sa_lifetime_data__empty: Option<bool>,
	sa_lifetime_data__gt: Option<Vec<i64>>,
	sa_lifetime_data__gte: Option<Vec<i64>>,
	sa_lifetime_data__lt: Option<Vec<i64>>,
	sa_lifetime_data__lte: Option<Vec<i64>>,
	sa_lifetime_data__n: Option<Vec<i64>>,
	sa_lifetime_seconds: Option<Vec<i64>>,
	sa_lifetime_seconds__empty: Option<bool>,
	sa_lifetime_seconds__gt: Option<Vec<i64>>,
	sa_lifetime_seconds__gte: Option<Vec<i64>>,
	sa_lifetime_seconds__lt: Option<Vec<i64>>,
	sa_lifetime_seconds__lte: Option<Vec<i64>>,
	sa_lifetime_seconds__n: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsListResponse {
	Http200(PaginatedIPSecProposalList),
	#[default]
	None
}
/// Get a list of IPSec proposal objects.
pub fn vpn_ipsec_proposals_list(state: &ThanixClient, query: VpnIpsecProposalsListQuery) -> Result<VpnIpsecProposalsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ipsec-proposals/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProposalsListResponse::Http200(r#response.json::<PaginatedIPSecProposalList>()?)) },
		_ => { Ok(VpnIpsecProposalsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsBulkUpdateResponse {
	Http200(Vec<IPSecProposal>),
	#[default]
	None
}
/// Put a list of IPSec proposal objects.
pub fn vpn_ipsec_proposals_bulk_update(state: &ThanixClient, body: Vec<IPSecProposalRequest>) -> Result<VpnIpsecProposalsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ipsec-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProposalsBulkUpdateResponse::Http200(r#response.json::<Vec<IPSecProposal>>()?)) },
		_ => { Ok(VpnIpsecProposalsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsCreateResponse {
	Http201(IPSecProposal),
	#[default]
	None
}
/// Post a list of IPSec proposal objects.
pub fn vpn_ipsec_proposals_create(state: &ThanixClient, body: WritableIPSecProposalRequest) -> Result<VpnIpsecProposalsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/ipsec-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnIpsecProposalsCreateResponse::Http201(r#response.json::<IPSecProposal>()?)) },
		_ => { Ok(VpnIpsecProposalsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of IPSec proposal objects.
pub fn vpn_ipsec_proposals_bulk_destroy(state: &ThanixClient, body: Vec<IPSecProposalRequest>) -> Result<VpnIpsecProposalsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ipsec-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIpsecProposalsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsBulkPartialUpdateResponse {
	Http200(Vec<IPSecProposal>),
	#[default]
	None
}
/// Patch a list of IPSec proposal objects.
pub fn vpn_ipsec_proposals_bulk_partial_update(state: &ThanixClient, body: Vec<IPSecProposalRequest>) -> Result<VpnIpsecProposalsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ipsec-proposals/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProposalsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<IPSecProposal>>()?)) },
		_ => { Ok(VpnIpsecProposalsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsRetrieveResponse {
	Http200(IPSecProposal),
	#[default]
	None
}
/// Get a IPSec proposal object.
pub fn vpn_ipsec_proposals_retrieve(state: &ThanixClient, id: i64) -> Result<VpnIpsecProposalsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/ipsec-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProposalsRetrieveResponse::Http200(r#response.json::<IPSecProposal>()?)) },
		_ => { Ok(VpnIpsecProposalsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsUpdateResponse {
	Http200(IPSecProposal),
	#[default]
	None
}
/// Put a IPSec proposal object.
pub fn vpn_ipsec_proposals_update(state: &ThanixClient, body: WritableIPSecProposalRequest, id: i64) -> Result<VpnIpsecProposalsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/ipsec-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProposalsUpdateResponse::Http200(r#response.json::<IPSecProposal>()?)) },
		_ => { Ok(VpnIpsecProposalsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a IPSec proposal object.
pub fn vpn_ipsec_proposals_destroy(state: &ThanixClient, id: i64) -> Result<VpnIpsecProposalsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/ipsec-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnIpsecProposalsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnIpsecProposalsPartialUpdateResponse {
	Http200(IPSecProposal),
	#[default]
	None
}
/// Patch a IPSec proposal object.
pub fn vpn_ipsec_proposals_partial_update(state: &ThanixClient, body: PatchedWritableIPSecProposalRequest, id: i64) -> Result<VpnIpsecProposalsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/ipsec-proposals/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnIpsecProposalsPartialUpdateResponse::Http200(r#response.json::<IPSecProposal>()?)) },
		_ => { Ok(VpnIpsecProposalsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnL2VpnTerminationsListQuery {
	assigned_object_type: Option<String>,
	assigned_object_type__n: Option<String>,
	assigned_object_type_id: Option<i64>,
	assigned_object_type_id__n: Option<i64>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	/// Device (name)
	device: Option<Vec<Option<String>>>,
	/// Device (name)
	device__n: Option<Vec<Option<String>>>,
	/// Device (ID)
	device_id: Option<Vec<i64>>,
	/// Device (ID)
	device_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Interface (name)
	interface: Option<Vec<String>>,
	/// Interface (name)
	interface__n: Option<Vec<String>>,
	/// Interface (ID)
	interface_id: Option<Vec<i64>>,
	/// Interface (ID)
	interface_id__n: Option<Vec<i64>>,
	/// L2VPN (slug)
	l2vpn: Option<Vec<String>>,
	/// L2VPN (slug)
	l2vpn__n: Option<Vec<String>>,
	/// L2VPN (ID)
	l2vpn_id: Option<Vec<i64>>,
	/// L2VPN (ID)
	l2vpn_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	region: Option<Vec<String>>,
	region_id: Option<Vec<i64>>,
	site: Option<Vec<String>>,
	site_id: Option<Vec<i64>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,
	/// Virtual machine (name)
	virtual_machine: Option<Vec<String>>,
	/// Virtual machine (name)
	virtual_machine__n: Option<Vec<String>>,
	/// Virtual machine (ID)
	virtual_machine_id: Option<Vec<i64>>,
	/// Virtual machine (ID)
	virtual_machine_id__n: Option<Vec<i64>>,
	/// VLAN (name)
	vlan: Option<Vec<String>>,
	/// VLAN (name)
	vlan__n: Option<Vec<String>>,
	/// VLAN (ID)
	vlan_id: Option<Vec<i64>>,
	/// VLAN (ID)
	vlan_id__n: Option<Vec<i64>>,
	/// VLAN number (1-4094)
	vlan_vid: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__empty: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__gt: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__gte: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__lt: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__lte: Option<i64>,
	/// VLAN number (1-4094)
	vlan_vid__n: Option<i64>,
	/// VM interface (name)
	vminterface: Option<Vec<String>>,
	/// VM interface (name)
	vminterface__n: Option<Vec<String>>,
	/// VM Interface (ID)
	vminterface_id: Option<Vec<i64>>,
	/// VM Interface (ID)
	vminterface_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsListResponse {
	Http200(PaginatedL2VPNTerminationList),
	#[default]
	None
}
/// Get a list of L2VPN termination objects.
pub fn vpn_l2vpn_terminations_list(state: &ThanixClient, query: VpnL2VpnTerminationsListQuery) -> Result<VpnL2VpnTerminationsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/l2vpn-terminations/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnTerminationsListResponse::Http200(r#response.json::<PaginatedL2VPNTerminationList>()?)) },
		_ => { Ok(VpnL2VpnTerminationsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsBulkUpdateResponse {
	Http200(Vec<L2VPNTermination>),
	#[default]
	None
}
/// Put a list of L2VPN termination objects.
pub fn vpn_l2vpn_terminations_bulk_update(state: &ThanixClient, body: Vec<L2VPNTerminationRequest>) -> Result<VpnL2VpnTerminationsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/l2vpn-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnTerminationsBulkUpdateResponse::Http200(r#response.json::<Vec<L2VPNTermination>>()?)) },
		_ => { Ok(VpnL2VpnTerminationsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsCreateResponse {
	Http201(L2VPNTermination),
	#[default]
	None
}
/// Post a list of L2VPN termination objects.
pub fn vpn_l2vpn_terminations_create(state: &ThanixClient, body: WritableL2VPNTerminationRequest) -> Result<VpnL2VpnTerminationsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/l2vpn-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnL2VpnTerminationsCreateResponse::Http201(r#response.json::<L2VPNTermination>()?)) },
		_ => { Ok(VpnL2VpnTerminationsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of L2VPN termination objects.
pub fn vpn_l2vpn_terminations_bulk_destroy(state: &ThanixClient, body: Vec<L2VPNTerminationRequest>) -> Result<VpnL2VpnTerminationsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/l2vpn-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnL2VpnTerminationsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsBulkPartialUpdateResponse {
	Http200(Vec<L2VPNTermination>),
	#[default]
	None
}
/// Patch a list of L2VPN termination objects.
pub fn vpn_l2vpn_terminations_bulk_partial_update(state: &ThanixClient, body: Vec<L2VPNTerminationRequest>) -> Result<VpnL2VpnTerminationsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/l2vpn-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnTerminationsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<L2VPNTermination>>()?)) },
		_ => { Ok(VpnL2VpnTerminationsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsRetrieveResponse {
	Http200(L2VPNTermination),
	#[default]
	None
}
/// Get a L2VPN termination object.
pub fn vpn_l2vpn_terminations_retrieve(state: &ThanixClient, id: i64) -> Result<VpnL2VpnTerminationsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/l2vpn-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnTerminationsRetrieveResponse::Http200(r#response.json::<L2VPNTermination>()?)) },
		_ => { Ok(VpnL2VpnTerminationsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsUpdateResponse {
	Http200(L2VPNTermination),
	#[default]
	None
}
/// Put a L2VPN termination object.
pub fn vpn_l2vpn_terminations_update(state: &ThanixClient, body: WritableL2VPNTerminationRequest, id: i64) -> Result<VpnL2VpnTerminationsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/l2vpn-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnTerminationsUpdateResponse::Http200(r#response.json::<L2VPNTermination>()?)) },
		_ => { Ok(VpnL2VpnTerminationsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a L2VPN termination object.
pub fn vpn_l2vpn_terminations_destroy(state: &ThanixClient, id: i64) -> Result<VpnL2VpnTerminationsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/l2vpn-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnL2VpnTerminationsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnTerminationsPartialUpdateResponse {
	Http200(L2VPNTermination),
	#[default]
	None
}
/// Patch a L2VPN termination object.
pub fn vpn_l2vpn_terminations_partial_update(state: &ThanixClient, body: PatchedWritableL2VPNTerminationRequest, id: i64) -> Result<VpnL2VpnTerminationsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/l2vpn-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnTerminationsPartialUpdateResponse::Http200(r#response.json::<L2VPNTermination>()?)) },
		_ => { Ok(VpnL2VpnTerminationsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnL2VpnsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	/// Export target (name)
	export_target: Option<Vec<String>>,
	/// Export target (name)
	export_target__n: Option<Vec<String>>,
	/// Export target
	export_target_id: Option<Vec<i64>>,
	/// Export target
	export_target_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	identifier: Option<Vec<i64>>,
	identifier__empty: Option<bool>,
	identifier__gt: Option<Vec<i64>>,
	identifier__gte: Option<Vec<i64>>,
	identifier__lt: Option<Vec<i64>>,
	identifier__lte: Option<Vec<i64>>,
	identifier__n: Option<Vec<i64>>,
	/// Import target (name)
	import_target: Option<Vec<String>>,
	/// Import target (name)
	import_target__n: Option<Vec<String>>,
	/// Import target
	import_target_id: Option<Vec<i64>>,
	/// Import target
	import_target_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	r#type: Option<Vec<String>>,
	type__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsListResponse {
	Http200(PaginatedL2VPNList),
	#[default]
	None
}
/// Get a list of L2VPN objects.
pub fn vpn_l2vpns_list(state: &ThanixClient, query: VpnL2VpnsListQuery) -> Result<VpnL2VpnsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/l2vpns/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnsListResponse::Http200(r#response.json::<PaginatedL2VPNList>()?)) },
		_ => { Ok(VpnL2VpnsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsBulkUpdateResponse {
	Http200(Vec<L2VPN>),
	#[default]
	None
}
/// Put a list of L2VPN objects.
pub fn vpn_l2vpns_bulk_update(state: &ThanixClient, body: Vec<L2VPNRequest>) -> Result<VpnL2VpnsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/l2vpns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnsBulkUpdateResponse::Http200(r#response.json::<Vec<L2VPN>>()?)) },
		_ => { Ok(VpnL2VpnsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsCreateResponse {
	Http201(L2VPN),
	#[default]
	None
}
/// Post a list of L2VPN objects.
pub fn vpn_l2vpns_create(state: &ThanixClient, body: WritableL2VPNRequest) -> Result<VpnL2VpnsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/l2vpns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnL2VpnsCreateResponse::Http201(r#response.json::<L2VPN>()?)) },
		_ => { Ok(VpnL2VpnsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of L2VPN objects.
pub fn vpn_l2vpns_bulk_destroy(state: &ThanixClient, body: Vec<L2VPNRequest>) -> Result<VpnL2VpnsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/l2vpns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnL2VpnsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsBulkPartialUpdateResponse {
	Http200(Vec<L2VPN>),
	#[default]
	None
}
/// Patch a list of L2VPN objects.
pub fn vpn_l2vpns_bulk_partial_update(state: &ThanixClient, body: Vec<L2VPNRequest>) -> Result<VpnL2VpnsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/l2vpns/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<L2VPN>>()?)) },
		_ => { Ok(VpnL2VpnsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsRetrieveResponse {
	Http200(L2VPN),
	#[default]
	None
}
/// Get a L2VPN object.
pub fn vpn_l2vpns_retrieve(state: &ThanixClient, id: i64) -> Result<VpnL2VpnsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/l2vpns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnsRetrieveResponse::Http200(r#response.json::<L2VPN>()?)) },
		_ => { Ok(VpnL2VpnsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsUpdateResponse {
	Http200(L2VPN),
	#[default]
	None
}
/// Put a L2VPN object.
pub fn vpn_l2vpns_update(state: &ThanixClient, body: WritableL2VPNRequest, id: i64) -> Result<VpnL2VpnsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/l2vpns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnsUpdateResponse::Http200(r#response.json::<L2VPN>()?)) },
		_ => { Ok(VpnL2VpnsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a L2VPN object.
pub fn vpn_l2vpns_destroy(state: &ThanixClient, id: i64) -> Result<VpnL2VpnsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/l2vpns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnL2VpnsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnL2VpnsPartialUpdateResponse {
	Http200(L2VPN),
	#[default]
	None
}
/// Patch a L2VPN object.
pub fn vpn_l2vpns_partial_update(state: &ThanixClient, body: PatchedWritableL2VPNRequest, id: i64) -> Result<VpnL2VpnsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/l2vpns/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnL2VpnsPartialUpdateResponse::Http200(r#response.json::<L2VPN>()?)) },
		_ => { Ok(VpnL2VpnsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnTunnelGroupsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsListResponse {
	Http200(PaginatedTunnelGroupList),
	#[default]
	None
}
/// Get a list of tunnel group objects.
pub fn vpn_tunnel_groups_list(state: &ThanixClient, query: VpnTunnelGroupsListQuery) -> Result<VpnTunnelGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/tunnel-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelGroupsListResponse::Http200(r#response.json::<PaginatedTunnelGroupList>()?)) },
		_ => { Ok(VpnTunnelGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsBulkUpdateResponse {
	Http200(Vec<TunnelGroup>),
	#[default]
	None
}
/// Put a list of tunnel group objects.
pub fn vpn_tunnel_groups_bulk_update(state: &ThanixClient, body: Vec<TunnelGroupRequest>) -> Result<VpnTunnelGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/tunnel-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<TunnelGroup>>()?)) },
		_ => { Ok(VpnTunnelGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsCreateResponse {
	Http201(TunnelGroup),
	#[default]
	None
}
/// Post a list of tunnel group objects.
pub fn vpn_tunnel_groups_create(state: &ThanixClient, body: TunnelGroupRequest) -> Result<VpnTunnelGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/tunnel-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnTunnelGroupsCreateResponse::Http201(r#response.json::<TunnelGroup>()?)) },
		_ => { Ok(VpnTunnelGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of tunnel group objects.
pub fn vpn_tunnel_groups_bulk_destroy(state: &ThanixClient, body: Vec<TunnelGroupRequest>) -> Result<VpnTunnelGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/tunnel-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnTunnelGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsBulkPartialUpdateResponse {
	Http200(Vec<TunnelGroup>),
	#[default]
	None
}
/// Patch a list of tunnel group objects.
pub fn vpn_tunnel_groups_bulk_partial_update(state: &ThanixClient, body: Vec<TunnelGroupRequest>) -> Result<VpnTunnelGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/tunnel-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<TunnelGroup>>()?)) },
		_ => { Ok(VpnTunnelGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsRetrieveResponse {
	Http200(TunnelGroup),
	#[default]
	None
}
/// Get a tunnel group object.
pub fn vpn_tunnel_groups_retrieve(state: &ThanixClient, id: i64) -> Result<VpnTunnelGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/tunnel-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelGroupsRetrieveResponse::Http200(r#response.json::<TunnelGroup>()?)) },
		_ => { Ok(VpnTunnelGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsUpdateResponse {
	Http200(TunnelGroup),
	#[default]
	None
}
/// Put a tunnel group object.
pub fn vpn_tunnel_groups_update(state: &ThanixClient, body: TunnelGroupRequest, id: i64) -> Result<VpnTunnelGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/tunnel-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelGroupsUpdateResponse::Http200(r#response.json::<TunnelGroup>()?)) },
		_ => { Ok(VpnTunnelGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a tunnel group object.
pub fn vpn_tunnel_groups_destroy(state: &ThanixClient, id: i64) -> Result<VpnTunnelGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/tunnel-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnTunnelGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelGroupsPartialUpdateResponse {
	Http200(TunnelGroup),
	#[default]
	None
}
/// Patch a tunnel group object.
pub fn vpn_tunnel_groups_partial_update(state: &ThanixClient, body: PatchedTunnelGroupRequest, id: i64) -> Result<VpnTunnelGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/tunnel-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelGroupsPartialUpdateResponse::Http200(r#response.json::<TunnelGroup>()?)) },
		_ => { Ok(VpnTunnelGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnTunnelTerminationsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// Interface (name)
	interface: Option<Vec<String>>,
	/// Interface (name)
	interface__n: Option<Vec<String>>,
	/// Interface (ID)
	interface_id: Option<Vec<i64>>,
	/// Interface (ID)
	interface_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Outside IP (ID)
	outside_ip_id: Option<Vec<i64>>,
	/// Outside IP (ID)
	outside_ip_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	role: Option<Vec<String>>,
	role__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	termination_type: Option<String>,
	termination_type__n: Option<String>,
	/// Tunnel (name)
	tunnel: Option<Vec<String>>,
	/// Tunnel (name)
	tunnel__n: Option<Vec<String>>,
	/// Tunnel (ID)
	tunnel_id: Option<Vec<i64>>,
	/// Tunnel (ID)
	tunnel_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	/// VM interface (name)
	vminterface: Option<Vec<String>>,
	/// VM interface (name)
	vminterface__n: Option<Vec<String>>,
	/// VM interface (ID)
	vminterface_id: Option<Vec<i64>>,
	/// VM interface (ID)
	vminterface_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsListResponse {
	Http200(PaginatedTunnelTerminationList),
	#[default]
	None
}
/// Get a list of tunnel termination objects.
pub fn vpn_tunnel_terminations_list(state: &ThanixClient, query: VpnTunnelTerminationsListQuery) -> Result<VpnTunnelTerminationsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/tunnel-terminations/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelTerminationsListResponse::Http200(r#response.json::<PaginatedTunnelTerminationList>()?)) },
		_ => { Ok(VpnTunnelTerminationsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsBulkUpdateResponse {
	Http200(Vec<TunnelTermination>),
	#[default]
	None
}
/// Put a list of tunnel termination objects.
pub fn vpn_tunnel_terminations_bulk_update(state: &ThanixClient, body: Vec<TunnelTerminationRequest>) -> Result<VpnTunnelTerminationsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/tunnel-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelTerminationsBulkUpdateResponse::Http200(r#response.json::<Vec<TunnelTermination>>()?)) },
		_ => { Ok(VpnTunnelTerminationsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsCreateResponse {
	Http201(TunnelTermination),
	#[default]
	None
}
/// Post a list of tunnel termination objects.
pub fn vpn_tunnel_terminations_create(state: &ThanixClient, body: WritableTunnelTerminationRequest) -> Result<VpnTunnelTerminationsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/tunnel-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnTunnelTerminationsCreateResponse::Http201(r#response.json::<TunnelTermination>()?)) },
		_ => { Ok(VpnTunnelTerminationsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of tunnel termination objects.
pub fn vpn_tunnel_terminations_bulk_destroy(state: &ThanixClient, body: Vec<TunnelTerminationRequest>) -> Result<VpnTunnelTerminationsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/tunnel-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnTunnelTerminationsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsBulkPartialUpdateResponse {
	Http200(Vec<TunnelTermination>),
	#[default]
	None
}
/// Patch a list of tunnel termination objects.
pub fn vpn_tunnel_terminations_bulk_partial_update(state: &ThanixClient, body: Vec<TunnelTerminationRequest>) -> Result<VpnTunnelTerminationsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/tunnel-terminations/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelTerminationsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<TunnelTermination>>()?)) },
		_ => { Ok(VpnTunnelTerminationsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsRetrieveResponse {
	Http200(TunnelTermination),
	#[default]
	None
}
/// Get a tunnel termination object.
pub fn vpn_tunnel_terminations_retrieve(state: &ThanixClient, id: i64) -> Result<VpnTunnelTerminationsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/tunnel-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelTerminationsRetrieveResponse::Http200(r#response.json::<TunnelTermination>()?)) },
		_ => { Ok(VpnTunnelTerminationsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsUpdateResponse {
	Http200(TunnelTermination),
	#[default]
	None
}
/// Put a tunnel termination object.
pub fn vpn_tunnel_terminations_update(state: &ThanixClient, body: WritableTunnelTerminationRequest, id: i64) -> Result<VpnTunnelTerminationsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/tunnel-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelTerminationsUpdateResponse::Http200(r#response.json::<TunnelTermination>()?)) },
		_ => { Ok(VpnTunnelTerminationsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a tunnel termination object.
pub fn vpn_tunnel_terminations_destroy(state: &ThanixClient, id: i64) -> Result<VpnTunnelTerminationsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/tunnel-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnTunnelTerminationsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelTerminationsPartialUpdateResponse {
	Http200(TunnelTermination),
	#[default]
	None
}
/// Patch a tunnel termination object.
pub fn vpn_tunnel_terminations_partial_update(state: &ThanixClient, body: PatchedWritableTunnelTerminationRequest, id: i64) -> Result<VpnTunnelTerminationsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/tunnel-terminations/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelTerminationsPartialUpdateResponse::Http200(r#response.json::<TunnelTermination>()?)) },
		_ => { Ok(VpnTunnelTerminationsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct VpnTunnelsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	encapsulation: Option<Vec<String>>,
	encapsulation__n: Option<Vec<String>>,
	/// Tunnel group (slug)
	group: Option<Vec<String>>,
	/// Tunnel group (slug)
	group__n: Option<Vec<String>>,
	/// Tunnel group (ID)
	group_id: Option<Vec<i64>>,
	/// Tunnel group (ID)
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	/// IPSec profile (name)
	ipsec_profile: Option<Vec<String>>,
	/// IPSec profile (name)
	ipsec_profile__n: Option<Vec<String>>,
	/// IPSec profile (ID)
	ipsec_profile_id: Option<Vec<i64>>,
	/// IPSec profile (ID)
	ipsec_profile_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	tunnel_id: Option<Vec<i64>>,
	tunnel_id__empty: Option<bool>,
	tunnel_id__gt: Option<Vec<i64>>,
	tunnel_id__gte: Option<Vec<i64>>,
	tunnel_id__lt: Option<Vec<i64>>,
	tunnel_id__lte: Option<Vec<i64>>,
	tunnel_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsListResponse {
	Http200(PaginatedTunnelList),
	#[default]
	None
}
/// Get a list of tunnel objects.
pub fn vpn_tunnels_list(state: &ThanixClient, query: VpnTunnelsListQuery) -> Result<VpnTunnelsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/tunnels/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelsListResponse::Http200(r#response.json::<PaginatedTunnelList>()?)) },
		_ => { Ok(VpnTunnelsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsBulkUpdateResponse {
	Http200(Vec<Tunnel>),
	#[default]
	None
}
/// Put a list of tunnel objects.
pub fn vpn_tunnels_bulk_update(state: &ThanixClient, body: Vec<TunnelRequest>) -> Result<VpnTunnelsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/tunnels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelsBulkUpdateResponse::Http200(r#response.json::<Vec<Tunnel>>()?)) },
		_ => { Ok(VpnTunnelsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsCreateResponse {
	Http201(Tunnel),
	#[default]
	None
}
/// Post a list of tunnel objects.
pub fn vpn_tunnels_create(state: &ThanixClient, body: WritableTunnelRequest) -> Result<VpnTunnelsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/vpn/tunnels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(VpnTunnelsCreateResponse::Http201(r#response.json::<Tunnel>()?)) },
		_ => { Ok(VpnTunnelsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of tunnel objects.
pub fn vpn_tunnels_bulk_destroy(state: &ThanixClient, body: Vec<TunnelRequest>) -> Result<VpnTunnelsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/tunnels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnTunnelsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsBulkPartialUpdateResponse {
	Http200(Vec<Tunnel>),
	#[default]
	None
}
/// Patch a list of tunnel objects.
pub fn vpn_tunnels_bulk_partial_update(state: &ThanixClient, body: Vec<TunnelRequest>) -> Result<VpnTunnelsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/tunnels/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<Tunnel>>()?)) },
		_ => { Ok(VpnTunnelsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsRetrieveResponse {
	Http200(Tunnel),
	#[default]
	None
}
/// Get a tunnel object.
pub fn vpn_tunnels_retrieve(state: &ThanixClient, id: i64) -> Result<VpnTunnelsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/vpn/tunnels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelsRetrieveResponse::Http200(r#response.json::<Tunnel>()?)) },
		_ => { Ok(VpnTunnelsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsUpdateResponse {
	Http200(Tunnel),
	#[default]
	None
}
/// Put a tunnel object.
pub fn vpn_tunnels_update(state: &ThanixClient, body: WritableTunnelRequest, id: i64) -> Result<VpnTunnelsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/vpn/tunnels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelsUpdateResponse::Http200(r#response.json::<Tunnel>()?)) },
		_ => { Ok(VpnTunnelsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a tunnel object.
pub fn vpn_tunnels_destroy(state: &ThanixClient, id: i64) -> Result<VpnTunnelsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/vpn/tunnels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(VpnTunnelsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum VpnTunnelsPartialUpdateResponse {
	Http200(Tunnel),
	#[default]
	None
}
/// Patch a tunnel object.
pub fn vpn_tunnels_partial_update(state: &ThanixClient, body: PatchedWritableTunnelRequest, id: i64) -> Result<VpnTunnelsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/vpn/tunnels/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(VpnTunnelsPartialUpdateResponse::Http200(r#response.json::<Tunnel>()?)) },
		_ => { Ok(VpnTunnelsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct WirelessWirelessLanGroupsListQuery {
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	name: Option<Vec<String>>,
	name__empty: Option<bool>,
	name__ic: Option<Vec<String>>,
	name__ie: Option<Vec<String>>,
	name__iew: Option<Vec<String>>,
	name__isw: Option<Vec<String>>,
	name__n: Option<Vec<String>>,
	name__nic: Option<Vec<String>>,
	name__nie: Option<Vec<String>>,
	name__niew: Option<Vec<String>>,
	name__nisw: Option<Vec<String>>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	parent: Option<Vec<String>>,
	parent__n: Option<Vec<String>>,
	parent_id: Option<Vec<i64>>,
	parent_id__n: Option<Vec<i64>>,
	/// Search
	q: Option<String>,
	slug: Option<Vec<String>>,
	slug__empty: Option<bool>,
	slug__ic: Option<Vec<String>>,
	slug__ie: Option<Vec<String>>,
	slug__iew: Option<Vec<String>>,
	slug__isw: Option<Vec<String>>,
	slug__n: Option<Vec<String>>,
	slug__nic: Option<Vec<String>>,
	slug__nie: Option<Vec<String>>,
	slug__niew: Option<Vec<String>>,
	slug__nisw: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsListResponse {
	Http200(PaginatedWirelessLANGroupList),
	#[default]
	None
}
/// Get a list of wireless LAN group objects.
pub fn wireless_wireless_lan_groups_list(state: &ThanixClient, query: WirelessWirelessLanGroupsListQuery) -> Result<WirelessWirelessLanGroupsListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/wireless/wireless-lan-groups/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLanGroupsListResponse::Http200(r#response.json::<PaginatedWirelessLANGroupList>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsBulkUpdateResponse {
	Http200(Vec<WirelessLANGroup>),
	#[default]
	None
}
/// Put a list of wireless LAN group objects.
pub fn wireless_wireless_lan_groups_bulk_update(state: &ThanixClient, body: Vec<WirelessLANGroupRequest>) -> Result<WirelessWirelessLanGroupsBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/wireless/wireless-lan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLanGroupsBulkUpdateResponse::Http200(r#response.json::<Vec<WirelessLANGroup>>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsCreateResponse {
	Http201(WirelessLANGroup),
	#[default]
	None
}
/// Post a list of wireless LAN group objects.
pub fn wireless_wireless_lan_groups_create(state: &ThanixClient, body: WritableWirelessLANGroupRequest) -> Result<WirelessWirelessLanGroupsCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/wireless/wireless-lan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(WirelessWirelessLanGroupsCreateResponse::Http201(r#response.json::<WirelessLANGroup>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of wireless LAN group objects.
pub fn wireless_wireless_lan_groups_bulk_destroy(state: &ThanixClient, body: Vec<WirelessLANGroupRequest>) -> Result<WirelessWirelessLanGroupsBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/wireless/wireless-lan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(WirelessWirelessLanGroupsBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsBulkPartialUpdateResponse {
	Http200(Vec<WirelessLANGroup>),
	#[default]
	None
}
/// Patch a list of wireless LAN group objects.
pub fn wireless_wireless_lan_groups_bulk_partial_update(state: &ThanixClient, body: Vec<WirelessLANGroupRequest>) -> Result<WirelessWirelessLanGroupsBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/wireless/wireless-lan-groups/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLanGroupsBulkPartialUpdateResponse::Http200(r#response.json::<Vec<WirelessLANGroup>>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsRetrieveResponse {
	Http200(WirelessLANGroup),
	#[default]
	None
}
/// Get a wireless LAN group object.
pub fn wireless_wireless_lan_groups_retrieve(state: &ThanixClient, id: i64) -> Result<WirelessWirelessLanGroupsRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/wireless/wireless-lan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLanGroupsRetrieveResponse::Http200(r#response.json::<WirelessLANGroup>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsUpdateResponse {
	Http200(WirelessLANGroup),
	#[default]
	None
}
/// Put a wireless LAN group object.
pub fn wireless_wireless_lan_groups_update(state: &ThanixClient, body: WritableWirelessLANGroupRequest, id: i64) -> Result<WirelessWirelessLanGroupsUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/wireless/wireless-lan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLanGroupsUpdateResponse::Http200(r#response.json::<WirelessLANGroup>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a wireless LAN group object.
pub fn wireless_wireless_lan_groups_destroy(state: &ThanixClient, id: i64) -> Result<WirelessWirelessLanGroupsDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/wireless/wireless-lan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(WirelessWirelessLanGroupsDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLanGroupsPartialUpdateResponse {
	Http200(WirelessLANGroup),
	#[default]
	None
}
/// Patch a wireless LAN group object.
pub fn wireless_wireless_lan_groups_partial_update(state: &ThanixClient, body: PatchedWritableWirelessLANGroupRequest, id: i64) -> Result<WirelessWirelessLanGroupsPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/wireless/wireless-lan-groups/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLanGroupsPartialUpdateResponse::Http200(r#response.json::<WirelessLANGroup>()?)) },
		_ => { Ok(WirelessWirelessLanGroupsPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct WirelessWirelessLansListQuery {
	auth_cipher: Option<Vec<String>>,
	auth_cipher__n: Option<Vec<String>>,
	auth_psk: Option<Vec<String>>,
	auth_psk__empty: Option<bool>,
	auth_psk__ic: Option<Vec<String>>,
	auth_psk__ie: Option<Vec<String>>,
	auth_psk__iew: Option<Vec<String>>,
	auth_psk__isw: Option<Vec<String>>,
	auth_psk__n: Option<Vec<String>>,
	auth_psk__nic: Option<Vec<String>>,
	auth_psk__nie: Option<Vec<String>>,
	auth_psk__niew: Option<Vec<String>>,
	auth_psk__nisw: Option<Vec<String>>,
	auth_type: Option<Vec<String>>,
	auth_type__n: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	group: Option<Vec<i64>>,
	group__n: Option<Vec<i64>>,
	group_id: Option<Vec<i64>>,
	group_id__n: Option<Vec<i64>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	ssid: Option<Vec<String>>,
	ssid__empty: Option<bool>,
	ssid__ic: Option<Vec<String>>,
	ssid__ie: Option<Vec<String>>,
	ssid__iew: Option<Vec<String>>,
	ssid__isw: Option<Vec<String>>,
	ssid__n: Option<Vec<String>>,
	ssid__nic: Option<Vec<String>>,
	ssid__nie: Option<Vec<String>>,
	ssid__niew: Option<Vec<String>>,
	ssid__nisw: Option<Vec<String>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,
	vlan_id: Option<Vec<i64>>,
	vlan_id__n: Option<Vec<i64>>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansListResponse {
	Http200(PaginatedWirelessLANList),
	#[default]
	None
}
/// Get a list of wireless LAN objects.
pub fn wireless_wireless_lans_list(state: &ThanixClient, query: WirelessWirelessLansListQuery) -> Result<WirelessWirelessLansListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/wireless/wireless-lans/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLansListResponse::Http200(r#response.json::<PaginatedWirelessLANList>()?)) },
		_ => { Ok(WirelessWirelessLansListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansBulkUpdateResponse {
	Http200(Vec<WirelessLAN>),
	#[default]
	None
}
/// Put a list of wireless LAN objects.
pub fn wireless_wireless_lans_bulk_update(state: &ThanixClient, body: Vec<WirelessLANRequest>) -> Result<WirelessWirelessLansBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/wireless/wireless-lans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLansBulkUpdateResponse::Http200(r#response.json::<Vec<WirelessLAN>>()?)) },
		_ => { Ok(WirelessWirelessLansBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansCreateResponse {
	Http201(WirelessLAN),
	#[default]
	None
}
/// Post a list of wireless LAN objects.
pub fn wireless_wireless_lans_create(state: &ThanixClient, body: WritableWirelessLANRequest) -> Result<WirelessWirelessLansCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/wireless/wireless-lans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(WirelessWirelessLansCreateResponse::Http201(r#response.json::<WirelessLAN>()?)) },
		_ => { Ok(WirelessWirelessLansCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of wireless LAN objects.
pub fn wireless_wireless_lans_bulk_destroy(state: &ThanixClient, body: Vec<WirelessLANRequest>) -> Result<WirelessWirelessLansBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/wireless/wireless-lans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(WirelessWirelessLansBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansBulkPartialUpdateResponse {
	Http200(Vec<WirelessLAN>),
	#[default]
	None
}
/// Patch a list of wireless LAN objects.
pub fn wireless_wireless_lans_bulk_partial_update(state: &ThanixClient, body: Vec<WirelessLANRequest>) -> Result<WirelessWirelessLansBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/wireless/wireless-lans/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLansBulkPartialUpdateResponse::Http200(r#response.json::<Vec<WirelessLAN>>()?)) },
		_ => { Ok(WirelessWirelessLansBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansRetrieveResponse {
	Http200(WirelessLAN),
	#[default]
	None
}
/// Get a wireless LAN object.
pub fn wireless_wireless_lans_retrieve(state: &ThanixClient, id: i64) -> Result<WirelessWirelessLansRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/wireless/wireless-lans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLansRetrieveResponse::Http200(r#response.json::<WirelessLAN>()?)) },
		_ => { Ok(WirelessWirelessLansRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansUpdateResponse {
	Http200(WirelessLAN),
	#[default]
	None
}
/// Put a wireless LAN object.
pub fn wireless_wireless_lans_update(state: &ThanixClient, body: WritableWirelessLANRequest, id: i64) -> Result<WirelessWirelessLansUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/wireless/wireless-lans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLansUpdateResponse::Http200(r#response.json::<WirelessLAN>()?)) },
		_ => { Ok(WirelessWirelessLansUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a wireless LAN object.
pub fn wireless_wireless_lans_destroy(state: &ThanixClient, id: i64) -> Result<WirelessWirelessLansDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/wireless/wireless-lans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(WirelessWirelessLansDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLansPartialUpdateResponse {
	Http200(WirelessLAN),
	#[default]
	None
}
/// Patch a wireless LAN object.
pub fn wireless_wireless_lans_partial_update(state: &ThanixClient, body: PatchedWritableWirelessLANRequest, id: i64) -> Result<WirelessWirelessLansPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/wireless/wireless-lans/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLansPartialUpdateResponse::Http200(r#response.json::<WirelessLAN>()?)) },
		_ => { Ok(WirelessWirelessLansPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
pub struct WirelessWirelessLinksListQuery {
	auth_cipher: Option<Vec<String>>,
	auth_cipher__n: Option<Vec<String>>,
	auth_psk: Option<Vec<String>>,
	auth_psk__empty: Option<bool>,
	auth_psk__ic: Option<Vec<String>>,
	auth_psk__ie: Option<Vec<String>>,
	auth_psk__iew: Option<Vec<String>>,
	auth_psk__isw: Option<Vec<String>>,
	auth_psk__n: Option<Vec<String>>,
	auth_psk__nic: Option<Vec<String>>,
	auth_psk__nie: Option<Vec<String>>,
	auth_psk__niew: Option<Vec<String>>,
	auth_psk__nisw: Option<Vec<String>>,
	auth_type: Option<Vec<String>>,
	auth_type__n: Option<Vec<String>>,
	created: Option<Vec<String>>,
	created__empty: Option<Vec<String>>,
	created__gt: Option<Vec<String>>,
	created__gte: Option<Vec<String>>,
	created__lt: Option<Vec<String>>,
	created__lte: Option<Vec<String>>,
	created__n: Option<Vec<String>>,
	created_by_request: Option<String>,
	description: Option<Vec<String>>,
	description__empty: Option<bool>,
	description__ic: Option<Vec<String>>,
	description__ie: Option<Vec<String>>,
	description__iew: Option<Vec<String>>,
	description__isw: Option<Vec<String>>,
	description__n: Option<Vec<String>>,
	description__nic: Option<Vec<String>>,
	description__nie: Option<Vec<String>>,
	description__niew: Option<Vec<String>>,
	description__nisw: Option<Vec<String>>,
	id: Option<Vec<i64>>,
	id__empty: Option<bool>,
	id__gt: Option<Vec<i64>>,
	id__gte: Option<Vec<i64>>,
	id__lt: Option<Vec<i64>>,
	id__lte: Option<Vec<i64>>,
	id__n: Option<Vec<i64>>,
	interface_a_id: Option<Vec<i64>>,
	interface_a_id__empty: Option<Vec<i64>>,
	interface_a_id__gt: Option<Vec<i64>>,
	interface_a_id__gte: Option<Vec<i64>>,
	interface_a_id__lt: Option<Vec<i64>>,
	interface_a_id__lte: Option<Vec<i64>>,
	interface_a_id__n: Option<Vec<i64>>,
	interface_b_id: Option<Vec<i64>>,
	interface_b_id__empty: Option<Vec<i64>>,
	interface_b_id__gt: Option<Vec<i64>>,
	interface_b_id__gte: Option<Vec<i64>>,
	interface_b_id__lt: Option<Vec<i64>>,
	interface_b_id__lte: Option<Vec<i64>>,
	interface_b_id__n: Option<Vec<i64>>,
	last_updated: Option<Vec<String>>,
	last_updated__empty: Option<Vec<String>>,
	last_updated__gt: Option<Vec<String>>,
	last_updated__gte: Option<Vec<String>>,
	last_updated__lt: Option<Vec<String>>,
	last_updated__lte: Option<Vec<String>>,
	last_updated__n: Option<Vec<String>>,
	/// Number of results to return per page.
	limit: Option<i64>,
	modified_by_request: Option<String>,
	/// The initial index from which to return the results.
	offset: Option<i64>,
	/// Which field to use when ordering the results.
	ordering: Option<String>,
	/// Search
	q: Option<String>,
	ssid: Option<Vec<String>>,
	ssid__empty: Option<bool>,
	ssid__ic: Option<Vec<String>>,
	ssid__ie: Option<Vec<String>>,
	ssid__iew: Option<Vec<String>>,
	ssid__isw: Option<Vec<String>>,
	ssid__n: Option<Vec<String>>,
	ssid__nic: Option<Vec<String>>,
	ssid__nie: Option<Vec<String>>,
	ssid__niew: Option<Vec<String>>,
	ssid__nisw: Option<Vec<String>>,
	status: Option<Vec<String>>,
	status__n: Option<Vec<String>>,
	tag: Option<Vec<String>>,
	tag__n: Option<Vec<String>>,
	/// Tenant (slug)
	tenant: Option<Vec<String>>,
	/// Tenant (slug)
	tenant__n: Option<Vec<String>>,
	/// Tenant Group (slug)
	tenant_group: Option<Vec<i64>>,
	/// Tenant Group (slug)
	tenant_group__n: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id: Option<Vec<i64>>,
	/// Tenant Group (ID)
	tenant_group_id__n: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id: Option<Vec<i64>>,
	/// Tenant (ID)
	tenant_id__n: Option<Vec<i64>>,
	updated_by_request: Option<String>,

}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksListResponse {
	Http200(PaginatedWirelessLinkList),
	#[default]
	None
}
/// Get a list of wireless link objects.
pub fn wireless_wireless_links_list(state: &ThanixClient, query: WirelessWirelessLinksListQuery) -> Result<WirelessWirelessLinksListResponse, Error> {
	let r#response = state.client.get(format!("{}/api/wireless/wireless-links/?{}", state.base_url, serde_qs::to_string(&query).unwrap()))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLinksListResponse::Http200(r#response.json::<PaginatedWirelessLinkList>()?)) },
		_ => { Ok(WirelessWirelessLinksListResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksBulkUpdateResponse {
	Http200(Vec<WirelessLink>),
	#[default]
	None
}
/// Put a list of wireless link objects.
pub fn wireless_wireless_links_bulk_update(state: &ThanixClient, body: Vec<WirelessLinkRequest>) -> Result<WirelessWirelessLinksBulkUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/wireless/wireless-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLinksBulkUpdateResponse::Http200(r#response.json::<Vec<WirelessLink>>()?)) },
		_ => { Ok(WirelessWirelessLinksBulkUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksCreateResponse {
	Http201(WirelessLink),
	#[default]
	None
}
/// Post a list of wireless link objects.
pub fn wireless_wireless_links_create(state: &ThanixClient, body: WritableWirelessLinkRequest) -> Result<WirelessWirelessLinksCreateResponse, Error> {
	let r#response = state.client.post(format!("{}/api/wireless/wireless-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		201 => { Ok(WirelessWirelessLinksCreateResponse::Http201(r#response.json::<WirelessLink>()?)) },
		_ => { Ok(WirelessWirelessLinksCreateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksBulkDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a list of wireless link objects.
pub fn wireless_wireless_links_bulk_destroy(state: &ThanixClient, body: Vec<WirelessLinkRequest>) -> Result<WirelessWirelessLinksBulkDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/wireless/wireless-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(WirelessWirelessLinksBulkDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksBulkPartialUpdateResponse {
	Http200(Vec<WirelessLink>),
	#[default]
	None
}
/// Patch a list of wireless link objects.
pub fn wireless_wireless_links_bulk_partial_update(state: &ThanixClient, body: Vec<WirelessLinkRequest>) -> Result<WirelessWirelessLinksBulkPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/wireless/wireless-links/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLinksBulkPartialUpdateResponse::Http200(r#response.json::<Vec<WirelessLink>>()?)) },
		_ => { Ok(WirelessWirelessLinksBulkPartialUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksRetrieveResponse {
	Http200(WirelessLink),
	#[default]
	None
}
/// Get a wireless link object.
pub fn wireless_wireless_links_retrieve(state: &ThanixClient, id: i64) -> Result<WirelessWirelessLinksRetrieveResponse, Error> {
	let r#response = state.client.get(format!("{}/api/wireless/wireless-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLinksRetrieveResponse::Http200(r#response.json::<WirelessLink>()?)) },
		_ => { Ok(WirelessWirelessLinksRetrieveResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksUpdateResponse {
	Http200(WirelessLink),
	#[default]
	None
}
/// Put a wireless link object.
pub fn wireless_wireless_links_update(state: &ThanixClient, body: WritableWirelessLinkRequest, id: i64) -> Result<WirelessWirelessLinksUpdateResponse, Error> {
	let r#response = state.client.put(format!("{}/api/wireless/wireless-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLinksUpdateResponse::Http200(r#response.json::<WirelessLink>()?)) },
		_ => { Ok(WirelessWirelessLinksUpdateResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksDestroyResponse {
	Http204,
	#[default]
	None
}
/// Delete a wireless link object.
pub fn wireless_wireless_links_destroy(state: &ThanixClient, id: i64) -> Result<WirelessWirelessLinksDestroyResponse, Error> {
	let r#response = state.client.delete(format!("{}/api/wireless/wireless-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.send()?;
	match r#response.status().as_u16() {
		_ => { Ok(WirelessWirelessLinksDestroyResponse::None) }
	}
}
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(untagged)]
pub enum WirelessWirelessLinksPartialUpdateResponse {
	Http200(WirelessLink),
	#[default]
	None
}
/// Patch a wireless link object.
pub fn wireless_wireless_links_partial_update(state: &ThanixClient, body: PatchedWritableWirelessLinkRequest, id: i64) -> Result<WirelessWirelessLinksPartialUpdateResponse, Error> {
	let r#response = state.client.patch(format!("{}/api/wireless/wireless-links/{id}/", state.base_url))
		.header("Authorization", format!("Token {}", state.authentication_token))
		.json(&body)
		.send()?;
	match r#response.status().as_u16() {
		200 => { Ok(WirelessWirelessLinksPartialUpdateResponse::Http200(r#response.json::<WirelessLink>()?)) },
		_ => { Ok(WirelessWirelessLinksPartialUpdateResponse::None) }
	}
}
